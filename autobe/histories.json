[{"type":"userMessage","id":"0199751f-1f58-7268-b247-603b78aa6267","created_at":"2025-09-23T05:49:57.976Z","contents":[{"type":"text","text":"I want to create a Todo list application.\r\n\r\nWhen I build an application, I only want the minimum functionality required for Todo list.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit."}]},{"id":"0199751f-1f5f-7328-8b6b-2c2415dce552","type":"userMessage","contents":[{"type":"text","text":"I want to create a Todo list application.\r\n\r\nWhen I build an application, I only want the minimum functionality required for Todo list.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit.\n\nMake every determinant by yourself, and just show me the analysis report. call analyze function."}],"created_at":"2025-09-23T05:49:57.983Z"},{"type":"analyze","id":"01997521-f70e-7709-ae16-b667d3ab3959","reason":"The user requested a requirements analysis report for a minimal Todo list application and delegated all decisions to me. The goal is to specify only the core features necessary for a basic Todo list, targeting users who are not familiar with programming and desire the simplest functional version possible.","prefix":"todoList","roles":[{"name":"user","description":"A registered member who can create, read, update, and delete their own todos. Can check or uncheck tasks and view a list of their todos. Cannot access or modify other users' data.","kind":"member"},{"name":"admin","description":"Has all user privileges, plus can view and delete any user's todos if necessary for administration. Can manage the service's operational settings.","kind":"admin"}],"files":[{"reason":"To provide a navigational overview and descriptive links to all core documents for the Todo list application, including role-based access information and developer autonomy note as per business documentation standards.","filename":"00-toc.md","content":"# Functional Requirements for Minimal Todo List Application\n\n## Scope of Application\nThis document defines all business-level requirements for a minimal Todo list application. The requirements cover the core functionality needed for users to manage their personal task lists and for administrators to fulfill operational duties. No technical or implementation details are included—only the business processes and constraints are described, using EARS format for all actionable requirements.\n\n## Core Features\n\n### Add Task/Todo\n- WHEN a user submits a valid todo item, THE system SHALL save the todo to that user's personal list.\n- IF a user submits an empty or whitespace-only todo, THEN THE system SHALL reject the submission and present an appropriate error message.\n\n### View Task List\n- WHEN a user requests to view their todo list, THE system SHALL display all todos belonging to that user in creation order, most recent first.\n- WHERE todos exist for a user, THE system SHALL provide a means for the user to distinguish completed from uncompleted tasks (e.g., visual indicator).\n\n### Mark Task as Completed\n- WHEN a user marks any of their todos as completed, THE system SHALL update the completion status of the selected task to \"completed\" without altering other fields.\n- WHEN a user marks any completed todo as uncompleted, THE system SHALL update the status to \"uncompleted\" only for the selected task.\n\n### Edit Task Content\n- WHEN a user edits the content of an existing todo, THE system SHALL update only the content field of that todo, provided the new content passes validation.\n- IF a user tries to edit a todo with empty or invalid content, THEN THE system SHALL reject the change and provide an error message.\n\n### Delete Task\n- WHEN a user deletes a todo they own, THE system SHALL permanently remove that todo from the user's list.\n\n## Business Logic Rules\n\n### Ownership and Access\n- THE system SHALL restrict access so that only the creator of a todo can view, edit, or delete that task, except for admin users.\n- WHEN an admin views any user's todos, THE system SHALL grant access for administrative purposes but require clear logging of this action.\n- WHEN an admin deletes a user's todo, THE system SHALL remove the todo and log the operation for audit purposes.\n\n### Task Content Rules\n- THE system SHALL enforce a maximum length of 255 characters for each todo's content.\n- IF content exceeds 255 characters, THEN THE system SHALL reject the todo with a relevant error message.\n\n### Status Defaults and Changes\n- WHEN a todo is created, THE system SHALL set its status to \"uncompleted\" by default.\n- WHEN a todo is successfully deleted, THE system SHALL remove all references to that todo in the user's active list.\n\n## Task and List Management\n\n### List Retrieval and Filtering\n- WHEN a user requests their todo list, THE system SHALL return all their todos, ordered with the most recently created tasks first.\n- WHERE many todos exist, THE system SHALL support paginated listing of tasks with a default page size of 20.\n\n### Bulk Operations (Optional Minimalism)\n- WHERE business requirements call for absolute minimalism, THE system SHALL NOT permit bulk operations on tasks (such as mass deletion or mark all as complete) at MVP stage.\n\n## Edge Cases and Exceptions\n\n### Invalid or Unauthorized Actions\n- IF a user attempts to view, edit, or delete a todo that does not exist or that belongs to another user, THEN THE system SHALL deny the operation and give a clear error notification.\n- IF an unauthenticated user (not logged in) attempts to access todo-related functions, THEN THE system SHALL require authentication before proceeding.\n- IF an admin performs any action affecting another user's todos, THEN THE system SHALL create an audit log entry with time, admin username, and action details.\n\n### Empty List Handling\n- IF a user has no todos, THEN THE system SHALL display a message indicating the list is empty.\n\n### Input Validation\n- THE system SHALL enforce that each todo must have non-empty, non-whitespace content and must not contain control characters.\n\n## Success Criteria\n- WHEN all requirements described above are implemented and verifiable by business tests, THE system SHALL be considered compliant with minimal functional requirements.\n- THE system SHALL pass all acceptance tests for the following scenarios without error:\n  - Adding, viewing, editing, deleting a todo for a user\n  - Marking tasks as completed/uncompleted\n  - Preventing access to todos by unauthorized users\n  - Enforcing business rules on content length and validation\n  - Admin actions on user data are logged correctly\n- THE system SHALL respond to all business operations (create, read, update, delete, mark complete) within 2 seconds for user-perceived performance.\n\n## Visual Flow (Mermaid Diagram)\n```mermaid\ngraph LR\n  UA[\"User(Log in)\"] --> NA[\"Create Todo\"]\n  NA --> VB[\"Validate content\"]\n  VB -->|\"Valid\"| SC[\"Save to user's todo list (status: uncompleted)\"]\n  VB -->|\"Invalid\"| ER[\"Show error\"]\n  UA --> VA[\"View Todos\"]\n  VA --> RL[\"Retrieve user's sorted todo list\"]\n  VA --> EL[\"Show 'no todos' message if empty\"]\n  UA --> MC[\"Mark as completed/uncompleted\"]\n  MC --> US[\"Update completion status\"]\n  UA --> ED[\"Edit todo content\"]\n  ED --> VC[\"Validate edit\"]\n  VC -->|\"Valid\"| UPD[\"Update content\"]\n  VC -->|\"Invalid\"| ER\n  UA --> DL[\"Delete Todo\"]\n  DL --> RM[\"Remove from list\"]\n  UA -.->|\"Try another's todo\"| ERR[\"Deny access, show error\"]\n  A[\"Admin\"] -->|\"View/Delete any todo\"| AUD[\"Audit log action\"]\n  A -->|\"Delete user's todo\"| RM\n```\n"},{"reason":"To establish the service's business vision, goals, and reasons for existence, along with a market-driven value proposition and success metrics, before specifying requirements or user scenarios.","filename":"01-service-overview.md","documentType":"service-overview","outline":["Introduction","Business Model","Core Value Proposition","Objectives and Key Results","Competitor Overview","Service Roadmap"],"audience":"general","content":"# Todo List Service Overview and Business Vision\n\n## Introduction\nThe todoList application is designed as a streamlined, user-centric platform that allows individuals to efficiently organize, manage, and track their personal tasks. With increasing digital lifestyles and the demand for simple productivity tools, there is a significant market opportunity for a minimal yet powerful Todo list service that prioritizes ease of use, data privacy, and reliable performance. This document defines the foundational business vision, objectives, and market positioning for the todoList service.\n\n## Business Model\n\n### Why This Service Exists\nDigital task and time management are essential needs in modern life and work. Many individuals struggle with disorganization, missed commitments, and decreased productivity due to ineffective or overloaded tools. While there are numerous existing solutions, many are bloated with features, confusing interfaces, or privacy concerns. The todoList service exists to fill the gap for users who desire a minimal, intuitive, and secure todo solution focused solely on core list management functionality—without distractions or complexity. By providing just the essentials, todoList enables users to regain control of their daily routines with lower cognitive friction and a short learning curve.\n\n### Revenue Strategy\nThe initial release of todoList focuses on user acquisition and engagement, with no monetization barriers. The core service is free and accessible to everyone. Future revenue models may include: \n- Optional premium features for task analytics or cloud backup\n- Pro user subscriptions targeting advanced personal or team usage\n- Selective cost-per-action partnerships with productivity tool ecosystems\n- Ethical in-app sponsorships or integrations (never intrusive advertisements)\n\n### Growth Plan\n- Launch with a minimum viable product (MVP) focused on usability and reliability\n- Leverage organic digital channels (app stores, social sharing) for initial growth\n- Encourage users to recommend the service via fast, positive experiences\n- Iteratively expand with additional features (optional reminders, integrations) based on validated user demand\n- Gather product analytics to continually improve retention and satisfaction\n\n### Success Metrics\nKey business indicators for evaluating service performance:\n- Monthly Active Users (MAU) and Daily Active Users (DAU)\n- New user signups per month\n- Task creation rate per user\n- User retention at 7/30/90 days\n- Churn rate (uninstalls or inactive accounts)\n- Net Promoter Score (NPS) or direct user satisfaction feedback\n- Incident-free uptime and average API response time\n\n## Core Value Proposition\nThe todoList service delivers peace of mind and enhanced productivity for users who want a simple, distraction-free way to manage daily tasks. Compared to feature-heavy competitors, todoList stands out by focusing strictly on reliability, speed, security, and user empowerment over their own data. There are no unnecessary bells and whistles—only the tools needed to efficiently create, track, check off, edit, and remove todos.\n\n## Objectives and Key Results (OKRs)\n- Objective: Launch a minimal, bug-free Todo list app with intuitive user onboarding\n  - KR1: Achieve at least 1,000 MAU within three months of launch\n  - KR2: Maintain >95% successful task creation and completion rates\n  - KR3: Attain an average task operation API response time < 1 second\n  - KR4: Ensure at least 80% of users report satisfaction or find the product useful\n  - KR5: Maintain >99.9% service uptime\n\n## Competitor Overview\nThe productivity tool market includes major players (e.g., Todoist, Microsoft To Do, Google Tasks, Any.do) as well as a range of niche mobile/web apps.\n- Strengths of competitors: advanced features, integrations, brand recognition\n- Weaknesses: potential complexity, privacy trade-offs, overwhelming interfaces for basic users\n- Differentiation for todoList: hyper-focus on minimal, essential functionality, and genuine respect for user privacy and simplicity. todoList will not collect more data than necessary and will always put user needs and autonomy first.\n\n## Service Roadmap\n1. **MVP Launch**: Registration, authentication, and personal todo CRUD operations with local data persistence\n2. **First Iteration**: Error handling, task check-off, completion/archiving, admin dashboard for user support\n3. **Early Growth Phase**: User feedback collection, refinement, added optional notification/reminder capability\n4. **Expansion**: Feature rollouts based on usage analytics, initial preparations for premium features and integrations (with user opt-in)\n\nThe roadmap is designed for maximum adaptability, with a commitment to never sacrifice clarity, transparency, or user trust in the pursuit of growth.\n"},{"reason":"To define all user roles, permissions, and authentication flows for the Todo list application, covering both end user and administrative needs in business terms and ensuring secure, role-based access to API functionality.","filename":"02-user-roles-and-authentication.md","documentType":"requirement","outline":["User Role Definitions","Permissions and Restrictions","Authentication Requirements","Role Hierarchy and Permission Matrix","JWT and Token Management"],"audience":"backend developers","content":"# User Roles and Authentication Requirements for Todo List Application\n\n## User Role Definitions\nThe Todo list application defines two primary user roles: **user** and **admin**.\n\n### Role: user\n- A registered member who can create, read, update, and delete their own todos.\n- Can mark their own todos as complete or incomplete.\n- May view a personal list of their todos.\n- Cannot access or modify other users' data or any administrative settings.\n\n### Role: admin\n- Has all privileges of a user.\n- Can view any user's todos for maintenance or compliance.\n- Can delete any user's todos for administrative or policy reasons.\n- Can manage service operational settings (e.g., user management, service announcements).\n- Cannot edit or create todos on behalf of another user (unless specified for business recovery).\n\n## Permissions and Restrictions\n\n### General Principle\nTHE system SHALL enforce strict, role-based access control for all core business actions, with no overlap in data manipulation between users and administrative tasks, except where specified for admin intervention.\n\n### User (user role)\n- THE user SHALL be able to create new todo items for their own account.\n- WHEN user creates a todo, THE system SHALL associate the todo ONLY with that user.\n- THE user SHALL be able to list, view, edit, and delete only their own todos.\n- IF a user tries to access or modify another user's data, THEN THE system SHALL deny access and provide a clear error message.\n- THE user SHALL be able to log in, log out, recover a lost password, and manage their own session.\n- THE user SHALL NOT access service-wide settings or other users' data.\n\n### Admin (admin role)\n- THE admin SHALL have all capabilities of a user as described above.\n- THE admin SHALL be able to list, view, and delete any user's todos. This action SHALL be used only for legitimate administrative or compliance purposes.\n- WHEN deleting another user's todo, THE admin SHALL trigger a logging process for audit and traceability.\n- THE admin SHALL be able to manage operational configurations, such as announcements, user status changes, and access restrictions.\n- THE admin SHALL NOT create or edit todos for other users except in explicit business recovery cases (such as restoring data after failure), which SHALL be documented and logged.\n\n## Authentication Requirements\n\n### Registration Process\n- THE system SHALL allow new users to register using a valid email address and password.\n- WHEN a user registers, THE system SHALL verify that the provided email is unique and not previously registered.\n- THE system SHALL provide a mechanism for the user to verify their email (e.g., via a time-limited verification code).\n- IF registration fails due to already used email, THEN THE system SHALL display a business-level error message.\n\n### Login and Session Management\n- THE user SHALL be able to authenticate using their registered credentials (email and password).\n- WHEN login is successful, THE system SHALL generate an authentication token (see Token Management section) and initiate a new session for the user.\n- THE system SHALL prevent login attempts with invalid credentials.\n- IF a login attempt fails, THEN THE system SHALL show a clear, business-appropriate error message (e.g., \"Invalid email or password\").\n- THE system SHALL allow the user to log out at any time, invalidating any active session(s).\n\n### Password and Account Management\n- THE system SHALL provide a secure password reset process, using either a time-limited code or secure email link.\n- WHEN a user requests a password reset, THE system SHALL send the appropriate verification to the user's registered email.\n- IF the password reset link or code is expired or invalid, THEN THE system SHALL prevent reset and inform the user.\n- THE user SHALL be able to change their password from their account settings.\n- THE user SHALL be able to revoke all active sessions if compromised.\n\n### Account Integrity\n- THE system SHALL ensure that email-verification status is required before allowing full user functionality (e.g., creating todos).\n- THE system SHALL not authorize dormant, deactivated, or deleted accounts.\n\n## Role Hierarchy and Permission Matrix\n\nThe roles are strictly hierarchical: admin > user. Admin inherits all user permissions, with additional administrative capabilities as specified.\n\n| Action                                                    | user | admin |\n|-----------------------------------------------------------|:----:|:-----:|\n| Register                                                  |  ✅  |   ✅  |\n| Log in/out                                                |  ✅  |   ✅  |\n| Create own todo                                           |  ✅  |   ✅  |\n| View own todos                                            |  ✅  |   ✅  |\n| Edit own todos                                            |  ✅  |   ✅  |\n| Delete own todos                                          |  ✅  |   ✅  |\n| Mark own todo completed/incomplete                        |  ✅  |   ✅  |\n| View other users' todos                                   |  ❌  |   ✅  |\n| Delete other users' todos                                 |  ❌  |   ✅  |\n| Manage service settings, announcements, or configurations |  ❌  |   ✅  |\n| Manage users                                              |  ❌  |   ✅  |\n| Restore or recover user data (in special cases)           |  ❌  |   ✅  |\n\n## JWT and Token Management\n\n- THE system SHALL use JWT (JSON Web Token) for authentication and user session management.\n- WHEN a user logs in, THE system SHALL issue a JWT access token (valid for 15–30 minutes) and a refresh token (valid for up to 30 days).\n- THE JWT payload SHALL contain userId, role, and permissions array. No password or sensitive information SHALL be included.\n- THE system SHALL verify JWT authenticity for every API call that requires authentication, denying access otherwise.\n- THE system SHALL have a process for revoking tokens upon user logout or in case of a security incident (e.g., token compromise).\n- WHERE a refresh token is used, THE system SHALL issue a new access token only after validating the refresh token and ensuring the session is still valid and the account is active.\n- THE JWT secret or signing key SHALL be securely managed and must not be exposed via configuration endpoints.\n\n## Business Rules and Security (EARS Format)\n- WHEN a non-authenticated user attempts to access a protected resource, THE system SHALL deny the request and return a business-oriented error message.\n- WHEN a token is expired or invalid, THE system SHALL prompt the user to log in again.\n- WHEN an admin performs any action affecting another user's data, THE system SHALL log the action for audit purposes.\n- IF a user attempts any prohibited operation per their role (e.g., deleting another user's todo), THEN THE system SHALL prevent the action and provide a clear, business-level error message.\n- WHILE a user is logged in and authenticated, THE system SHALL validate the session token on every privileged request.\n\n## Example Authentication and Authorization Flow (Mermaid Diagram)\n```mermaid\ngraph LR\nA[\"User Registers\"] --> B[\"Email Verification\"]\nB --> |\"Verified\"| C[\"Login\"]\nC --> D[\"JWT Issued (Access/Refresh)\"]\nD --> E[\"Access API (e.g., Get Todos)\"]\nE --> F{\"Has Permission?\"}\nF -->|\"Yes\"| G[\"Action Allowed\"]\nF -->|\"No\"| H[\"Show Error Message\"]\nG --> I[\"Action Completed\"]\nH --> J[\"Access Denied\"]\nC --> K[\"Logout\"]\nK --> L[\"Revoke Token\"]\n```\n\n## Compliance and Best Practices\n- THE system SHALL never expose authentication errors in a way that leaks internals or enables user enumeration.\n- All actions affecting cross-user data SHALL be securely logged for business audit and compliance.\n- All requirements above focus on business rules—technical implementation, APIs, and data stores are defined at developer discretion.\n"},{"reason":"To clearly state all business-level functional requirements for the minimal Todo list application, setting concrete and testable expectations for what the system must deliver, without specifying technical solutions.","filename":"03-functional-requirements.md","documentType":"requirement","outline":["Scope of Application","Core Features","Business Logic Rules","Task and List Management","Edge Cases and Exceptions","Success Criteria"],"audience":"backend developers","content":"# Functional Requirements for Minimal Todo List Application\n\n## Scope of Application\nThis document defines all business-level requirements for a minimal Todo list application. The requirements cover the core functionality needed for users to manage their personal task lists and for administrators to fulfill operational duties. No technical or implementation details are included—only the business processes and constraints are described, using EARS format for all actionable requirements.\n\n## Core Features\n\n### Add Task/Todo\n- WHEN a user submits a valid todo item, THE system SHALL save the todo to that user's personal list.\n- IF a user submits an empty or whitespace-only todo, THEN THE system SHALL reject the submission and present an appropriate error message.\n\n### View Task List\n- WHEN a user requests to view their todo list, THE system SHALL display all todos belonging to that user in creation order, most recent first.\n- WHERE todos exist for a user, THE system SHALL provide a means for the user to distinguish completed from uncompleted tasks (e.g., visual indicator).\n\n### Mark Task as Completed\n- WHEN a user marks any of their todos as completed, THE system SHALL update the completion status of the selected task to \"completed\" without altering other fields.\n- WHEN a user marks any completed todo as uncompleted, THE system SHALL update the status to \"uncompleted\" only for the selected task.\n\n### Edit Task Content\n- WHEN a user edits the content of an existing todo, THE system SHALL update only the content field of that todo, provided the new content passes validation.\n- IF a user tries to edit a todo with empty or invalid content, THEN THE system SHALL reject the change and provide an error message.\n\n### Delete Task\n- WHEN a user deletes a todo they own, THE system SHALL permanently remove that todo from the user's list.\n\n## Business Logic Rules\n\n### Ownership and Access\n- THE system SHALL restrict access so that only the creator of a todo can view, edit, or delete that task, except for admin users.\n- WHEN an admin views any user's todos, THE system SHALL grant access for administrative purposes but require clear logging of this action.\n- WHEN an admin deletes a user's todo, THE system SHALL remove the todo and log the operation for audit purposes.\n\n### Task Content Rules\n- THE system SHALL enforce a maximum length of 255 characters for each todo's content.\n- IF content exceeds 255 characters, THEN THE system SHALL reject the todo with a relevant error message.\n\n### Status Defaults and Changes\n- WHEN a todo is created, THE system SHALL set its status to \"uncompleted\" by default.\n- WHEN a todo is successfully deleted, THE system SHALL remove all references to that todo in the user's active list.\n\n## Task and List Management\n\n### List Retrieval and Filtering\n- WHEN a user requests their todo list, THE system SHALL return all their todos, ordered with the most recently created tasks first.\n- WHERE many todos exist, THE system SHALL support paginated listing of tasks with a default page size of 20.\n\n### Bulk Operations (Optional Minimalism)\n- WHERE business requirements call for absolute minimalism, THE system SHALL NOT permit bulk operations on tasks (such as mass deletion or mark all as complete) at MVP stage.\n\n## Edge Cases and Exceptions\n\n### Invalid or Unauthorized Actions\n- IF a user attempts to view, edit, or delete a todo that does not exist or that belongs to another user, THEN THE system SHALL deny the operation and give a clear error notification.\n- IF an unauthenticated user (not logged in) attempts to access todo-related functions, THEN THE system SHALL require authentication before proceeding.\n- IF an admin performs any action affecting another user's todos, THEN THE system SHALL create an audit log entry with time, admin username, and action details.\n\n### Empty List Handling\n- IF a user has no todos, THEN THE system SHALL display a message indicating the list is empty.\n\n### Input Validation\n- THE system SHALL enforce that each todo must have non-empty, non-whitespace content and must not contain control characters.\n\n## Success Criteria\n- WHEN all requirements described above are implemented and verifiable by business tests, THE system SHALL be considered compliant with minimal functional requirements.\n- THE system SHALL pass all acceptance tests for the following scenarios without error:\n  - Adding, viewing, editing, deleting a todo for a user\n  - Marking tasks as completed/uncompleted\n  - Preventing access to todos by unauthorized users\n  - Enforcing business rules on content length and validation\n  - Admin actions on user data are logged correctly\n- THE system SHALL respond to all business operations (create, read, update, delete, mark complete) within 2 seconds for user-perceived performance.\n\n## Visual Flow (Mermaid Diagram)\n```mermaid\ngraph LR\n  UA[\"User(Log in)\"] --> NA[\"Create Todo\"]\n  NA --> VB[\"Validate content\"]\n  VB -->|\"Valid\"| SC[\"Save to user's todo list (status: uncompleted)\"]\n  VB -->|\"Invalid\"| ER[\"Show error\"]\n  UA --> VA[\"View Todos\"]\n  VA --> RL[\"Retrieve user's sorted todo list\"]\n  VA --> EL[\"Show 'no todos' message if empty\"]\n  UA --> MC[\"Mark as completed/uncompleted\"]\n  MC --> US[\"Update completion status\"]\n  UA --> ED[\"Edit todo content\"]\n  ED --> VC[\"Validate edit\"]\n  VC -->|\"Valid\"| UPD[\"Update content\"]\n  VC -->|\"Invalid\"| ER\n  UA --> DL[\"Delete Todo\"]\n  DL --> RM[\"Remove from list\"]\n  UA -.->|\"Try another's todo\"| ERR[\"Deny access, show error\"]\n  A[\"Admin\"] -->|\"View/Delete any todo\"| AUD[\"Audit log action\"]\n  A -->|\"Delete user's todo\"| RM\n```\n"},{"reason":"To detail non-functional requirements that impact the user experience and platform reliability, including response times, scalability, data protection, and regulatory constraints essential for business viability.","filename":"04-nonfunctional-requirements.md","documentType":"requirement","outline":["Performance Criteria","Security Requirements","Compliance Mandates","Reliability and Availability","Scalability Considerations"],"audience":"backend developers","content":"# Non-Functional Requirements for Todo List Application\n\n## Performance Criteria\n- THE service SHALL respond to all standard API operations (create, read, update, delete Todo) within 1 second under normal load (fewer than 1,000 concurrent users).\n- WHEN a user loads their Todo list, THE system SHALL return a complete list within 1 second, unless the user has over 5,000 items.\n- IF a user has over 5,000 Todos, THEN THE system SHALL return the first 100 Todos in 1 second and provide mechanisms to request more.\n- THE system SHALL support at least 2,000 total concurrent users, scaling to 10,000 with performance degradation not to exceed 30% increase in average response time.\n- THE system SHALL be available 24/7 except for scheduled maintenance, with notification provided at least 48 hours in advance.\n\n## Security Requirements\n- THE service SHALL require HTTPS/TLS encryption for all client-server communications, without exception.\n- WHEN users register, log in, or reset passwords, THE system SHALL enforce input validation and sanitization to prevent injection attacks (XSS, SQL Injection, etc.).\n- THE system SHALL store all user credentials using salted, strong one-way hashing algorithms (e.g., bcrypt, argon2).\n- THE service SHALL use JWT (JSON Web Tokens) for authentication, with access tokens expiring within 30 minutes and refresh tokens no longer than 30 days.\n- WHEN an admin accesses or deletes another user's Todo, THE system SHALL log this action with a timestamp, role, and affected resource.\n- WHERE multiple failed login attempts occur (more than 5 within 10 minutes), THE system SHALL temporarily block further attempts from that source for 15 minutes and log the event.\n- THE service SHALL prevent unauthenticated or unauthorized users from accessing, modifying, or viewing any data not permitted by their role (as defined in [User Roles and Authentication](./02-user-roles-and-authentication.md)).\n- IF a security breach is detected (including data access outside user scope), THEN THE service SHALL notify an admin within 15 minutes and restrict further suspicious activity.\n\n## Compliance Mandates\n- THE service SHALL comply with all relevant data protection laws and regulations applicable to the service’s jurisdiction (e.g., GDPR, CCPA if service operates in those regions).\n- THE system SHALL provide means for users to request the deletion of their data, and deletion SHALL occur within 30 days of the request, with user notification upon completion.\n- WHERE data is retained for operational or legal purposes, THE system SHALL clearly inform users during account registration (linking to the [Privacy and Data Protection Policy](./09-privacy-and-data-protection.md)).\n- WHEN processing or storing sensitive information (such as authentication credentials), THE service SHALL use practices consistent with ISO/IEC 27001 recommendations.\n\n## Reliability and Availability\n- THE service SHALL achieve an uptime of at least 99.5% measured monthly, excluding scheduled downtime with advance notice.\n- WHEN a critical system failure occurs (e.g., total outage, database corruption), THEN THE system SHALL notify admins within 5 minutes and provide a status update every 30 minutes until resolved.\n- THE service SHALL perform and verify daily data backups, storing copies in at least two physically separate locations.\n- WHEN a user performs a successful write operation (create, update, delete), THE system SHALL confirm the operation and ensure that the result persists across service restarts.\n- IF a user’s action fails due to backend error, THEN THE system SHALL respond with a clear error message and not result in data loss or inconsistency.\n\n## Scalability Considerations\n- THE service SHALL be designed to handle user base growth from 100 to at least 50,000 registered users without requiring fundamental system redesign.\n- THE system SHALL scale horizontal capacity (i.e., add more servers) for API endpoints, authentication, and storage when usage exceeds 80% sustained capacity for more than 1 hour.\n- WHEN increased demand is observed, THE system SHALL degrade gracefully by prioritizing core API responses (listing, reading, updating Todos) and may defer lower-priority operations (analytics, logs compaction) until demand subsides.\n- WHERE load spikes exceed currently provisioned resources, THE system SHALL maintain at least read access for all active users, even if some write operations must be temporarily throttled.\n\n## Visual Overview: System NFR Relationships\n```mermaid\ngraph LR\n  A[\"User Request\"] --> B[\"Performance Layer\"]\n  B --> C[\"Security Enforcement\"]\n  C --> D[\"Compliance Checks\"]\n  D --> E[\"Reliability Mechanisms\"]\n  E --> F[\"Scalability Logic\"]\n  F --> G[\"Business Outcomes\"]\n\n  subgraph \"Critical NFR Dimensions\"\n    B\n    C\n    D\n    E\n    F\n  end\n\n  subgraph \"Business Drivers\"\n    G\n  end\n```\n\nAll requirements above are written solely as business-driven minimum guarantees; technical implementation details are left to the discretion of the development team."},{"reason":"To create rich, scenario-based user stories that describe exactly how each user type interacts with the system and what pain points are resolved by the service, aligning with business and product strategy.","filename":"05-user-stories.md","documentType":"user-story","outline":["Persona Overview","Primary Scenarios","Secondary Scenarios","Failure and Exception Scenarios"],"audience":"backend developers","content":"# User Stories for Minimal Todo List Application\n\n## Persona Overview\n\n### Registered User (\"user\" role)\nA regular member who registers to use the service to organize personal tasks. Seeks simplicity, privacy, fast access, and full control over their task data. Pain points include forgetting critical tasks, not being able to find or modify todos quickly, and risk of accidental data loss.\n\n### Administrator (\"admin\" role)\nManages the overall health and operation of the Todo list platform, including resolving user issues or misuse. Focused on ensuring system integrity, privacy, and minimal friction for daily users. Needs clear oversight tools and the power to resolve business-impacting situations (e.g., data misuse or objectionable content in todos).\n\n## Primary Scenarios\n\n### 1. User Registers and Becomes Productive\n- WHEN a new visitor wants to use the todo list, THE system SHALL allow registration using email and password.\n- WHEN registration succeeds, THE system SHALL allow immediate creation of the first todo item.\n- WHEN logged in, THE user SHALL access a personal list of todos.\n\n### 2. Creating, Viewing, and Editing Todos\n- WHEN a user is authenticated, THE system SHALL allow the creation of a new todo item with a title and optional description.\n- WHEN a user views their list, THE system SHALL display all current todos, sorted by creation or due date.\n- WHEN a user edits a todo, THE system SHALL update the task and display the change instantly in the user's list.\n\n### 3. Marking Todos as Complete or Incomplete\n- WHEN a user marks a todo as complete, THE system SHALL reflect this status in the user's personal task list.\n- WHEN a completed todo is unchecked, THE system SHALL revert its status to incomplete and show the update immediately.\n\n### 4. Deleting Todos\n- WHEN a user deletes a todo, THE system SHALL permanently remove the task from the user's accessible list.\n- WHEN a user requests deletion, THE system SHALL display a confirmation step to prevent accidental loss.\n\n### 5. Admin Oversight and Intervention\n- WHEN an admin logs in, THE system SHALL provide a dashboard or access to all users' todos.\n- WHEN an admin identifies misuse (e.g., offensive content), THE system SHALL allow the admin to delete inappropriate todos.\n- WHEN platform-wide settings need adjustment, THE system SHALL enable admins to make and save operational changes instantly.\n\n## Secondary Scenarios\n\n### 6. Password Management\n- WHEN a user forgets their password, THE system SHALL provide a secure password reset flow via email.\n- WHEN a user wants to change their password, THE system SHALL validate and update securely.\n\n### 7. Session Management\n- WHEN a user logs out, THE system SHALL terminate the session and restrict access to todos until re-authentication.\n- WHEN a user is inactive for a prolonged period, THE system SHALL expire the session as per business policy and require login again.\n\n### 8. Bulk Operations\n- WHEN a user wishes to delete multiple todos at once, THE system SHALL support selection and batch removal with a single confirmation step.\n- WHEN a user desires to mark all tasks as complete, THE system SHALL perform this action efficiently and update the state for each task.\n\n### 9. Data Privacy Actions\n- WHEN a user wishes to delete their account, THE system SHALL provide a clear process, erase the user's todos, and confirm the operation to the user.\n\n## Failure and Exception Scenarios\n\n### 10. Invalid Actions and Error Handling\n- IF a user attempts to view, edit, or delete a todo they do not own, THEN THE system SHALL deny the action and return an appropriate error message.\n- IF a user tries to create a todo with missing required fields (e.g., no title), THEN THE system SHALL show a validation error and block submission.\n- IF the backend is temporarily unavailable, THEN THE system SHALL inform users of the issue and suggest retrying later, without data loss.\n- IF an admin tries to access removed or non-existent todos, THEN THE system SHALL display an error and prevent undefined system behavior.\n\n### 11. Security and Privacy Violations\n- IF a user or admin attempts to bypass authentication, THEN THE system SHALL block access and log the attempt for security review.\n\n### 12. Business Rule Violations\n- IF a user tries to create more todos than allowed by business policy, THEN THE system SHALL show a limit-reached message and stop further additions until some are removed or the limit is changed by policy.\n\n---\n\n## Summary Mermaid Diagram\n\n```mermaid\ngraph LR\n  subgraph \"Regular User Flows\"\n    A[\"Register\"] --> B[\"Login\"]\n    B --> C[\"Create Todo\"]\n    C --> D[\"Edit Todo\"]\n    D --> E[\"Mark Complete/Incomplete\"]\n    C --> F[\"Delete Todo\"]\n    F --> G[\"Delete Account\"]\n  end\n  subgraph \"Admin Flows\"\n    H[\"Admin Login\"] --> I[\"View All Users' Todos\"]\n    I --> J[\"Delete Any Todo\"]\n    J --> K[\"Manage Platform Settings\"]\n  end\n  C -.-> I\n  J -.-> F\n```\n\n"},{"reason":"To map the complete user flows for typical Todo list usage, visually and descriptively illustrating step-by-step business processes from account creation to completion of daily tasks.","filename":"06-user-flow.md","documentType":"user-flow","outline":["User Registration and Login","Adding and Managing Todos","Marking Todos as Completed","Editing and Deleting Todos","Admin-Specific Operations"],"audience":"backend developers","content":"# User Flow for Minimal Todo List Application\n\n## 1. User Registration and Login\n\n### Registration Flow\n- WHEN a new user accesses the service, THE system SHALL present a registration option.\n- WHEN a user initiates the registration process, THE system SHALL collect a valid, unique email and password meeting business rule requirements (see [Business Rules Document](./08-business-rules.md)).\n- WHEN all required registration criteria are satisfied, THE system SHALL create a user account in the \"user\" role.\n- IF the email is already used, THEN THE system SHALL reject registration and display a clear error message.\n- WHEN registration is successful, THE system SHALL require account login with email and password.\n\n### Login Flow\n- WHEN the user attempts login, THE system SHALL validate the credentials.\n- IF credentials are correct, THEN THE system SHALL establish an authenticated session.\n- IF credentials are incorrect, THEN THE system SHALL deny access and notify the user.\n- THE system SHALL limit login attempts to prevent brute force, as per security policy.\n\n### Logout Flow\n- WHEN the user chooses to log out, THE system SHALL terminate the session instantly and remove session tokens.\n\n---\n\n## 2. Adding and Managing Todos\n\n### Add Todo\n- WHEN a logged-in user submits a new todo item, THE system SHALL validate task content according to business rules (e.g., content length, prohibited words, due date validity).\n- WHEN validation passes, THE system SHALL record the todo item, assigning ownership to the user and setting its state as \"active\" and \"not completed\".\n- IF validation fails (empty, too long, invalid date, etc.), THEN THE system SHALL reject the creation and return specific error.\n- THE system SHALL assign unique IDs to todos per user account.\n\n### View Todo List\n- WHEN a user is authenticated, THE system SHALL display all existing todo items owned by the user in a list view, showing status (completed, active, etc.), due date, and content.\n- WHERE a user has no todos, THE system SHALL show an empty state response.\n\n---\n\n## 3. Marking Todos as Completed\n- WHEN a user marks a todo as \"completed\", THE system SHALL update its status accordingly and timestamp the completion (see [Business Rules Document](./08-business-rules.md)).\n- WHEN a user unmarks a completed todo (returns to active), THE system SHALL clear the completion timestamp.\n- IF an operation targets a non-existent or unauthorized todo, THEN THE system SHALL deny the action with a permission error.\n\n---\n\n## 4. Editing and Deleting Todos\n\n### Editing Todos\n- WHEN a user edits their own todo, THE system SHALL validate all updates per business rules.\n- WHEN validation passes, THE system SHALL save the updated todo, preserving the unique identifier and timestamps.\n- IF the edits fail business rules (e.g., empty content, forbidden date changes), THEN THE system SHALL reject and provide actionable error messages.\n- IF a user attempts to edit a todo that does not belong to them, THEN THE system SHALL block the request and show an authorization error.\n\n### Deleting Todos\n- WHEN a user requests deletion of their own todo, THE system SHALL permanently remove the todo and all associated data from their list.\n- IF deletion is successful, THE system SHALL update the list view and confirm the result.\n- IF the user attempts to delete a todo they do not own, THEN THE system SHALL deny the action with an error.\n\n---\n\n## 5. Admin-Specific Operations\n\n- WHEN an admin logs in, THE system SHALL grant access to both standard user operations and additional administrative functions.\n- THE admin SHALL be able to view all users' todos via a global list/search.\n- WHEN an admin determines that a todo violates policy or is required for operational action, THE system SHALL allow the admin to delete any user's todo, removing it from the targeted user's account.\n- WHEN deleting as an admin, THE system SHALL record which admin deleted the todo and when, for audit purposes.\n- THE admin SHALL NOT be able to edit user passwords or account settings related to authentication (see [User Roles Document](./02-user-roles-and-authentication.md)), unless otherwise described in requirements.\n\n---\n\n## 6. User Flow Diagrams (Mermaid)\n\n### Registration and Login Flow\n```mermaid\ngraph LR\n  A[\"User Opens App\"] --> B{\"Is Registered?\"}\n  B -->|\"No\"| C[\"Register with Email/Password\"]\n  C --> D{\"Register Success?\"}\n  D -->|\"Yes\"| E[\"Login with Credentials\"]\n  D -->|\"No\"| F[\"Show Registration Error\"]\n  B -->|\"Yes\"| E\n  E --> G{\"Login Success?\"}\n  G -->|\"Yes\"| H[\"User Account Home\"]\n  G -->|\"No\"| I[\"Show Login Error\"]\n```\n\n### Todo Management Flow\n```mermaid\ngraph LR\n  AA[\"User Account Home\"] --> AB[\"Submit New Todo\"]\n  AB --> AC{\"Todo Valid?\"}\n  AC -->|\"Yes\"| AD[\"Todo Saved\"]\n  AC -->|\"No\"| AE[\"Show Validation Error\"]\n  AD --> AF[\"Show My Todo List\"]\n  AF --> AG[\"Mark as Completed or Edit/Delete\"]\n  AG --> AH{\"Authorization OK?\"}\n  AH -->|\"Yes\"| AI[\"Apply Change\"]\n  AH -->|\"No\"| AJ[\"Show Auth Error\"]\n```\n\n### Admin Operation Flow\n```mermaid\ngraph LR\n  BA[\"Admin Logs In\"] --> BB[\"View User Todos\"]\n  BB --> BC[\"Search or Select Todo\"]\n  BC --> BD[\"Delete Todo Option\"]\n  BD --> BE{\"Delete Confirmed?\"}\n  BE -->|\"Yes\"| BF[\"Delete Todo and Log Action\"]\n  BE -->|\"No\"| BG[\"Return to Todo List\"]\n```\n\n---\n\n# End of Document"},{"reason":"To describe all business-level error situations, user-facing messages, and business process recovery actions, ensuring robust and user-friendly system behavior.","filename":"07-error-handling-and-recovery.md","documentType":"requirement","outline":["Common Error Scenarios","Validation Failures","Authorization and Access Denied","Data Integrity Issues","User Recovery Actions"],"audience":"backend developers","content":"# Error Handling and Recovery Requirements for Minimal Todo List Application\n\n## 1. Common Error Scenarios\nThis section outlines principal cases where users (registered users and admins) or the system might encounter operational failures and defines expected behaviors for each.\n\n### 1.1. General Business Error Principles\n- THE system SHALL provide a clear, actionable error message to the affected user for every failed business process.\n- THE system SHALL prevent exposure of technical details or internal states to end users.\n- THE system SHALL log all errors internally for later admin review while protecting user privacy.\n- WHEN an error occurs, THE system SHALL preserve user-entered data unless its integrity is compromised.\n\n\n## 2. Validation Failures\nValidation failures occur when user input does not meet business-defined constraints for todos (e.g., missing text, excessive length, invalid due date).\n\n### 2.1. Empty or Invalid Todo Content\n- WHEN a user attempts to create or update a todo with empty content, THE system SHALL reject the request and return an error message indicating that todo content cannot be empty.\n- WHEN a user submits todo content exceeding the allowed length, THE system SHALL reject the request and display an error message specifying the maximum character limit.\n- WHEN a user includes disallowed characters or input types, THE system SHALL deny the action, indicate the invalid content, and prompt for correction.\n\n### 2.2. Invalid Due Date\n- WHEN a user tries to set a due date in an incorrect format or with a date in the past, THE system SHALL reject the request and explain that due dates must be in the future using the required format.\n\n### 2.3. Invalid Update or Deletion Request\n- WHEN a user attempts to update or delete a todo without specifying a valid todo identifier, THE system SHALL deny the action and prompt for clarification or correction.\n\n\n## 3. Authorization and Access Denied\nThis section describes how the system manages access control failures.\n\n### 3.1. Unauthorized Access (Not Logged In)\n- WHEN a non-authenticated user tries to create, modify, or delete any todo, THE system SHALL deny access and prompt the user to log in.\n\n### 3.2. Forbidden Action (Insufficient Permission)\n- WHEN a user attempts to view, modify, or delete a todo that they do not own, THE system SHALL deny the request and inform the user that only the owner (or admin, if applicable) may access this resource.\n- WHEN an admin deletes a user's todo, THE system SHALL record the action for audit purposes and provide a business-appropriate notification indicating administrative intervention.\n\n### 3.3. Session Expiration\n- WHEN a user’s authentication session expires, THE system SHALL invalidate access, inform the user, and prompt re-authentication before allowing further actions.\n\n\n## 4. Data Integrity Issues\nFailures arising from system or storage problems, accidental duplicates, or corrupted data.\n\n### 4.1. Todo Not Found\n- WHEN a user or admin requests access to a non-existent todo, THE system SHALL respond with an error stating that the requested todo does not exist or has already been deleted.\n\n### 4.2. Duplicate Todos Prevention\n- WHEN a user attempts to create a todo that is an exact duplicate of an existing todo in their list, THE system SHALL warn the user and prevent duplicate creation.\n\n### 4.3. Unexpected Data State\n- IF underlying data is found to be corrupted or inconsistent, THEN THE system SHALL block the current action, notify the user of a temporary issue, and recommend retrying later.\n- WHEN system-side errors occur that prevent successful transaction completion, THE system SHALL not apply any partial changes and must guarantee atomicity for all business actions.\n\n\n## 5. User Recovery Actions\nThis section covers the business process by which users are guided to recover from errors as painlessly as possible.\n\n### 5.1. User Correction Workflow\n- WHEN a validation error is encountered, THE system SHALL present the user with actionable, specific guidance to correct the input.\n- WHEN a todo operation fails, THE system SHALL retain any valid information the user previously entered (where safe to do so) to avoid user rework.\n\n### 5.2. Retrying Failed Actions\n- WHEN an operation fails due to temporary system or network errors, THE system SHALL offer the user the ability to retry the same action after a short interval.\n- WHERE a repeat action may produce a duplicate, THE system SHALL prevent duplicate entries and prompt for confirmation as appropriate.\n\n### 5.3. Escalation to Admin\n- WHEN a persistent unrecoverable error prevents the user from managing their own todos, THE system SHALL direct the user to a support or admin contact channel (email or help resource, as appropriate to the business model).\n- THE admin role SHALL have access logs and tools to investigate error cases, limited to the minimum data required for resolution.\n\n### 5.4. Example Error and Recovery Flow\n\n```mermaid\ngraph LR\n  A[\"User Submits Todo (Create/Update)\"] --> B{\"Validation Passes?\"}\n  B -->|\"Yes\"| C[\"DB Operation\"]\n  B -->|\"No\"| D[\"Show Validation Error Message\"]\n  D --> E[\"User Corrects Input\"]\n  E --> B\n  C --> F{\"DB Success?\"}\n  F -->|\"Yes\"| G[\"Operation Complete\"]\n  F -->|\"No\"| H[\"Show Generic Error, Offer Retry\"]\n  H --> I[\"User Retries Action\"]\n  I --> C\n```\n\n## 6. Success Criteria for Error Handling\n- THE system SHALL provide a user message for every error, stating the exact business reason for failure.\n- THE system SHALL never expose stack traces or internal error details in user-facing messages.\n- THE system SHALL ensure every error state leads to a logical, recoverable end state or clear escalation path.\n- THE system SHALL log all errors for future analysis by administrators.\n\n---\n\n# Reference to Related Documents\n- For detailed permissions and user roles, see [User Roles and Authentication Requirements](./02-user-roles-and-authentication.md).\n- Business and validation rules are specified in [Business Rules for Todos](./08-business-rules.md).\n- Functional requirements are described in [Functional Requirements](./03-functional-requirements.md).\n- Data protection practices can be reviewed in [Privacy and Data Protection](./09-privacy-and-data-protection.md)."},{"reason":"To detail business rules and validation logic for todo creation, management, and access, ensuring clear understanding of operational constraints and user data relationships.","filename":"08-business-rules.md","documentType":"requirement","outline":["Task Content and Length Rules","Due Date Logic","Ownership and Data Access","Edge Cases and Prohibited Operations"],"audience":"backend developers","content":"# Business Rules and Validation Logic for Minimal Todo List Application\n\n## Task Content and Length Rules\n\n- THE system SHALL allow only plain text content in each todo item. No images, attachments, or formatting tags are permitted.\n\n- THE system SHALL require that the task description not be empty and contain only printable, non-control characters except for newlines.\n\n- THE system SHALL enforce a minimum length of 1 character and a maximum length of 255 characters (excluding whitespace padding) for task content.\n\n- WHEN a user attempts to create or update a todo with content exceeding 255 characters, THE system SHALL reject the request and present a descriptive error.\n\n- IF the content field is all whitespace, THEN THE system SHALL treat it as empty and reject the todo creation or update.\n\n- THE system SHALL trim leading and trailing whitespace from task content before applying length or emptiness checks.\n\n- IF a todo's content contains potentially harmful code (such as <script> tags), THEN THE system SHALL reject the todo and return a sanitization error.\n\n\n## Due Date Logic\n\n- THE system SHALL allow, but not require, an optional due date for each todo.\n\n- WHEN a due date is specified, THE system SHALL require it to be a valid ISO 8601 date (yyyy-mm-dd) and not earlier than the current date.\n\n- IF a user attempts to set a due date in the past, THEN THE system SHALL reject the request and return a validation error.\n\n- IF a user submits a due date in an invalid format, THEN THE system SHALL return a validation error specifying the required format.\n\n- WHEN a todo is created without a due date, THE system SHALL store it as null or undefined for the due date field.\n\n- THE system SHALL not allow the due date to be changed to a value earlier than the todo's creation date.\n\n- WHEN marking a todo as completed, THE system SHALL not lock or alter the due date field.\n\n\n## Ownership and Data Access\n\n- THE system SHALL associate every todo item with the user (by unique user ID) who created it. Ownership is strictly enforced by business logic.\n\n- WHEN a user attempts to access, update, or delete a todo, THE system SHALL verify that the requesting user is the owner of the todo (unless the user holds the admin role).\n\n- IF a user attempts to access, update, or delete a todo they do not own and are not an admin, THEN THE system SHALL deny access and present an authorization error.\n\n- WHEN an admin user attempts to view or delete any user's todo, THE system SHALL permit the action.\n\n- THE system SHALL never reveal or allow update/delete access to a user's todos by another user unless the requesting party is an admin.\n\n- WHEN deleting a user, THE system SHALL delete or anonymize all todos associated with that user, according to data retention policy.\n\n- THE system SHALL support user-level querying: users may only see their own todos, even when querying task lists; admins may access all users' todos as needed.\n\n- IF a user requests a list of todos, THEN THE system SHALL return only those belonging to the requesting user (unless admin).\n\n\n## Edge Cases and Prohibited Operations\n\n- IF a todo task is already marked as completed and a user attempts to mark it completed again, THEN THE system SHALL ignore the action and return success without changing state.\n\n- IF a user attempts to update or delete a todo that does not exist, THEN THE system SHALL respond with an error indicating the todo is not found.\n\n- WHEN a user attempts to delete a completed todo, THE system SHALL permit deletion following the same rules as for incomplete tasks.\n\n- THE system SHALL not permit the creation of multiple todos with identical content for the same user, if submitted within the same minute (deduplication window).\n\n- IF a user attempts to submit two identical tasks within the deduplication window, THEN THE system SHALL reject the second submission with a deduplication error message.\n\n- THE system SHALL not allow re-assignment or transfer of ownership of existing todo items between users via any operation.\n\n- THE system SHALL not permit users to directly manipulate system meta-fields (such as creation timestamp, completion timestamp, or user IDs)—these are system-controlled only.\n\n- WHEN a user or admin queries for all tasks, THE system SHALL apply system-level filtering and sorting according to business logic and only expose fields allowed by the business rules.\n\n\n---\n\nFor related material, refer to the [Functional Requirements Document](./03-functional-requirements.md), [User Roles and Authentication Document](./02-user-roles-and-authentication.md), and [Error Handling and Recovery Guide](./07-error-handling-and-recovery.md).\n"},{"reason":"To address data privacy practices, end user rights, and user consent requirements relevant to the handling of todos and user authentication, reflecting privacy-first business principles.","filename":"09-privacy-and-data-protection.md","documentType":"requirement","outline":["Data Handling Policies","User Consent Flow","Access Log and Data Retention","Right to Deletion and Correction"],"audience":"backend developers","content":"# Todo List 개인정보 보호 및 데이터 처리 요구사항\n\n## 1. 데이터 처리 정책\n\n### 수집 데이터 유형\n- THE 서비스 SHALL 최소한의 데이터만 수집한다: 계정 식별자(이메일), 인증 정보, 소유한 todo 데이터(제목, 내용, 완료여부, 선택적 기한), 기본 로그(타임스탬프, 변경 기록 등)로 제한한다.\n- THE 서비스 SHALL 사업상의 목적 외 데이터는 수집 및 저장하지 않는다.\n- THE 서비스 SHALL 수집 데이터 사용 목적(업무 운영, 유지, 개선) 외 타 용도(3자 제공, 마케팅 등)로 활용하지 않는다.\n- WHEN 데이터가 서비스 개선·분석 목적으로 처리될 때, THE 서비스 SHALL 반드시 익명화하거나 비식별 정보만 사용한다.\n- WHERE 법률이 요구하는 경우 외에는, THE 서비스 SHALL 어떠한 개인정보도 외부에 제공하지 않는다.\n- IF 사법기관이나 법령상 적법한 요구가 있을 때, THEN THE 서비스 SHALL 꼭 필요한 최소 범위만 제공하고, 허용되는 경우 사용자에게 알린다.\n\n## 2. 사용자 동의 흐름\n\n### 가입 시 명시적 동의\n- WHEN 신규 사용자가 계정 생성 시도 시, THE 서비스 SHALL 수집 정보, 이용 목적, 권한 안내 등 명시된 개인정보 처리 방침을 제공한다.\n- WHEN 사용자 계정을 생성할 때, THE 서비스 SHALL 개인정보 처리방침에 대한 명확한 동의 절차를 필수적으로 거친다.\n\n### 지속적 동의 및 철회\n- WHERE 사용자가 서비스를 계속 이용하는 경우, THE 서비스 SHALL 최초 동의 내용에 한해 지속적 동의로 간주한다.\n- WHERE 사용자가 동의 철회를 원하면, THE 서비스 SHALL 철회 요청 통로를 제공하고 법적/운영상의 예외를 제외하고 즉시 모든 관련 데이터 처리를 중단한다.\n- IF 사용자가 동의를 철회한 경우, THEN THE 서비스 SHALL 필수 보관 사유(법적·회계 등)를 제외한 개인정보 및 todo 데이터를 즉시 삭제한다.\n\n### 약관 및 정책 변경\n- WHEN 개인정보 관련 정책이 실질적으로 변경될 때, THE 서비스 SHALL 사전 안내 및 추가 동의(필요시)를 요구한다.\n\n## 3. 접근 로그 및 데이터 보관/파기\n\n### 접근 및 변경 로그\n- THE 서비스 SHALL 사용자 데이터 접근·삭제 등 주요 행위 발생 시, 사용자·시간·행위 내용을 보안적으로 기록한다.\n- WHEN 관리자가 타인 데이터를 접근/삭제/수정 시, THE 서비스 SHALL 사유, 관리자 신원, 시간 등의 정보와 함께 로깅한다.\n- WHERE 법적으로 허용되는 한, 사용자도 자신의 접근 내역 요약본 제공을 요청할 수 있다.\n\n### 데이터 보관 및 파기 정책\n- THE 서비스 SHALL 사용자 데이터는 사업 제공·유지에 필요한 최소 기간만 보관하고, 그 후에는 반드시 완전 삭제한다.\n- WHEN 사용자가 계정/데이터(목록 등) 삭제를 요청하면, THE 서비스 SHALL 관련 데이터를 지체 없이 영구 삭제하며, 법령상 예외기간(최대 30일) 내 처리한다.\n- WHERE 법적 보관 의무가 있을 경우에만 일정 기간 보관하고, 보존 기간 종료 즉시 파기한다.\n- AFTER 법적 보관기간이 만료되면, THE 시스템 SHALL 사용자의 인적 식별이 가능한 모든 데이터를 영구 파기한다.\n\n## 4. 삭제 및 수정 권리\n\n### 사용자의 데이터 삭제·수정·이동 권리\n- WHEN 사용자가 데이터(계정, todo 등) 삭제를 요청하면, THE 서비스 SHALL 지체 없이 처리를 진행하고 법령상 예외를 제외하면 즉시 삭제한다.\n- WHEN 사용자가 내 todo 또는 프로필 정보 수정 요청 시, THE 서비스 SHALL 사업 규칙이 허용하는 한(예: 관리자 조사 중 제외) 언제든 변경할 수 있게 한다.\n- WHERE 기술적으로 가능한 경우, THE 서비스 SHALL 사용자가 자신의 todo/개인정보 전체를 표준 디지털 파일로 즉시 다운로드 받을 권리를 제공한다.\n\n### 관리자의 권한 및 알림\n- WHEN 관리자가 사용자의 todo에 대해 불법, 악성, 정책 위반 내용을 발견하면, THE 서비스 SHALL 해당 데이터를 삭제할 수 있으나, 사유·시간·관리자 정보를 반드시 기록한다.\n- IF 법에 특별한 제한이 없는 한, THE 서비스 SHALL 데이터 주체(사용자)에게 알림 처리한다.\n\n## 5. EARS 형식 예시 요구사항 및 오류·예외 플로우\n\n- WHEN 데이터 삭제 요청이 접수될 경우, THE 서비스 SHALL 보관 기한을 체크 후, 만료 시 즉시 영구 삭제한다.\n- IF 법적 보존 기간 미경과 투두/계정 삭제 요청이 오면, THE 서비스 SHALL 임시 비활성 처리 후 만료시점에 자동완전삭제 플로우를 적용한다.\n- WHEN 접근 로그 내역 전송 요청이 오면, THE 서비스 SHALL 본인 확인을 거쳐 요약본을 발송한다.\n- IF 관리자가 데이터를 삭제하면, THEN THE 서비스 SHALL 즉시 행위 내역을 관리자/사용자별 로그로 남긴다.\n- WHEN 개인정보 변경 또는 동의 철회 실패(예: 내부 오류) 시, THE 서비스 SHALL 사용자에게 원인 및 추가 조치 방법을 안내한다.\n- IF 데이터 삭제(영구, 임시) 과정에서 DB 오류가 발생하면, THE 서비스 SHALL 사용자에게 실시간 안내 후, 복원 가능여부 및 재시도 옵션을 제공한다.\n\n## 6. 정보 흐름 및 권리 처리 다이어그램 (머메이드)\n\n```mermaid\ngraph LR\n  A[\"사용자 가입/등록\"] --> B[\"개인정보 처리방침 동의\"]\n  B --> C{\"동의 완료?\"}\n  C -->|\"Yes\"| D[\"계정 생성 및 투두 등록\"]\n  C -->|\"No\"| E[\"가입 중단\"]\n  D --> F[\"Todo 사용 및 데이터 생성\"]\n  F --> G[\"삭제·정정·다운로드 요청 및 실행\"]\n  G --> H[\"보존/삭제/지원 절차\"]\n  H --> I{\"법정 또는 정책상 보관 필요?\"}\n  I -->|\"Yes\"| J[\"합리적 보관 후 삭제\"]\n  I -->|\"No\"| K[\"즉시 영구 삭제\"]\n  D --> L[\"개인정보방침 변경\"]\n  L --> M[\"사전 안내 및 재동의 요구\"]\n```\n\n## 7. 사업 규칙, 오탈자 방지, 연계 규정\n- THE 서비스 SHALL 개인정보 보호, 데이터 보관, 삭제, 접근권 덕을 명확히 관리하고, 모든 내부 로그·사용자 알림·동의절차·오류처리 등에 누락이 없도록 한다.\n- WHERE 추가 사업 규칙(관리자 예외/특정법 적용 등)이 필요한 경우, 각 문서(인증, 업무규칙, 오류처리 등) 내 [관련 문서](./02-user-roles-and-authentication.md), [업무 규칙](./08-business-rules.md), [오류 처리](./07-error-handling-and-recovery.md)를 적절히 참조한다.\n- 이 요구사항은 기술 구현 지시가 아닌, 비즈니스 요구와 운영 측면에 한정한다."},{"reason":"To outline measurable criteria and business-focused indicators for overall success of the system, ensuring alignment with business goals and stakeholder expectations.","filename":"10-success-metrics.md","documentType":"requirement","outline":["Key Performance Indicators (KPIs)","Service Adoption Metrics","User Satisfaction Measures","Retention and Usage"],"audience":"business stakeholders","content":"# Success Metrics and Measurement Framework for Todo List Application\n\n## Key Performance Indicators (KPIs)\n\nSuccess for the Todo List application is determined by a focused set of metrics that directly monitor how well the system serves its intended business purposes: supporting users in managing everyday tasks with minimal friction. All KPIs are described using EARS format to eliminate ambiguity and to create an actionable baseline for backend development and business review.\n\n### System Usage Metrics\n- WHEN the system is operational, THE application SHALL record the daily number of actively logged-in users (Daily Active Users, DAU).\n- THE system SHALL calculate Monthly Active Users (MAU) by counting unique users active in a rolling 30-day window.\n- THE system SHALL record the total number of tasks (todos) created per day and per user.\n\n### Task Completion Rate\n- WHEN a user marks a todo as complete, THE application SHALL increment the user's completed tasks count.\n- THE system SHALL calculate the percentage of completed todos out of all created todos per user and as a global metric (Task Completion Rate).\n\n### Data Quality and Error Rate\n- THE system SHALL record the number of failed operations as a percentage of total attempted business actions (e.g., task creation, update, deletion), segmented by operation and user role.\n- WHEN an error occurs during a valid user action, THE system SHALL log the incident type and frequency for business review.\n\n\n## Service Adoption Metrics\n\nSuccess depends on the application’s ability to attract and activate new users, as well as on the rate at which users engage with core features.\n\n### User Registration and Onboarding\n- THE system SHALL record the number of newly registered users per day, week, and month.\n- WHEN a user completes their first todo after registering, THE system SHALL increment the number of activated users.\n- THE application SHALL calculate the activation rate as the percentage of new registrants who create at least one todo within 24 hours post-registration.\n- THE system SHALL track how many users abandon the application before creating their first todo (onboarding drop-off).\n\n### Feature Utilization\n- THE system SHALL monitor the average number of todos created, completed, and deleted per user.\n- WHERE users return within one day, seven days, or 30 days, THE system SHALL increment the relevant return user cohort counter (1-day, 7-day, 30-day return rate).\n\n\n## User Satisfaction Measures\n\nUser satisfaction must be measured using direct feedback and indirect indicators reflecting users' real experience of the core todo management capabilities.\n\n### Survey and Feedback\n- WHEN a user voluntarily submits feedback or rates the service, THE system SHALL store the rating value and textual feedback for aggregation.\n- THE system SHALL calculate the average user satisfaction score based on periodic ratings or feedback.\n- WHERE users indicate dissatisfaction (e.g., low rating, explicit complaint), THE system SHALL increment the user dissatisfaction counter and log the instance for business review.\n\n### Support and Issue Reporting\n- THE application SHALL record the number of support tickets, bug reports, or complaints by type and outcome (resolved/unresolved) for trend analysis.\n\n\n## Retention and Usage\n\nLong-term value is demonstrated by users who consistently return and rely on the todo service to manage their tasks. Retention is a key business goal.\n\n### Retention Cohorts\n- THE system SHALL measure user retention by tracking the percentage of users who log in at least once after 1 day, 7 days, and 30 days from the date of their registration (retention rate).\n\n### Churn Analysis\n- WHERE a registered user shows no activity for 30 days, THE system SHALL flag the user as a churn candidate and count within a churn rate metric.\n- IF a churn candidate returns after inactivity, THEN THE system SHALL move the user back to active retention metrics.\n\n### Frequency of Use\n- THE system SHALL record the average number of session logins, todos created, todos marked as completed, and todos deleted per user within set periods (daily, weekly, monthly).\n\n\n## Business Acceptance Criteria\n\n- THE application SHALL achieve a minimum DAU/MAU ratio of 20% within three months of launch.\n- THE activation rate (users who create a todo within 24 hours of registration) SHALL exceed 70% in the first six months.\n- THE average user satisfaction score SHALL remain above 4 out of 5 on feedback surveys.\n- THE churn rate (percentage of users inactive for 30 days) SHALL not exceed 40% in the first year.\n\n\n## Success Metric Visualization (Mermaid)\n\n```mermaid\ngraph LR\n    A[\"User Registration\"] --> B[\"Creates First Todo\"]\n    B --> C[\"Activation Count Up\"]\n    A --> D[\"No Todo Created - Onboarding Drop-off\"]\n    C --> E[\"Returns Within 1, 7, or 30 Days?\"]\n    E -->|\"Yes\"| F[\"Retention Cohorts\"]\n    E -->|\"No\"| G[\"Churn Candidate\"]\n    F --> H[\"DAU/MAU Calculation\"]\n    B --> I[\"User Feedback Survey\"]\n    I --> J[\"Aggregate Satisfaction Score\"]\n```\n\n\n## Measurement Boundaries and Rationale\n\n- All metrics are limited to core business actions as defined in the minimal feature set of the application (task creation, completion, deletion, registration, login, feedback, and session activity).\n- Metrics intentionally exclude any technical, implementation-level details such as infrastructure performance or internal API responses.\n- These requirements strictly express \"what\" must be measured to declare the system a business success, with the \"how\" of measurement delegated to developer discretion.\n\n\n## Document Closure\n\nAll metrics and criteria in this report are written to provide business stakeholders with clear, quantifiable evidence for assessing the health, usability, and value of the Todo List application. They ensure complete alignment with the service vision of enabling simple, effective daily task management for all users and provide the foundation for ongoing product iteration and business validation."}],"created_at":"2025-09-23T05:50:00.258Z","completed_at":"2025-09-23T05:53:04.270Z","step":0},{"type":"prisma","id":"01997524-12ca-76ed-aa2f-7c5db86b733f","reason":"Step to the Prisma DB schema generation after requirements analysis","schemas":{"schema-01-actors.prisma":"/// Application users table. Stores core account/authentication credentials,\n/// registration data, profile fields, and business status for each user.\n/// Used to verify personal identity, manage sessions, and enforce\n/// user-specific business rules. Core relationships: owns many todos (see\n/// {@link todo_list_todos}), is target for logs. Cannot perform privileged\n/// admin actions. Users are independently managed entities representing the\n/// main service customer base.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// User's unique login email address. Used for authentication and\n  /// identification. Must be unique for each user and serve as primary contact\n  /// for registration, password recovery, and notifications.\n  email String\n  \n  /// Bcrypt/argon2 hashed password for authentication. NEVER stores plain\n  /// password. Required for user login.\n  password_hash String\n  \n  /// Optional user display name for UI and search. Can be empty or null if not\n  /// set by user. Not enforced to be unique.\n  name String?\n  \n  /// Optional field for user's profile/avatar image URL. Useful for\n  /// personalized interfaces. Null if user does not set.\n  avatar_uri String? @db.VarChar(80000)\n  \n  /// Current account status (e.g., active, locked, disabled). Used for\n  /// lifecycle control, login restriction, or compliance. Business logic\n  /// enforces legal values; implement as string here for flexibility.\n  status String\n  \n  /// Timestamp of user's most recent successful login. Used for security and\n  /// audit. Null if never logged in yet.\n  last_login_at DateTime? @db.Timestamptz\n  \n  /// Record creation time (UTC). Used for audit trail and time-based queries.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp of most recent data update to the user record.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft-deletion timestamp. If not null, user is considered deleted (not\n  /// visible in main listings, subject to compliance retention).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  todo_list_todos todo_list_todos[]\n  todo_list_audit_logs todo_list_audit_logs[]\n  \n  @@unique([email])\n  @@index([created_at])\n  @@index([status])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Administrator accounts table. Stores admin credentials, authentication,\n/// status, profile, and privileged operational data. Used to manage and\n/// operate all aspects of the Todo List service and review or delete user\n/// todos as necessary. Requires auditability of all administrative actions.\n/// Account is distinct from regular users for business control and\n/// compliance, isolating admin roles from end-user personas.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_admins {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Administrator's unique login email. For secure privileged access only.\n  /// Must be unique among admin accounts.\n  email String\n  \n  /// Hash of admin's password, as in user accounts. For login authentication\n  /// (bcrypt/argon2 hash).\n  password_hash String\n  \n  /// Administrator's display name for UI, policy, and audit references.\n  /// Nullable if not set but strongly encouraged for logging.\n  name String?\n  \n  /// Optional admin profile/avatar image.\n  avatar_uri String? @db.VarChar(80000)\n  \n  /// Current admin account status (e.g., active, locked, disabled, suspended).\n  /// Used for controlling access to admin actions; values managed by business\n  /// logic.\n  status String\n  \n  /// Business-defined privilege level (e.g., superadmin, support, auditor).\n  /// Used for assigning different sets of administrative permissions within\n  /// the admin domain.\n  privilege_level String\n  \n  /// Timestamp of the admin's most recent privileged operational action (e.g.,\n  /// delete user todo, set announcement). Used for audit tracking and\n  /// accountability.\n  last_admin_action_at DateTime? @db.Timestamptz\n  \n  /// Timestamp of the administrator's last successful login. Used for security\n  /// and operational auditing.\n  last_login_at DateTime? @db.Timestamptz\n  \n  /// Admin account creation timestamp (UTC). Used for onboarding tracking and\n  /// auditing.\n  created_at DateTime @db.Timestamptz\n  \n  /// Most recent update timestamp, for audit and policy enforcement.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft-delete timestamp; if not null, admin account is technically deleted\n  /// or suspended.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  todo_list_audit_logs todo_list_audit_logs[]\n  \n  @@unique([email])\n  @@index([privilege_level])\n  @@index([created_at])\n  @@index([status])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-02-todos.prisma":"/// Represents individual tasks (todos) created and owned by users. Each todo\n/// can have content (with a business rule of maximum 255 characters),\n/// optional due date, and a completed status. Only the owner (or an admin)\n/// can view, edit, mark complete/incomplete, or delete each todo. This table\n/// supports per-user task management, access enforcement, and core\n/// productivity operations. Cross-references todo_list_users for ownership\n/// linkage.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_todos {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Owner user's {@link todo_list_users.id}. Indicates which user this todo\n  /// belongs to.\n  todo_list_user_id String @db.Uuid\n  \n  /// The textual content of the todo. Maximum 255 characters, trimmed of\n  /// whitespace, must not be empty or only whitespace. Validated business\n  /// rules (no control characters, required).\n  content String\n  \n  /// Optional due date for the todo, null if not set. If present, must be an\n  /// ISO date not before creation date.\n  due_date DateTime? @db.Timestamptz\n  \n  /// Whether the todo has been marked as completed. Defaults to false on\n  /// creation, toggled by user action.\n  completed Boolean\n  \n  /// Timestamp when the todo was marked as completed. Null if not completed.\n  completed_at DateTime? @db.Timestamptz\n  \n  /// When this todo was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp of the last modification to this todo (edit, status change,\n  /// etc).\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user todo_list_users @relation(fields: [todo_list_user_id], references: [id], onDelete: Cascade)\n  \n  todo_list_audit_logs todo_list_audit_logs[]\n  \n  @@unique([todo_list_user_id, content])\n  @@index([todo_list_user_id, created_at])\n  @@index([todo_list_user_id, completed])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Records all admin-initiated actions affecting any user's todos, such as\n/// viewing or deleting a user's todo for compliance or security purposes.\n/// Captures admin username, affected user, target todo, admin action (enum:\n/// 'view', 'delete'), rationale (optional free text), and audit timestamp.\n/// Supports privacy compliance, monitoring, and traceability in accordance\n/// with business and legal policy.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_audit_logs {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Admin's {@link todo_list_admins.id} who performed the action.\n  todo_list_admin_id String @db.Uuid\n  \n  /// Target user's {@link todo_list_users.id} whose todo was affected or\n  /// accessed.\n  todo_list_user_id String @db.Uuid\n  \n  /// Target todo's {@link todo_list_todos.id} affected by the admin action.\n  todo_list_todo_id String @db.Uuid\n  \n  /// Admin action type on the todo. Enum: 'view', 'delete'.\n  action String\n  \n  /// Optional explanation or justification text for the admin action. Free\n  /// text field; null allowed for non-sensitive actions.\n  rationale String?\n  \n  /// Timestamp when this audit log entry was created.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  admin todo_list_admins @relation(fields: [todo_list_admin_id], references: [id], onDelete: Cascade)\n  user todo_list_users @relation(fields: [todo_list_user_id], references: [id], onDelete: Cascade)\n  todo todo_list_todos @relation(fields: [todo_list_todo_id], references: [id], onDelete: Cascade)\n  \n  @@index([todo_list_admin_id])\n  @@index([todo_list_todo_id])\n  \n  @@index([todo_list_user_id, created_at])\n  @@index([action])\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-actors.prisma","namespace":"Actors","models":[{"name":"todo_list_users","description":"Application users table. Stores core account/authentication credentials, registration data, profile fields, and business status for each user. Used to verify personal identity, manage sessions, and enforce user-specific business rules. Core relationships: owns many todos (see {@link todo_list_todos}), is target for logs. Cannot perform privileged admin actions. Users are independently managed entities representing the main service customer base.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"User's unique login email address. Used for authentication and identification. Must be unique for each user and serve as primary contact for registration, password recovery, and notifications.","nullable":false},{"name":"password_hash","type":"string","description":"Bcrypt/argon2 hashed password for authentication. NEVER stores plain password. Required for user login.","nullable":false},{"name":"name","type":"string","description":"Optional user display name for UI and search. Can be empty or null if not set by user. Not enforced to be unique.","nullable":true},{"name":"avatar_uri","type":"uri","description":"Optional field for user's profile/avatar image URL. Useful for personalized interfaces. Null if user does not set.","nullable":true},{"name":"status","type":"string","description":"Current account status (e.g., active, locked, disabled). Used for lifecycle control, login restriction, or compliance. Business logic enforces legal values; implement as string here for flexibility.","nullable":false},{"name":"last_login_at","type":"datetime","description":"Timestamp of user's most recent successful login. Used for security and audit. Null if never logged in yet.","nullable":true},{"name":"created_at","type":"datetime","description":"Record creation time (UTC). Used for audit trail and time-based queries.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp of most recent data update to the user record.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Soft-deletion timestamp. If not null, user is considered deleted (not visible in main listings, subject to compliance retention).","nullable":true}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]},{"fieldNames":["status"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"todo_list_admins","description":"Administrator accounts table. Stores admin credentials, authentication, status, profile, and privileged operational data. Used to manage and operate all aspects of the Todo List service and review or delete user todos as necessary. Requires auditability of all administrative actions. Account is distinct from regular users for business control and compliance, isolating admin roles from end-user personas.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Administrator's unique login email. For secure privileged access only. Must be unique among admin accounts.","nullable":false},{"name":"password_hash","type":"string","description":"Hash of admin's password, as in user accounts. For login authentication (bcrypt/argon2 hash).","nullable":false},{"name":"name","type":"string","description":"Administrator's display name for UI, policy, and audit references. Nullable if not set but strongly encouraged for logging.","nullable":true},{"name":"avatar_uri","type":"uri","description":"Optional admin profile/avatar image.","nullable":true},{"name":"status","type":"string","description":"Current admin account status (e.g., active, locked, disabled, suspended). Used for controlling access to admin actions; values managed by business logic.","nullable":false},{"name":"privilege_level","type":"string","description":"Business-defined privilege level (e.g., superadmin, support, auditor). Used for assigning different sets of administrative permissions within the admin domain.","nullable":false},{"name":"last_admin_action_at","type":"datetime","description":"Timestamp of the admin's most recent privileged operational action (e.g., delete user todo, set announcement). Used for audit tracking and accountability.","nullable":true},{"name":"last_login_at","type":"datetime","description":"Timestamp of the administrator's last successful login. Used for security and operational auditing.","nullable":true},{"name":"created_at","type":"datetime","description":"Admin account creation timestamp (UTC). Used for onboarding tracking and auditing.","nullable":false},{"name":"updated_at","type":"datetime","description":"Most recent update timestamp, for audit and policy enforcement.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Soft-delete timestamp; if not null, admin account is technically deleted or suspended.","nullable":true}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["privilege_level"]},{"fieldNames":["created_at"]},{"fieldNames":["status"]}],"ginIndexes":[{"fieldName":"name"}]}]},{"filename":"schema-02-todos.prisma","namespace":"Todos","models":[{"name":"todo_list_todos","description":"Represents individual tasks (todos) created and owned by users. Each todo can have content (with a business rule of maximum 255 characters), optional due date, and a completed status. Only the owner (or an admin) can view, edit, mark complete/incomplete, or delete each todo. This table supports per-user task management, access enforcement, and core productivity operations. Cross-references todo_list_users for ownership linkage.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"todo_list_user_id","type":"uuid","description":"Owner user's {@link todo_list_users.id}. Indicates which user this todo belongs to.","relation":{"name":"user","targetModel":"todo_list_users"},"unique":false,"nullable":false}],"plainFields":[{"name":"content","type":"string","description":"The textual content of the todo. Maximum 255 characters, trimmed of whitespace, must not be empty or only whitespace. Validated business rules (no control characters, required).","nullable":false},{"name":"due_date","type":"datetime","description":"Optional due date for the todo, null if not set. If present, must be an ISO date not before creation date.","nullable":true},{"name":"completed","type":"boolean","description":"Whether the todo has been marked as completed. Defaults to false on creation, toggled by user action.","nullable":false},{"name":"completed_at","type":"datetime","description":"Timestamp when the todo was marked as completed. Null if not completed.","nullable":true},{"name":"created_at","type":"datetime","description":"When this todo was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp of the last modification to this todo (edit, status change, etc).","nullable":false}],"uniqueIndexes":[{"fieldNames":["todo_list_user_id","content"],"unique":true}],"plainIndexes":[{"fieldNames":["todo_list_user_id","created_at"]},{"fieldNames":["todo_list_user_id","completed"]}],"ginIndexes":[{"fieldName":"content"}]},{"name":"todo_list_audit_logs","description":"Records all admin-initiated actions affecting any user's todos, such as viewing or deleting a user's todo for compliance or security purposes. Captures admin username, affected user, target todo, admin action (enum: 'view', 'delete'), rationale (optional free text), and audit timestamp. Supports privacy compliance, monitoring, and traceability in accordance with business and legal policy.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"todo_list_admin_id","type":"uuid","description":"Admin's {@link todo_list_admins.id} who performed the action.","relation":{"name":"admin","targetModel":"todo_list_admins"},"unique":false,"nullable":false},{"name":"todo_list_user_id","type":"uuid","description":"Target user's {@link todo_list_users.id} whose todo was affected or accessed.","relation":{"name":"user","targetModel":"todo_list_users"},"unique":false,"nullable":false},{"name":"todo_list_todo_id","type":"uuid","description":"Target todo's {@link todo_list_todos.id} affected by the admin action.","relation":{"name":"todo","targetModel":"todo_list_todos"},"unique":false,"nullable":false}],"plainFields":[{"name":"action","type":"string","description":"Admin action type on the todo. Enum: 'view', 'delete'.","nullable":false},{"name":"rationale","type":"string","description":"Optional explanation or justification text for the admin action. Free text field; null allowed for non-sensitive actions.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when this audit log entry was created.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["todo_list_user_id","created_at"]},{"fieldNames":["action"]}],"ginIndexes":[]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-actors.prisma":"/// Application users table. Stores core account/authentication credentials,\n/// registration data, profile fields, and business status for each user.\n/// Used to verify personal identity, manage sessions, and enforce\n/// user-specific business rules. Core relationships: owns many todos (see\n/// {@link todo_list_todos}), is target for logs. Cannot perform privileged\n/// admin actions. Users are independently managed entities representing the\n/// main service customer base.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// User's unique login email address. Used for authentication and\n  /// identification. Must be unique for each user and serve as primary contact\n  /// for registration, password recovery, and notifications.\n  email String\n\n  /// Bcrypt/argon2 hashed password for authentication. NEVER stores plain\n  /// password. Required for user login.\n  password_hash String\n\n  /// Optional user display name for UI and search. Can be empty or null if not\n  /// set by user. Not enforced to be unique.\n  name String?\n\n  /// Optional field for user's profile/avatar image URL. Useful for\n  /// personalized interfaces. Null if user does not set.\n  avatar_uri String? @db.VarChar(80000)\n\n  /// Current account status (e.g., active, locked, disabled). Used for\n  /// lifecycle control, login restriction, or compliance. Business logic\n  /// enforces legal values; implement as string here for flexibility.\n  status String\n\n  /// Timestamp of user's most recent successful login. Used for security and\n  /// audit. Null if never logged in yet.\n  last_login_at DateTime? @db.Timestamptz\n\n  /// Record creation time (UTC). Used for audit trail and time-based queries.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp of most recent data update to the user record.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft-deletion timestamp. If not null, user is considered deleted (not\n  /// visible in main listings, subject to compliance retention).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  todo_list_todos      todo_list_todos[]\n  todo_list_audit_logs todo_list_audit_logs[]\n\n  @@unique([email])\n  @@index([created_at])\n  @@index([status])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Administrator accounts table. Stores admin credentials, authentication,\n/// status, profile, and privileged operational data. Used to manage and\n/// operate all aspects of the Todo List service and review or delete user\n/// todos as necessary. Requires auditability of all administrative actions.\n/// Account is distinct from regular users for business control and\n/// compliance, isolating admin roles from end-user personas.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_admins {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Administrator's unique login email. For secure privileged access only.\n  /// Must be unique among admin accounts.\n  email String\n\n  /// Hash of admin's password, as in user accounts. For login authentication\n  /// (bcrypt/argon2 hash).\n  password_hash String\n\n  /// Administrator's display name for UI, policy, and audit references.\n  /// Nullable if not set but strongly encouraged for logging.\n  name String?\n\n  /// Optional admin profile/avatar image.\n  avatar_uri String? @db.VarChar(80000)\n\n  /// Current admin account status (e.g., active, locked, disabled, suspended).\n  /// Used for controlling access to admin actions; values managed by business\n  /// logic.\n  status String\n\n  /// Business-defined privilege level (e.g., superadmin, support, auditor).\n  /// Used for assigning different sets of administrative permissions within\n  /// the admin domain.\n  privilege_level String\n\n  /// Timestamp of the admin's most recent privileged operational action (e.g.,\n  /// delete user todo, set announcement). Used for audit tracking and\n  /// accountability.\n  last_admin_action_at DateTime? @db.Timestamptz\n\n  /// Timestamp of the administrator's last successful login. Used for security\n  /// and operational auditing.\n  last_login_at DateTime? @db.Timestamptz\n\n  /// Admin account creation timestamp (UTC). Used for onboarding tracking and\n  /// auditing.\n  created_at DateTime @db.Timestamptz\n\n  /// Most recent update timestamp, for audit and policy enforcement.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft-delete timestamp; if not null, admin account is technically deleted\n  /// or suspended.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  todo_list_audit_logs todo_list_audit_logs[]\n\n  @@unique([email])\n  @@index([privilege_level])\n  @@index([created_at])\n  @@index([status])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-02-todos.prisma":"/// Represents individual tasks (todos) created and owned by users. Each todo\n/// can have content (with a business rule of maximum 255 characters),\n/// optional due date, and a completed status. Only the owner (or an admin)\n/// can view, edit, mark complete/incomplete, or delete each todo. This table\n/// supports per-user task management, access enforcement, and core\n/// productivity operations. Cross-references todo_list_users for ownership\n/// linkage.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_todos {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Owner user's {@link todo_list_users.id}. Indicates which user this todo\n  /// belongs to.\n  todo_list_user_id String @db.Uuid\n\n  /// The textual content of the todo. Maximum 255 characters, trimmed of\n  /// whitespace, must not be empty or only whitespace. Validated business\n  /// rules (no control characters, required).\n  content String\n\n  /// Optional due date for the todo, null if not set. If present, must be an\n  /// ISO date not before creation date.\n  due_date DateTime? @db.Timestamptz\n\n  /// Whether the todo has been marked as completed. Defaults to false on\n  /// creation, toggled by user action.\n  completed Boolean\n\n  /// Timestamp when the todo was marked as completed. Null if not completed.\n  completed_at DateTime? @db.Timestamptz\n\n  /// When this todo was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp of the last modification to this todo (edit, status change,\n  /// etc).\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user todo_list_users @relation(fields: [todo_list_user_id], references: [id], onDelete: Cascade)\n\n  todo_list_audit_logs todo_list_audit_logs[]\n\n  @@unique([todo_list_user_id, content])\n  @@index([todo_list_user_id, created_at])\n  @@index([todo_list_user_id, completed])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Records all admin-initiated actions affecting any user's todos, such as\n/// viewing or deleting a user's todo for compliance or security purposes.\n/// Captures admin username, affected user, target todo, admin action (enum:\n/// 'view', 'delete'), rationale (optional free text), and audit timestamp.\n/// Supports privacy compliance, monitoring, and traceability in accordance\n/// with business and legal policy.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_audit_logs {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Admin's {@link todo_list_admins.id} who performed the action.\n  todo_list_admin_id String @db.Uuid\n\n  /// Target user's {@link todo_list_users.id} whose todo was affected or\n  /// accessed.\n  todo_list_user_id String @db.Uuid\n\n  /// Target todo's {@link todo_list_todos.id} affected by the admin action.\n  todo_list_todo_id String @db.Uuid\n\n  /// Admin action type on the todo. Enum: 'view', 'delete'.\n  action String\n\n  /// Optional explanation or justification text for the admin action. Free\n  /// text field; null allowed for non-sensitive actions.\n  rationale String?\n\n  /// Timestamp when this audit log entry was created.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  admin todo_list_admins @relation(fields: [todo_list_admin_id], references: [id], onDelete: Cascade)\n  user  todo_list_users  @relation(fields: [todo_list_user_id], references: [id], onDelete: Cascade)\n  todo  todo_list_todos  @relation(fields: [todo_list_todo_id], references: [id], onDelete: Cascade)\n\n  @@index([todo_list_admin_id])\n  @@index([todo_list_todo_id])\n  @@index([todo_list_user_id, created_at])\n  @@index([action])\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/client.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model todo_list_users\n * Application users table. Stores core account/authentication credentials,\n * registration data, profile fields, and business status for each user.\n * Used to verify personal identity, manage sessions, and enforce\n * user-specific business rules. Core relationships: owns many todos (see\n * {@link todo_list_todos}), is target for logs. Cannot perform privileged\n * admin actions. Users are independently managed entities representing the\n * main service customer base.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_users = $Result.DefaultSelection<Prisma.$todo_list_usersPayload>\n/**\n * Model todo_list_admins\n * Administrator accounts table. Stores admin credentials, authentication,\n * status, profile, and privileged operational data. Used to manage and\n * operate all aspects of the Todo List service and review or delete user\n * todos as necessary. Requires auditability of all administrative actions.\n * Account is distinct from regular users for business control and\n * compliance, isolating admin roles from end-user personas.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_admins = $Result.DefaultSelection<Prisma.$todo_list_adminsPayload>\n/**\n * Model todo_list_todos\n * Represents individual tasks (todos) created and owned by users. Each todo\n * can have content (with a business rule of maximum 255 characters),\n * optional due date, and a completed status. Only the owner (or an admin)\n * can view, edit, mark complete/incomplete, or delete each todo. This table\n * supports per-user task management, access enforcement, and core\n * productivity operations. Cross-references todo_list_users for ownership\n * linkage.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_todos = $Result.DefaultSelection<Prisma.$todo_list_todosPayload>\n/**\n * Model todo_list_audit_logs\n * Records all admin-initiated actions affecting any user's todos, such as\n * viewing or deleting a user's todo for compliance or security purposes.\n * Captures admin username, affected user, target todo, admin action (enum:\n * 'view', 'delete'), rationale (optional free text), and audit timestamp.\n * Supports privacy compliance, monitoring, and traceability in accordance\n * with business and legal policy.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_audit_logs = $Result.DefaultSelection<Prisma.$todo_list_audit_logsPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Todo_list_users\n * const todo_list_users = await prisma.todo_list_users.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Todo_list_users\n   * const todo_list_users = await prisma.todo_list_users.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.todo_list_users`: Exposes CRUD operations for the **todo_list_users** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_users\n    * const todo_list_users = await prisma.todo_list_users.findMany()\n    * ```\n    */\n  get todo_list_users(): Prisma.todo_list_usersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_list_admins`: Exposes CRUD operations for the **todo_list_admins** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_admins\n    * const todo_list_admins = await prisma.todo_list_admins.findMany()\n    * ```\n    */\n  get todo_list_admins(): Prisma.todo_list_adminsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_list_todos`: Exposes CRUD operations for the **todo_list_todos** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_todos\n    * const todo_list_todos = await prisma.todo_list_todos.findMany()\n    * ```\n    */\n  get todo_list_todos(): Prisma.todo_list_todosDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_list_audit_logs`: Exposes CRUD operations for the **todo_list_audit_logs** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_audit_logs\n    * const todo_list_audit_logs = await prisma.todo_list_audit_logs.findMany()\n    * ```\n    */\n  get todo_list_audit_logs(): Prisma.todo_list_audit_logsDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    todo_list_users: 'todo_list_users',\n    todo_list_admins: 'todo_list_admins',\n    todo_list_todos: 'todo_list_todos',\n    todo_list_audit_logs: 'todo_list_audit_logs'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"todo_list_users\" | \"todo_list_admins\" | \"todo_list_todos\" | \"todo_list_audit_logs\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      todo_list_users: {\n        payload: Prisma.$todo_list_usersPayload<ExtArgs>\n        fields: Prisma.todo_list_usersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_usersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_usersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_usersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_usersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_usersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_usersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_usersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_usersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_usersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          update: {\n            args: Prisma.todo_list_usersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_usersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_usersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_usersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_usersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_usersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_users>\n          }\n          groupBy: {\n            args: Prisma.todo_list_usersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_usersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_usersCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_usersCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_list_admins: {\n        payload: Prisma.$todo_list_adminsPayload<ExtArgs>\n        fields: Prisma.todo_list_adminsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_adminsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_adminsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_adminsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_adminsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_adminsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_adminsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_adminsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_adminsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_adminsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          update: {\n            args: Prisma.todo_list_adminsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_adminsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_adminsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_adminsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_adminsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_adminsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_admins>\n          }\n          groupBy: {\n            args: Prisma.todo_list_adminsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_adminsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_adminsCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_adminsCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_list_todos: {\n        payload: Prisma.$todo_list_todosPayload<ExtArgs>\n        fields: Prisma.todo_list_todosFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_todosFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_todosFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_todosFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_todosFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_todosFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_todosCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_todosCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_todosCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_todosDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          update: {\n            args: Prisma.todo_list_todosUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_todosDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_todosUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_todosUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_todosUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_todosAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_todos>\n          }\n          groupBy: {\n            args: Prisma.todo_list_todosGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_todosGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_todosCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_todosCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_list_audit_logs: {\n        payload: Prisma.$todo_list_audit_logsPayload<ExtArgs>\n        fields: Prisma.todo_list_audit_logsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_audit_logsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_audit_logsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_audit_logsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_audit_logsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_audit_logsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_audit_logsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_audit_logsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_audit_logsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_audit_logsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>\n          }\n          update: {\n            args: Prisma.todo_list_audit_logsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_audit_logsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_audit_logsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_audit_logsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_audit_logsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_audit_logsPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_audit_logsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_audit_logs>\n          }\n          groupBy: {\n            args: Prisma.todo_list_audit_logsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_audit_logsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_audit_logsCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_audit_logsCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`\n     */\n    adapter?: runtime.SqlDriverAdapterFactory | null\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    todo_list_users?: todo_list_usersOmit\n    todo_list_admins?: todo_list_adminsOmit\n    todo_list_todos?: todo_list_todosOmit\n    todo_list_audit_logs?: todo_list_audit_logsOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Todo_list_usersCountOutputType\n   */\n\n  export type Todo_list_usersCountOutputType = {\n    todo_list_todos: number\n    todo_list_audit_logs: number\n  }\n\n  export type Todo_list_usersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_todos?: boolean | Todo_list_usersCountOutputTypeCountTodo_list_todosArgs\n    todo_list_audit_logs?: boolean | Todo_list_usersCountOutputTypeCountTodo_list_audit_logsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_list_usersCountOutputType without action\n   */\n  export type Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_list_usersCountOutputType\n     */\n    select?: Todo_list_usersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_list_usersCountOutputType without action\n   */\n  export type Todo_list_usersCountOutputTypeCountTodo_list_todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_todosWhereInput\n  }\n\n  /**\n   * Todo_list_usersCountOutputType without action\n   */\n  export type Todo_list_usersCountOutputTypeCountTodo_list_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_audit_logsWhereInput\n  }\n\n\n  /**\n   * Count Type Todo_list_adminsCountOutputType\n   */\n\n  export type Todo_list_adminsCountOutputType = {\n    todo_list_audit_logs: number\n  }\n\n  export type Todo_list_adminsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_audit_logs?: boolean | Todo_list_adminsCountOutputTypeCountTodo_list_audit_logsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_list_adminsCountOutputType without action\n   */\n  export type Todo_list_adminsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_list_adminsCountOutputType\n     */\n    select?: Todo_list_adminsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_list_adminsCountOutputType without action\n   */\n  export type Todo_list_adminsCountOutputTypeCountTodo_list_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_audit_logsWhereInput\n  }\n\n\n  /**\n   * Count Type Todo_list_todosCountOutputType\n   */\n\n  export type Todo_list_todosCountOutputType = {\n    todo_list_audit_logs: number\n  }\n\n  export type Todo_list_todosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_audit_logs?: boolean | Todo_list_todosCountOutputTypeCountTodo_list_audit_logsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_list_todosCountOutputType without action\n   */\n  export type Todo_list_todosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_list_todosCountOutputType\n     */\n    select?: Todo_list_todosCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_list_todosCountOutputType without action\n   */\n  export type Todo_list_todosCountOutputTypeCountTodo_list_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_audit_logsWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model todo_list_users\n   */\n\n  export type AggregateTodo_list_users = {\n    _count: Todo_list_usersCountAggregateOutputType | null\n    _min: Todo_list_usersMinAggregateOutputType | null\n    _max: Todo_list_usersMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_usersMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    avatar_uri: string | null\n    status: string | null\n    last_login_at: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_list_usersMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    avatar_uri: string | null\n    status: string | null\n    last_login_at: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_list_usersCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    name: number\n    avatar_uri: number\n    status: number\n    last_login_at: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_usersMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    avatar_uri?: true\n    status?: true\n    last_login_at?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_list_usersMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    avatar_uri?: true\n    status?: true\n    last_login_at?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_list_usersCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    avatar_uri?: true\n    status?: true\n    last_login_at?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_users to aggregate.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_users\n    **/\n    _count?: true | Todo_list_usersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_usersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_usersMaxAggregateInputType\n  }\n\n  export type GetTodo_list_usersAggregateType<T extends Todo_list_usersAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_users]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_users[P]>\n      : GetScalarType<T[P], AggregateTodo_list_users[P]>\n  }\n\n\n\n\n  export type todo_list_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_usersWhereInput\n    orderBy?: todo_list_usersOrderByWithAggregationInput | todo_list_usersOrderByWithAggregationInput[]\n    by: Todo_list_usersScalarFieldEnum[] | Todo_list_usersScalarFieldEnum\n    having?: todo_list_usersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_usersCountAggregateInputType | true\n    _min?: Todo_list_usersMinAggregateInputType\n    _max?: Todo_list_usersMaxAggregateInputType\n  }\n\n  export type Todo_list_usersGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    name: string | null\n    avatar_uri: string | null\n    status: string\n    last_login_at: Date | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Todo_list_usersCountAggregateOutputType | null\n    _min: Todo_list_usersMinAggregateOutputType | null\n    _max: Todo_list_usersMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_usersGroupByPayload<T extends todo_list_usersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_usersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_usersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_usersGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_usersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    avatar_uri?: boolean\n    status?: boolean\n    last_login_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    todo_list_todos?: boolean | todo_list_users$todo_list_todosArgs<ExtArgs>\n    todo_list_audit_logs?: boolean | todo_list_users$todo_list_audit_logsArgs<ExtArgs>\n    _count?: boolean | Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    avatar_uri?: boolean\n    status?: boolean\n    last_login_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    avatar_uri?: boolean\n    status?: boolean\n    last_login_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    avatar_uri?: boolean\n    status?: boolean\n    last_login_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type todo_list_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"name\" | \"avatar_uri\" | \"status\" | \"last_login_at\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"todo_list_users\"]>\n  export type todo_list_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_todos?: boolean | todo_list_users$todo_list_todosArgs<ExtArgs>\n    todo_list_audit_logs?: boolean | todo_list_users$todo_list_audit_logsArgs<ExtArgs>\n    _count?: boolean | Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_list_usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type todo_list_usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $todo_list_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_users\"\n    objects: {\n      todo_list_todos: Prisma.$todo_list_todosPayload<ExtArgs>[]\n      todo_list_audit_logs: Prisma.$todo_list_audit_logsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * User's unique login email address. Used for authentication and\n       * identification. Must be unique for each user and serve as primary contact\n       * for registration, password recovery, and notifications.\n       */\n      email: string\n      /**\n       * Bcrypt/argon2 hashed password for authentication. NEVER stores plain\n       * password. Required for user login.\n       */\n      password_hash: string\n      /**\n       * Optional user display name for UI and search. Can be empty or null if not\n       * set by user. Not enforced to be unique.\n       */\n      name: string | null\n      /**\n       * Optional field for user's profile/avatar image URL. Useful for\n       * personalized interfaces. Null if user does not set.\n       */\n      avatar_uri: string | null\n      /**\n       * Current account status (e.g., active, locked, disabled). Used for\n       * lifecycle control, login restriction, or compliance. Business logic\n       * enforces legal values; implement as string here for flexibility.\n       */\n      status: string\n      /**\n       * Timestamp of user's most recent successful login. Used for security and\n       * audit. Null if never logged in yet.\n       */\n      last_login_at: Date | null\n      /**\n       * Record creation time (UTC). Used for audit trail and time-based queries.\n       */\n      created_at: Date\n      /**\n       * Timestamp of most recent data update to the user record.\n       */\n      updated_at: Date\n      /**\n       * Soft-deletion timestamp. If not null, user is considered deleted (not\n       * visible in main listings, subject to compliance retention).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"todo_list_users\"]>\n    composites: {}\n  }\n\n  type todo_list_usersGetPayload<S extends boolean | null | undefined | todo_list_usersDefaultArgs> = $Result.GetResult<Prisma.$todo_list_usersPayload, S>\n\n  type todo_list_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_usersCountAggregateInputType | true\n    }\n\n  export interface todo_list_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_users'], meta: { name: 'todo_list_users' } }\n    /**\n     * Find zero or one Todo_list_users that matches the filter.\n     * @param {todo_list_usersFindUniqueArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_usersFindUniqueArgs>(args: SelectSubset<T, todo_list_usersFindUniqueArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_users that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_usersFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindFirstArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_usersFindFirstArgs>(args?: SelectSubset<T, todo_list_usersFindFirstArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_users that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindFirstOrThrowArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findMany()\n     * \n     * // Get first 10 Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_usersFindManyArgs>(args?: SelectSubset<T, todo_list_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_users.\n     * @param {todo_list_usersCreateArgs} args - Arguments to create a Todo_list_users.\n     * @example\n     * // Create one Todo_list_users\n     * const Todo_list_users = await prisma.todo_list_users.create({\n     *   data: {\n     *     // ... data to create a Todo_list_users\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_usersCreateArgs>(args: SelectSubset<T, todo_list_usersCreateArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_users.\n     * @param {todo_list_usersCreateManyArgs} args - Arguments to create many Todo_list_users.\n     * @example\n     * // Create many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_usersCreateManyArgs>(args?: SelectSubset<T, todo_list_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_users and returns the data saved in the database.\n     * @param {todo_list_usersCreateManyAndReturnArgs} args - Arguments to create many Todo_list_users.\n     * @example\n     * // Create many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_users and only return the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_users.\n     * @param {todo_list_usersDeleteArgs} args - Arguments to delete one Todo_list_users.\n     * @example\n     * // Delete one Todo_list_users\n     * const Todo_list_users = await prisma.todo_list_users.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_users\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_usersDeleteArgs>(args: SelectSubset<T, todo_list_usersDeleteArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_users.\n     * @param {todo_list_usersUpdateArgs} args - Arguments to update one Todo_list_users.\n     * @example\n     * // Update one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_usersUpdateArgs>(args: SelectSubset<T, todo_list_usersUpdateArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_users.\n     * @param {todo_list_usersDeleteManyArgs} args - Arguments to filter Todo_list_users to delete.\n     * @example\n     * // Delete a few Todo_list_users\n     * const { count } = await prisma.todo_list_users.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_usersDeleteManyArgs>(args?: SelectSubset<T, todo_list_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_usersUpdateManyArgs>(args: SelectSubset<T, todo_list_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_users and returns the data updated in the database.\n     * @param {todo_list_usersUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_users.\n     * @example\n     * // Update many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_users and only return the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_users.\n     * @param {todo_list_usersUpsertArgs} args - Arguments to update or create a Todo_list_users.\n     * @example\n     * // Update or create a Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_users\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_users we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_usersUpsertArgs>(args: SelectSubset<T, todo_list_usersUpsertArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersCountArgs} args - Arguments to filter Todo_list_users to count.\n     * @example\n     * // Count the number of Todo_list_users\n     * const count = await prisma.todo_list_users.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_users we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_usersCountArgs>(\n      args?: Subset<T, todo_list_usersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_usersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_usersAggregateArgs>(args: Subset<T, Todo_list_usersAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_usersAggregateType<T>>\n\n    /**\n     * Group by Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_usersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_usersGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_usersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_users model\n   */\n  readonly fields: todo_list_usersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_users.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    todo_list_todos<T extends todo_list_users$todo_list_todosArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_users$todo_list_todosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    todo_list_audit_logs<T extends todo_list_users$todo_list_audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_users$todo_list_audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_users model\n   */\n  interface todo_list_usersFieldRefs {\n    readonly id: FieldRef<\"todo_list_users\", 'String'>\n    readonly email: FieldRef<\"todo_list_users\", 'String'>\n    readonly password_hash: FieldRef<\"todo_list_users\", 'String'>\n    readonly name: FieldRef<\"todo_list_users\", 'String'>\n    readonly avatar_uri: FieldRef<\"todo_list_users\", 'String'>\n    readonly status: FieldRef<\"todo_list_users\", 'String'>\n    readonly last_login_at: FieldRef<\"todo_list_users\", 'DateTime'>\n    readonly created_at: FieldRef<\"todo_list_users\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_users\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"todo_list_users\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_users findUnique\n   */\n  export type todo_list_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users findUniqueOrThrow\n   */\n  export type todo_list_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users findFirst\n   */\n  export type todo_list_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_users.\n     */\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users findFirstOrThrow\n   */\n  export type todo_list_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_users.\n     */\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users findMany\n   */\n  export type todo_list_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users create\n   */\n  export type todo_list_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_users.\n     */\n    data: XOR<todo_list_usersCreateInput, todo_list_usersUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_users createMany\n   */\n  export type todo_list_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_users.\n     */\n    data: todo_list_usersCreateManyInput | todo_list_usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_users createManyAndReturn\n   */\n  export type todo_list_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_users.\n     */\n    data: todo_list_usersCreateManyInput | todo_list_usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_users update\n   */\n  export type todo_list_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateInput, todo_list_usersUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_users to update.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users updateMany\n   */\n  export type todo_list_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateManyMutationInput, todo_list_usersUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_users to update\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users updateManyAndReturn\n   */\n  export type todo_list_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateManyMutationInput, todo_list_usersUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_users to update\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users upsert\n   */\n  export type todo_list_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_users to update in case it exists.\n     */\n    where: todo_list_usersWhereUniqueInput\n    /**\n     * In case the todo_list_users found by the `where` argument doesn't exist, create a new todo_list_users with this data.\n     */\n    create: XOR<todo_list_usersCreateInput, todo_list_usersUncheckedCreateInput>\n    /**\n     * In case the todo_list_users was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_usersUpdateInput, todo_list_usersUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_users delete\n   */\n  export type todo_list_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_users to delete.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users deleteMany\n   */\n  export type todo_list_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_users to delete\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users.todo_list_todos\n   */\n  export type todo_list_users$todo_list_todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    where?: todo_list_todosWhereInput\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    cursor?: todo_list_todosWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users.todo_list_audit_logs\n   */\n  export type todo_list_users$todo_list_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    where?: todo_list_audit_logsWhereInput\n    orderBy?: todo_list_audit_logsOrderByWithRelationInput | todo_list_audit_logsOrderByWithRelationInput[]\n    cursor?: todo_list_audit_logsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_list_audit_logsScalarFieldEnum | Todo_list_audit_logsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users without action\n   */\n  export type todo_list_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_list_admins\n   */\n\n  export type AggregateTodo_list_admins = {\n    _count: Todo_list_adminsCountAggregateOutputType | null\n    _min: Todo_list_adminsMinAggregateOutputType | null\n    _max: Todo_list_adminsMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_adminsMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    avatar_uri: string | null\n    status: string | null\n    privilege_level: string | null\n    last_admin_action_at: Date | null\n    last_login_at: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_list_adminsMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    avatar_uri: string | null\n    status: string | null\n    privilege_level: string | null\n    last_admin_action_at: Date | null\n    last_login_at: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_list_adminsCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    name: number\n    avatar_uri: number\n    status: number\n    privilege_level: number\n    last_admin_action_at: number\n    last_login_at: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_adminsMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    avatar_uri?: true\n    status?: true\n    privilege_level?: true\n    last_admin_action_at?: true\n    last_login_at?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_list_adminsMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    avatar_uri?: true\n    status?: true\n    privilege_level?: true\n    last_admin_action_at?: true\n    last_login_at?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_list_adminsCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    avatar_uri?: true\n    status?: true\n    privilege_level?: true\n    last_admin_action_at?: true\n    last_login_at?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_adminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_admins to aggregate.\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_admins to fetch.\n     */\n    orderBy?: todo_list_adminsOrderByWithRelationInput | todo_list_adminsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_adminsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_admins\n    **/\n    _count?: true | Todo_list_adminsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_adminsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_adminsMaxAggregateInputType\n  }\n\n  export type GetTodo_list_adminsAggregateType<T extends Todo_list_adminsAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_admins]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_admins[P]>\n      : GetScalarType<T[P], AggregateTodo_list_admins[P]>\n  }\n\n\n\n\n  export type todo_list_adminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_adminsWhereInput\n    orderBy?: todo_list_adminsOrderByWithAggregationInput | todo_list_adminsOrderByWithAggregationInput[]\n    by: Todo_list_adminsScalarFieldEnum[] | Todo_list_adminsScalarFieldEnum\n    having?: todo_list_adminsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_adminsCountAggregateInputType | true\n    _min?: Todo_list_adminsMinAggregateInputType\n    _max?: Todo_list_adminsMaxAggregateInputType\n  }\n\n  export type Todo_list_adminsGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    name: string | null\n    avatar_uri: string | null\n    status: string\n    privilege_level: string\n    last_admin_action_at: Date | null\n    last_login_at: Date | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Todo_list_adminsCountAggregateOutputType | null\n    _min: Todo_list_adminsMinAggregateOutputType | null\n    _max: Todo_list_adminsMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_adminsGroupByPayload<T extends todo_list_adminsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_adminsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_adminsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_adminsGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_adminsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_adminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    avatar_uri?: boolean\n    status?: boolean\n    privilege_level?: boolean\n    last_admin_action_at?: boolean\n    last_login_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    todo_list_audit_logs?: boolean | todo_list_admins$todo_list_audit_logsArgs<ExtArgs>\n    _count?: boolean | Todo_list_adminsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_admins\"]>\n\n  export type todo_list_adminsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    avatar_uri?: boolean\n    status?: boolean\n    privilege_level?: boolean\n    last_admin_action_at?: boolean\n    last_login_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_admins\"]>\n\n  export type todo_list_adminsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    avatar_uri?: boolean\n    status?: boolean\n    privilege_level?: boolean\n    last_admin_action_at?: boolean\n    last_login_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_admins\"]>\n\n  export type todo_list_adminsSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    avatar_uri?: boolean\n    status?: boolean\n    privilege_level?: boolean\n    last_admin_action_at?: boolean\n    last_login_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type todo_list_adminsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"name\" | \"avatar_uri\" | \"status\" | \"privilege_level\" | \"last_admin_action_at\" | \"last_login_at\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"todo_list_admins\"]>\n  export type todo_list_adminsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_audit_logs?: boolean | todo_list_admins$todo_list_audit_logsArgs<ExtArgs>\n    _count?: boolean | Todo_list_adminsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_list_adminsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type todo_list_adminsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $todo_list_adminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_admins\"\n    objects: {\n      todo_list_audit_logs: Prisma.$todo_list_audit_logsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Administrator's unique login email. For secure privileged access only.\n       * Must be unique among admin accounts.\n       */\n      email: string\n      /**\n       * Hash of admin's password, as in user accounts. For login authentication\n       * (bcrypt/argon2 hash).\n       */\n      password_hash: string\n      /**\n       * Administrator's display name for UI, policy, and audit references.\n       * Nullable if not set but strongly encouraged for logging.\n       */\n      name: string | null\n      /**\n       * Optional admin profile/avatar image.\n       */\n      avatar_uri: string | null\n      /**\n       * Current admin account status (e.g., active, locked, disabled, suspended).\n       * Used for controlling access to admin actions; values managed by business\n       * logic.\n       */\n      status: string\n      /**\n       * Business-defined privilege level (e.g., superadmin, support, auditor).\n       * Used for assigning different sets of administrative permissions within\n       * the admin domain.\n       */\n      privilege_level: string\n      /**\n       * Timestamp of the admin's most recent privileged operational action (e.g.,\n       * delete user todo, set announcement). Used for audit tracking and\n       * accountability.\n       */\n      last_admin_action_at: Date | null\n      /**\n       * Timestamp of the administrator's last successful login. Used for security\n       * and operational auditing.\n       */\n      last_login_at: Date | null\n      /**\n       * Admin account creation timestamp (UTC). Used for onboarding tracking and\n       * auditing.\n       */\n      created_at: Date\n      /**\n       * Most recent update timestamp, for audit and policy enforcement.\n       */\n      updated_at: Date\n      /**\n       * Soft-delete timestamp; if not null, admin account is technically deleted\n       * or suspended.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"todo_list_admins\"]>\n    composites: {}\n  }\n\n  type todo_list_adminsGetPayload<S extends boolean | null | undefined | todo_list_adminsDefaultArgs> = $Result.GetResult<Prisma.$todo_list_adminsPayload, S>\n\n  type todo_list_adminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_adminsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_adminsCountAggregateInputType | true\n    }\n\n  export interface todo_list_adminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_admins'], meta: { name: 'todo_list_admins' } }\n    /**\n     * Find zero or one Todo_list_admins that matches the filter.\n     * @param {todo_list_adminsFindUniqueArgs} args - Arguments to find a Todo_list_admins\n     * @example\n     * // Get one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_adminsFindUniqueArgs>(args: SelectSubset<T, todo_list_adminsFindUniqueArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_admins that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_adminsFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_admins\n     * @example\n     * // Get one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_adminsFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_adminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_admins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsFindFirstArgs} args - Arguments to find a Todo_list_admins\n     * @example\n     * // Get one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_adminsFindFirstArgs>(args?: SelectSubset<T, todo_list_adminsFindFirstArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_admins that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsFindFirstOrThrowArgs} args - Arguments to find a Todo_list_admins\n     * @example\n     * // Get one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_adminsFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_adminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_admins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findMany()\n     * \n     * // Get first 10 Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_adminsWithIdOnly = await prisma.todo_list_admins.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_adminsFindManyArgs>(args?: SelectSubset<T, todo_list_adminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_admins.\n     * @param {todo_list_adminsCreateArgs} args - Arguments to create a Todo_list_admins.\n     * @example\n     * // Create one Todo_list_admins\n     * const Todo_list_admins = await prisma.todo_list_admins.create({\n     *   data: {\n     *     // ... data to create a Todo_list_admins\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_adminsCreateArgs>(args: SelectSubset<T, todo_list_adminsCreateArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_admins.\n     * @param {todo_list_adminsCreateManyArgs} args - Arguments to create many Todo_list_admins.\n     * @example\n     * // Create many Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_adminsCreateManyArgs>(args?: SelectSubset<T, todo_list_adminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_admins and returns the data saved in the database.\n     * @param {todo_list_adminsCreateManyAndReturnArgs} args - Arguments to create many Todo_list_admins.\n     * @example\n     * // Create many Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_admins and only return the `id`\n     * const todo_list_adminsWithIdOnly = await prisma.todo_list_admins.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_adminsCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_adminsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_admins.\n     * @param {todo_list_adminsDeleteArgs} args - Arguments to delete one Todo_list_admins.\n     * @example\n     * // Delete one Todo_list_admins\n     * const Todo_list_admins = await prisma.todo_list_admins.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_admins\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_adminsDeleteArgs>(args: SelectSubset<T, todo_list_adminsDeleteArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_admins.\n     * @param {todo_list_adminsUpdateArgs} args - Arguments to update one Todo_list_admins.\n     * @example\n     * // Update one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_adminsUpdateArgs>(args: SelectSubset<T, todo_list_adminsUpdateArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_admins.\n     * @param {todo_list_adminsDeleteManyArgs} args - Arguments to filter Todo_list_admins to delete.\n     * @example\n     * // Delete a few Todo_list_admins\n     * const { count } = await prisma.todo_list_admins.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_adminsDeleteManyArgs>(args?: SelectSubset<T, todo_list_adminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_adminsUpdateManyArgs>(args: SelectSubset<T, todo_list_adminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_admins and returns the data updated in the database.\n     * @param {todo_list_adminsUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_admins.\n     * @example\n     * // Update many Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_admins and only return the `id`\n     * const todo_list_adminsWithIdOnly = await prisma.todo_list_admins.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_adminsUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_adminsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_admins.\n     * @param {todo_list_adminsUpsertArgs} args - Arguments to update or create a Todo_list_admins.\n     * @example\n     * // Update or create a Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_admins\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_admins we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_adminsUpsertArgs>(args: SelectSubset<T, todo_list_adminsUpsertArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsCountArgs} args - Arguments to filter Todo_list_admins to count.\n     * @example\n     * // Count the number of Todo_list_admins\n     * const count = await prisma.todo_list_admins.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_admins we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_adminsCountArgs>(\n      args?: Subset<T, todo_list_adminsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_adminsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_adminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_adminsAggregateArgs>(args: Subset<T, Todo_list_adminsAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_adminsAggregateType<T>>\n\n    /**\n     * Group by Todo_list_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_adminsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_adminsGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_adminsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_adminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_adminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_admins model\n   */\n  readonly fields: todo_list_adminsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_admins.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_adminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    todo_list_audit_logs<T extends todo_list_admins$todo_list_audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_admins$todo_list_audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_admins model\n   */\n  interface todo_list_adminsFieldRefs {\n    readonly id: FieldRef<\"todo_list_admins\", 'String'>\n    readonly email: FieldRef<\"todo_list_admins\", 'String'>\n    readonly password_hash: FieldRef<\"todo_list_admins\", 'String'>\n    readonly name: FieldRef<\"todo_list_admins\", 'String'>\n    readonly avatar_uri: FieldRef<\"todo_list_admins\", 'String'>\n    readonly status: FieldRef<\"todo_list_admins\", 'String'>\n    readonly privilege_level: FieldRef<\"todo_list_admins\", 'String'>\n    readonly last_admin_action_at: FieldRef<\"todo_list_admins\", 'DateTime'>\n    readonly last_login_at: FieldRef<\"todo_list_admins\", 'DateTime'>\n    readonly created_at: FieldRef<\"todo_list_admins\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_admins\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"todo_list_admins\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_admins findUnique\n   */\n  export type todo_list_adminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where: todo_list_adminsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_admins findUniqueOrThrow\n   */\n  export type todo_list_adminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where: todo_list_adminsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_admins findFirst\n   */\n  export type todo_list_adminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_admins to fetch.\n     */\n    orderBy?: todo_list_adminsOrderByWithRelationInput | todo_list_adminsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_admins.\n     */\n    cursor?: todo_list_adminsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_admins.\n     */\n    distinct?: Todo_list_adminsScalarFieldEnum | Todo_list_adminsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_admins findFirstOrThrow\n   */\n  export type todo_list_adminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_admins to fetch.\n     */\n    orderBy?: todo_list_adminsOrderByWithRelationInput | todo_list_adminsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_admins.\n     */\n    cursor?: todo_list_adminsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_admins.\n     */\n    distinct?: Todo_list_adminsScalarFieldEnum | Todo_list_adminsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_admins findMany\n   */\n  export type todo_list_adminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_admins to fetch.\n     */\n    orderBy?: todo_list_adminsOrderByWithRelationInput | todo_list_adminsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_admins.\n     */\n    cursor?: todo_list_adminsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_admins.\n     */\n    skip?: number\n    distinct?: Todo_list_adminsScalarFieldEnum | Todo_list_adminsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_admins create\n   */\n  export type todo_list_adminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_admins.\n     */\n    data: XOR<todo_list_adminsCreateInput, todo_list_adminsUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_admins createMany\n   */\n  export type todo_list_adminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_admins.\n     */\n    data: todo_list_adminsCreateManyInput | todo_list_adminsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_admins createManyAndReturn\n   */\n  export type todo_list_adminsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_admins.\n     */\n    data: todo_list_adminsCreateManyInput | todo_list_adminsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_admins update\n   */\n  export type todo_list_adminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_admins.\n     */\n    data: XOR<todo_list_adminsUpdateInput, todo_list_adminsUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_admins to update.\n     */\n    where: todo_list_adminsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_admins updateMany\n   */\n  export type todo_list_adminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_admins.\n     */\n    data: XOR<todo_list_adminsUpdateManyMutationInput, todo_list_adminsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_admins to update\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * Limit how many todo_list_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_admins updateManyAndReturn\n   */\n  export type todo_list_adminsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_admins.\n     */\n    data: XOR<todo_list_adminsUpdateManyMutationInput, todo_list_adminsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_admins to update\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * Limit how many todo_list_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_admins upsert\n   */\n  export type todo_list_adminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_admins to update in case it exists.\n     */\n    where: todo_list_adminsWhereUniqueInput\n    /**\n     * In case the todo_list_admins found by the `where` argument doesn't exist, create a new todo_list_admins with this data.\n     */\n    create: XOR<todo_list_adminsCreateInput, todo_list_adminsUncheckedCreateInput>\n    /**\n     * In case the todo_list_admins was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_adminsUpdateInput, todo_list_adminsUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_admins delete\n   */\n  export type todo_list_adminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_admins to delete.\n     */\n    where: todo_list_adminsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_admins deleteMany\n   */\n  export type todo_list_adminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_admins to delete\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * Limit how many todo_list_admins to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_admins.todo_list_audit_logs\n   */\n  export type todo_list_admins$todo_list_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    where?: todo_list_audit_logsWhereInput\n    orderBy?: todo_list_audit_logsOrderByWithRelationInput | todo_list_audit_logsOrderByWithRelationInput[]\n    cursor?: todo_list_audit_logsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_list_audit_logsScalarFieldEnum | Todo_list_audit_logsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_admins without action\n   */\n  export type todo_list_adminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_adminsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_list_todos\n   */\n\n  export type AggregateTodo_list_todos = {\n    _count: Todo_list_todosCountAggregateOutputType | null\n    _min: Todo_list_todosMinAggregateOutputType | null\n    _max: Todo_list_todosMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_todosMinAggregateOutputType = {\n    id: string | null\n    todo_list_user_id: string | null\n    content: string | null\n    due_date: Date | null\n    completed: boolean | null\n    completed_at: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Todo_list_todosMaxAggregateOutputType = {\n    id: string | null\n    todo_list_user_id: string | null\n    content: string | null\n    due_date: Date | null\n    completed: boolean | null\n    completed_at: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Todo_list_todosCountAggregateOutputType = {\n    id: number\n    todo_list_user_id: number\n    content: number\n    due_date: number\n    completed: number\n    completed_at: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_todosMinAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    content?: true\n    due_date?: true\n    completed?: true\n    completed_at?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Todo_list_todosMaxAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    content?: true\n    due_date?: true\n    completed?: true\n    completed_at?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Todo_list_todosCountAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    content?: true\n    due_date?: true\n    completed?: true\n    completed_at?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_todosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_todos to aggregate.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_todos\n    **/\n    _count?: true | Todo_list_todosCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_todosMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_todosMaxAggregateInputType\n  }\n\n  export type GetTodo_list_todosAggregateType<T extends Todo_list_todosAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_todos]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_todos[P]>\n      : GetScalarType<T[P], AggregateTodo_list_todos[P]>\n  }\n\n\n\n\n  export type todo_list_todosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_todosWhereInput\n    orderBy?: todo_list_todosOrderByWithAggregationInput | todo_list_todosOrderByWithAggregationInput[]\n    by: Todo_list_todosScalarFieldEnum[] | Todo_list_todosScalarFieldEnum\n    having?: todo_list_todosScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_todosCountAggregateInputType | true\n    _min?: Todo_list_todosMinAggregateInputType\n    _max?: Todo_list_todosMaxAggregateInputType\n  }\n\n  export type Todo_list_todosGroupByOutputType = {\n    id: string\n    todo_list_user_id: string\n    content: string\n    due_date: Date | null\n    completed: boolean\n    completed_at: Date | null\n    created_at: Date\n    updated_at: Date\n    _count: Todo_list_todosCountAggregateOutputType | null\n    _min: Todo_list_todosMinAggregateOutputType | null\n    _max: Todo_list_todosMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_todosGroupByPayload<T extends todo_list_todosGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_todosGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_todosGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_todosGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_todosGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_todosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    content?: boolean\n    due_date?: boolean\n    completed?: boolean\n    completed_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n    todo_list_audit_logs?: boolean | todo_list_todos$todo_list_audit_logsArgs<ExtArgs>\n    _count?: boolean | Todo_list_todosCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    content?: boolean\n    due_date?: boolean\n    completed?: boolean\n    completed_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    content?: boolean\n    due_date?: boolean\n    completed?: boolean\n    completed_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectScalar = {\n    id?: boolean\n    todo_list_user_id?: boolean\n    content?: boolean\n    due_date?: boolean\n    completed?: boolean\n    completed_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type todo_list_todosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"todo_list_user_id\" | \"content\" | \"due_date\" | \"completed\" | \"completed_at\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"todo_list_todos\"]>\n  export type todo_list_todosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n    todo_list_audit_logs?: boolean | todo_list_todos$todo_list_audit_logsArgs<ExtArgs>\n    _count?: boolean | Todo_list_todosCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_list_todosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }\n  export type todo_list_todosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }\n\n  export type $todo_list_todosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_todos\"\n    objects: {\n      user: Prisma.$todo_list_usersPayload<ExtArgs>\n      todo_list_audit_logs: Prisma.$todo_list_audit_logsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Owner user's {@link todo_list_users.id}. Indicates which user this todo\n       * belongs to.\n       */\n      todo_list_user_id: string\n      /**\n       * The textual content of the todo. Maximum 255 characters, trimmed of\n       * whitespace, must not be empty or only whitespace. Validated business\n       * rules (no control characters, required).\n       */\n      content: string\n      /**\n       * Optional due date for the todo, null if not set. If present, must be an\n       * ISO date not before creation date.\n       */\n      due_date: Date | null\n      /**\n       * Whether the todo has been marked as completed. Defaults to false on\n       * creation, toggled by user action.\n       */\n      completed: boolean\n      /**\n       * Timestamp when the todo was marked as completed. Null if not completed.\n       */\n      completed_at: Date | null\n      /**\n       * When this todo was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp of the last modification to this todo (edit, status change,\n       * etc).\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n    composites: {}\n  }\n\n  type todo_list_todosGetPayload<S extends boolean | null | undefined | todo_list_todosDefaultArgs> = $Result.GetResult<Prisma.$todo_list_todosPayload, S>\n\n  type todo_list_todosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_todosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_todosCountAggregateInputType | true\n    }\n\n  export interface todo_list_todosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_todos'], meta: { name: 'todo_list_todos' } }\n    /**\n     * Find zero or one Todo_list_todos that matches the filter.\n     * @param {todo_list_todosFindUniqueArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_todosFindUniqueArgs>(args: SelectSubset<T, todo_list_todosFindUniqueArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_todos that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_todosFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_todosFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_todosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_todos that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindFirstArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_todosFindFirstArgs>(args?: SelectSubset<T, todo_list_todosFindFirstArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_todos that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindFirstOrThrowArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_todosFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_todosFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_todos that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findMany()\n     * \n     * // Get first 10 Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_todosFindManyArgs>(args?: SelectSubset<T, todo_list_todosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_todos.\n     * @param {todo_list_todosCreateArgs} args - Arguments to create a Todo_list_todos.\n     * @example\n     * // Create one Todo_list_todos\n     * const Todo_list_todos = await prisma.todo_list_todos.create({\n     *   data: {\n     *     // ... data to create a Todo_list_todos\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_todosCreateArgs>(args: SelectSubset<T, todo_list_todosCreateArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_todos.\n     * @param {todo_list_todosCreateManyArgs} args - Arguments to create many Todo_list_todos.\n     * @example\n     * // Create many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_todosCreateManyArgs>(args?: SelectSubset<T, todo_list_todosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_todos and returns the data saved in the database.\n     * @param {todo_list_todosCreateManyAndReturnArgs} args - Arguments to create many Todo_list_todos.\n     * @example\n     * // Create many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_todos and only return the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_todosCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_todosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_todos.\n     * @param {todo_list_todosDeleteArgs} args - Arguments to delete one Todo_list_todos.\n     * @example\n     * // Delete one Todo_list_todos\n     * const Todo_list_todos = await prisma.todo_list_todos.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_todos\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_todosDeleteArgs>(args: SelectSubset<T, todo_list_todosDeleteArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_todos.\n     * @param {todo_list_todosUpdateArgs} args - Arguments to update one Todo_list_todos.\n     * @example\n     * // Update one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_todosUpdateArgs>(args: SelectSubset<T, todo_list_todosUpdateArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_todos.\n     * @param {todo_list_todosDeleteManyArgs} args - Arguments to filter Todo_list_todos to delete.\n     * @example\n     * // Delete a few Todo_list_todos\n     * const { count } = await prisma.todo_list_todos.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_todosDeleteManyArgs>(args?: SelectSubset<T, todo_list_todosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_todosUpdateManyArgs>(args: SelectSubset<T, todo_list_todosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_todos and returns the data updated in the database.\n     * @param {todo_list_todosUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_todos.\n     * @example\n     * // Update many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_todos and only return the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_todosUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_todosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_todos.\n     * @param {todo_list_todosUpsertArgs} args - Arguments to update or create a Todo_list_todos.\n     * @example\n     * // Update or create a Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_todos\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_todos we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_todosUpsertArgs>(args: SelectSubset<T, todo_list_todosUpsertArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosCountArgs} args - Arguments to filter Todo_list_todos to count.\n     * @example\n     * // Count the number of Todo_list_todos\n     * const count = await prisma.todo_list_todos.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_todos we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_todosCountArgs>(\n      args?: Subset<T, todo_list_todosCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_todosCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_todosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_todosAggregateArgs>(args: Subset<T, Todo_list_todosAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_todosAggregateType<T>>\n\n    /**\n     * Group by Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_todosGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_todosGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_todosGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_todosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_todosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_todos model\n   */\n  readonly fields: todo_list_todosFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_todos.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_todosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends todo_list_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_usersDefaultArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    todo_list_audit_logs<T extends todo_list_todos$todo_list_audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_todos$todo_list_audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_todos model\n   */\n  interface todo_list_todosFieldRefs {\n    readonly id: FieldRef<\"todo_list_todos\", 'String'>\n    readonly todo_list_user_id: FieldRef<\"todo_list_todos\", 'String'>\n    readonly content: FieldRef<\"todo_list_todos\", 'String'>\n    readonly due_date: FieldRef<\"todo_list_todos\", 'DateTime'>\n    readonly completed: FieldRef<\"todo_list_todos\", 'Boolean'>\n    readonly completed_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n    readonly created_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_todos findUnique\n   */\n  export type todo_list_todosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos findUniqueOrThrow\n   */\n  export type todo_list_todosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos findFirst\n   */\n  export type todo_list_todosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_todos.\n     */\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos findFirstOrThrow\n   */\n  export type todo_list_todosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_todos.\n     */\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos findMany\n   */\n  export type todo_list_todosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos create\n   */\n  export type todo_list_todosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_todos.\n     */\n    data: XOR<todo_list_todosCreateInput, todo_list_todosUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_todos createMany\n   */\n  export type todo_list_todosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_todos.\n     */\n    data: todo_list_todosCreateManyInput | todo_list_todosCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_todos createManyAndReturn\n   */\n  export type todo_list_todosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_todos.\n     */\n    data: todo_list_todosCreateManyInput | todo_list_todosCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_todos update\n   */\n  export type todo_list_todosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateInput, todo_list_todosUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_todos to update.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos updateMany\n   */\n  export type todo_list_todosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_todos to update\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_todos updateManyAndReturn\n   */\n  export type todo_list_todosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_todos to update\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_todos upsert\n   */\n  export type todo_list_todosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_todos to update in case it exists.\n     */\n    where: todo_list_todosWhereUniqueInput\n    /**\n     * In case the todo_list_todos found by the `where` argument doesn't exist, create a new todo_list_todos with this data.\n     */\n    create: XOR<todo_list_todosCreateInput, todo_list_todosUncheckedCreateInput>\n    /**\n     * In case the todo_list_todos was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_todosUpdateInput, todo_list_todosUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_todos delete\n   */\n  export type todo_list_todosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_todos to delete.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos deleteMany\n   */\n  export type todo_list_todosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_todos to delete\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_todos.todo_list_audit_logs\n   */\n  export type todo_list_todos$todo_list_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    where?: todo_list_audit_logsWhereInput\n    orderBy?: todo_list_audit_logsOrderByWithRelationInput | todo_list_audit_logsOrderByWithRelationInput[]\n    cursor?: todo_list_audit_logsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_list_audit_logsScalarFieldEnum | Todo_list_audit_logsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos without action\n   */\n  export type todo_list_todosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_list_audit_logs\n   */\n\n  export type AggregateTodo_list_audit_logs = {\n    _count: Todo_list_audit_logsCountAggregateOutputType | null\n    _min: Todo_list_audit_logsMinAggregateOutputType | null\n    _max: Todo_list_audit_logsMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_audit_logsMinAggregateOutputType = {\n    id: string | null\n    todo_list_admin_id: string | null\n    todo_list_user_id: string | null\n    todo_list_todo_id: string | null\n    action: string | null\n    rationale: string | null\n    created_at: Date | null\n  }\n\n  export type Todo_list_audit_logsMaxAggregateOutputType = {\n    id: string | null\n    todo_list_admin_id: string | null\n    todo_list_user_id: string | null\n    todo_list_todo_id: string | null\n    action: string | null\n    rationale: string | null\n    created_at: Date | null\n  }\n\n  export type Todo_list_audit_logsCountAggregateOutputType = {\n    id: number\n    todo_list_admin_id: number\n    todo_list_user_id: number\n    todo_list_todo_id: number\n    action: number\n    rationale: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_audit_logsMinAggregateInputType = {\n    id?: true\n    todo_list_admin_id?: true\n    todo_list_user_id?: true\n    todo_list_todo_id?: true\n    action?: true\n    rationale?: true\n    created_at?: true\n  }\n\n  export type Todo_list_audit_logsMaxAggregateInputType = {\n    id?: true\n    todo_list_admin_id?: true\n    todo_list_user_id?: true\n    todo_list_todo_id?: true\n    action?: true\n    rationale?: true\n    created_at?: true\n  }\n\n  export type Todo_list_audit_logsCountAggregateInputType = {\n    id?: true\n    todo_list_admin_id?: true\n    todo_list_user_id?: true\n    todo_list_todo_id?: true\n    action?: true\n    rationale?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_audit_logs to aggregate.\n     */\n    where?: todo_list_audit_logsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_audit_logs to fetch.\n     */\n    orderBy?: todo_list_audit_logsOrderByWithRelationInput | todo_list_audit_logsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_audit_logsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_audit_logs from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_audit_logs.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_audit_logs\n    **/\n    _count?: true | Todo_list_audit_logsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_audit_logsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_audit_logsMaxAggregateInputType\n  }\n\n  export type GetTodo_list_audit_logsAggregateType<T extends Todo_list_audit_logsAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_audit_logs]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_audit_logs[P]>\n      : GetScalarType<T[P], AggregateTodo_list_audit_logs[P]>\n  }\n\n\n\n\n  export type todo_list_audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_audit_logsWhereInput\n    orderBy?: todo_list_audit_logsOrderByWithAggregationInput | todo_list_audit_logsOrderByWithAggregationInput[]\n    by: Todo_list_audit_logsScalarFieldEnum[] | Todo_list_audit_logsScalarFieldEnum\n    having?: todo_list_audit_logsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_audit_logsCountAggregateInputType | true\n    _min?: Todo_list_audit_logsMinAggregateInputType\n    _max?: Todo_list_audit_logsMaxAggregateInputType\n  }\n\n  export type Todo_list_audit_logsGroupByOutputType = {\n    id: string\n    todo_list_admin_id: string\n    todo_list_user_id: string\n    todo_list_todo_id: string\n    action: string\n    rationale: string | null\n    created_at: Date\n    _count: Todo_list_audit_logsCountAggregateOutputType | null\n    _min: Todo_list_audit_logsMinAggregateOutputType | null\n    _max: Todo_list_audit_logsMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_audit_logsGroupByPayload<T extends todo_list_audit_logsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_audit_logsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_audit_logsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_audit_logsGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_audit_logsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_admin_id?: boolean\n    todo_list_user_id?: boolean\n    todo_list_todo_id?: boolean\n    action?: boolean\n    rationale?: boolean\n    created_at?: boolean\n    admin?: boolean | todo_list_adminsDefaultArgs<ExtArgs>\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n    todo?: boolean | todo_list_todosDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_audit_logs\"]>\n\n  export type todo_list_audit_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_admin_id?: boolean\n    todo_list_user_id?: boolean\n    todo_list_todo_id?: boolean\n    action?: boolean\n    rationale?: boolean\n    created_at?: boolean\n    admin?: boolean | todo_list_adminsDefaultArgs<ExtArgs>\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n    todo?: boolean | todo_list_todosDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_audit_logs\"]>\n\n  export type todo_list_audit_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_admin_id?: boolean\n    todo_list_user_id?: boolean\n    todo_list_todo_id?: boolean\n    action?: boolean\n    rationale?: boolean\n    created_at?: boolean\n    admin?: boolean | todo_list_adminsDefaultArgs<ExtArgs>\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n    todo?: boolean | todo_list_todosDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_audit_logs\"]>\n\n  export type todo_list_audit_logsSelectScalar = {\n    id?: boolean\n    todo_list_admin_id?: boolean\n    todo_list_user_id?: boolean\n    todo_list_todo_id?: boolean\n    action?: boolean\n    rationale?: boolean\n    created_at?: boolean\n  }\n\n  export type todo_list_audit_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"todo_list_admin_id\" | \"todo_list_user_id\" | \"todo_list_todo_id\" | \"action\" | \"rationale\" | \"created_at\", ExtArgs[\"result\"][\"todo_list_audit_logs\"]>\n  export type todo_list_audit_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    admin?: boolean | todo_list_adminsDefaultArgs<ExtArgs>\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n    todo?: boolean | todo_list_todosDefaultArgs<ExtArgs>\n  }\n  export type todo_list_audit_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    admin?: boolean | todo_list_adminsDefaultArgs<ExtArgs>\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n    todo?: boolean | todo_list_todosDefaultArgs<ExtArgs>\n  }\n  export type todo_list_audit_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    admin?: boolean | todo_list_adminsDefaultArgs<ExtArgs>\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n    todo?: boolean | todo_list_todosDefaultArgs<ExtArgs>\n  }\n\n  export type $todo_list_audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_audit_logs\"\n    objects: {\n      admin: Prisma.$todo_list_adminsPayload<ExtArgs>\n      user: Prisma.$todo_list_usersPayload<ExtArgs>\n      todo: Prisma.$todo_list_todosPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Admin's {@link todo_list_admins.id} who performed the action.\n       */\n      todo_list_admin_id: string\n      /**\n       * Target user's {@link todo_list_users.id} whose todo was affected or\n       * accessed.\n       */\n      todo_list_user_id: string\n      /**\n       * Target todo's {@link todo_list_todos.id} affected by the admin action.\n       */\n      todo_list_todo_id: string\n      /**\n       * Admin action type on the todo. Enum: 'view', 'delete'.\n       */\n      action: string\n      /**\n       * Optional explanation or justification text for the admin action. Free\n       * text field; null allowed for non-sensitive actions.\n       */\n      rationale: string | null\n      /**\n       * Timestamp when this audit log entry was created.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"todo_list_audit_logs\"]>\n    composites: {}\n  }\n\n  type todo_list_audit_logsGetPayload<S extends boolean | null | undefined | todo_list_audit_logsDefaultArgs> = $Result.GetResult<Prisma.$todo_list_audit_logsPayload, S>\n\n  type todo_list_audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_audit_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_audit_logsCountAggregateInputType | true\n    }\n\n  export interface todo_list_audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_audit_logs'], meta: { name: 'todo_list_audit_logs' } }\n    /**\n     * Find zero or one Todo_list_audit_logs that matches the filter.\n     * @param {todo_list_audit_logsFindUniqueArgs} args - Arguments to find a Todo_list_audit_logs\n     * @example\n     * // Get one Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_audit_logsFindUniqueArgs>(args: SelectSubset<T, todo_list_audit_logsFindUniqueArgs<ExtArgs>>): Prisma__todo_list_audit_logsClient<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_audit_logs that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_audit_logs\n     * @example\n     * // Get one Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_audit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_audit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_audit_logsClient<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_audit_logs that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_audit_logsFindFirstArgs} args - Arguments to find a Todo_list_audit_logs\n     * @example\n     * // Get one Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_audit_logsFindFirstArgs>(args?: SelectSubset<T, todo_list_audit_logsFindFirstArgs<ExtArgs>>): Prisma__todo_list_audit_logsClient<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_audit_logs that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_audit_logsFindFirstOrThrowArgs} args - Arguments to find a Todo_list_audit_logs\n     * @example\n     * // Get one Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_audit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_audit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_audit_logsClient<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_audit_logs that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_audit_logsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.findMany()\n     * \n     * // Get first 10 Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_audit_logsWithIdOnly = await prisma.todo_list_audit_logs.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_audit_logsFindManyArgs>(args?: SelectSubset<T, todo_list_audit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_audit_logs.\n     * @param {todo_list_audit_logsCreateArgs} args - Arguments to create a Todo_list_audit_logs.\n     * @example\n     * // Create one Todo_list_audit_logs\n     * const Todo_list_audit_logs = await prisma.todo_list_audit_logs.create({\n     *   data: {\n     *     // ... data to create a Todo_list_audit_logs\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_audit_logsCreateArgs>(args: SelectSubset<T, todo_list_audit_logsCreateArgs<ExtArgs>>): Prisma__todo_list_audit_logsClient<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_audit_logs.\n     * @param {todo_list_audit_logsCreateManyArgs} args - Arguments to create many Todo_list_audit_logs.\n     * @example\n     * // Create many Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_audit_logsCreateManyArgs>(args?: SelectSubset<T, todo_list_audit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_audit_logs and returns the data saved in the database.\n     * @param {todo_list_audit_logsCreateManyAndReturnArgs} args - Arguments to create many Todo_list_audit_logs.\n     * @example\n     * // Create many Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_audit_logs and only return the `id`\n     * const todo_list_audit_logsWithIdOnly = await prisma.todo_list_audit_logs.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_audit_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_audit_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_audit_logs.\n     * @param {todo_list_audit_logsDeleteArgs} args - Arguments to delete one Todo_list_audit_logs.\n     * @example\n     * // Delete one Todo_list_audit_logs\n     * const Todo_list_audit_logs = await prisma.todo_list_audit_logs.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_audit_logs\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_audit_logsDeleteArgs>(args: SelectSubset<T, todo_list_audit_logsDeleteArgs<ExtArgs>>): Prisma__todo_list_audit_logsClient<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_audit_logs.\n     * @param {todo_list_audit_logsUpdateArgs} args - Arguments to update one Todo_list_audit_logs.\n     * @example\n     * // Update one Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_audit_logsUpdateArgs>(args: SelectSubset<T, todo_list_audit_logsUpdateArgs<ExtArgs>>): Prisma__todo_list_audit_logsClient<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_audit_logs.\n     * @param {todo_list_audit_logsDeleteManyArgs} args - Arguments to filter Todo_list_audit_logs to delete.\n     * @example\n     * // Delete a few Todo_list_audit_logs\n     * const { count } = await prisma.todo_list_audit_logs.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_audit_logsDeleteManyArgs>(args?: SelectSubset<T, todo_list_audit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_audit_logs.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_audit_logsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_audit_logsUpdateManyArgs>(args: SelectSubset<T, todo_list_audit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_audit_logs and returns the data updated in the database.\n     * @param {todo_list_audit_logsUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_audit_logs.\n     * @example\n     * // Update many Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_audit_logs and only return the `id`\n     * const todo_list_audit_logsWithIdOnly = await prisma.todo_list_audit_logs.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_audit_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_audit_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_audit_logs.\n     * @param {todo_list_audit_logsUpsertArgs} args - Arguments to update or create a Todo_list_audit_logs.\n     * @example\n     * // Update or create a Todo_list_audit_logs\n     * const todo_list_audit_logs = await prisma.todo_list_audit_logs.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_audit_logs\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_audit_logs we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_audit_logsUpsertArgs>(args: SelectSubset<T, todo_list_audit_logsUpsertArgs<ExtArgs>>): Prisma__todo_list_audit_logsClient<$Result.GetResult<Prisma.$todo_list_audit_logsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_audit_logs.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_audit_logsCountArgs} args - Arguments to filter Todo_list_audit_logs to count.\n     * @example\n     * // Count the number of Todo_list_audit_logs\n     * const count = await prisma.todo_list_audit_logs.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_audit_logs we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_audit_logsCountArgs>(\n      args?: Subset<T, todo_list_audit_logsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_audit_logsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_audit_logs.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_audit_logsAggregateArgs>(args: Subset<T, Todo_list_audit_logsAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_audit_logsAggregateType<T>>\n\n    /**\n     * Group by Todo_list_audit_logs.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_audit_logsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_audit_logsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_audit_logsGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_audit_logsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_audit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_audit_logs model\n   */\n  readonly fields: todo_list_audit_logsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_audit_logs.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    admin<T extends todo_list_adminsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_adminsDefaultArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    user<T extends todo_list_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_usersDefaultArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    todo<T extends todo_list_todosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_todosDefaultArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_audit_logs model\n   */\n  interface todo_list_audit_logsFieldRefs {\n    readonly id: FieldRef<\"todo_list_audit_logs\", 'String'>\n    readonly todo_list_admin_id: FieldRef<\"todo_list_audit_logs\", 'String'>\n    readonly todo_list_user_id: FieldRef<\"todo_list_audit_logs\", 'String'>\n    readonly todo_list_todo_id: FieldRef<\"todo_list_audit_logs\", 'String'>\n    readonly action: FieldRef<\"todo_list_audit_logs\", 'String'>\n    readonly rationale: FieldRef<\"todo_list_audit_logs\", 'String'>\n    readonly created_at: FieldRef<\"todo_list_audit_logs\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_audit_logs findUnique\n   */\n  export type todo_list_audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_audit_logs to fetch.\n     */\n    where: todo_list_audit_logsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_audit_logs findUniqueOrThrow\n   */\n  export type todo_list_audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_audit_logs to fetch.\n     */\n    where: todo_list_audit_logsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_audit_logs findFirst\n   */\n  export type todo_list_audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_audit_logs to fetch.\n     */\n    where?: todo_list_audit_logsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_audit_logs to fetch.\n     */\n    orderBy?: todo_list_audit_logsOrderByWithRelationInput | todo_list_audit_logsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_audit_logs.\n     */\n    cursor?: todo_list_audit_logsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_audit_logs from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_audit_logs.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_audit_logs.\n     */\n    distinct?: Todo_list_audit_logsScalarFieldEnum | Todo_list_audit_logsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_audit_logs findFirstOrThrow\n   */\n  export type todo_list_audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_audit_logs to fetch.\n     */\n    where?: todo_list_audit_logsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_audit_logs to fetch.\n     */\n    orderBy?: todo_list_audit_logsOrderByWithRelationInput | todo_list_audit_logsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_audit_logs.\n     */\n    cursor?: todo_list_audit_logsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_audit_logs from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_audit_logs.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_audit_logs.\n     */\n    distinct?: Todo_list_audit_logsScalarFieldEnum | Todo_list_audit_logsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_audit_logs findMany\n   */\n  export type todo_list_audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_audit_logs to fetch.\n     */\n    where?: todo_list_audit_logsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_audit_logs to fetch.\n     */\n    orderBy?: todo_list_audit_logsOrderByWithRelationInput | todo_list_audit_logsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_audit_logs.\n     */\n    cursor?: todo_list_audit_logsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_audit_logs from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_audit_logs.\n     */\n    skip?: number\n    distinct?: Todo_list_audit_logsScalarFieldEnum | Todo_list_audit_logsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_audit_logs create\n   */\n  export type todo_list_audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_audit_logs.\n     */\n    data: XOR<todo_list_audit_logsCreateInput, todo_list_audit_logsUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_audit_logs createMany\n   */\n  export type todo_list_audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_audit_logs.\n     */\n    data: todo_list_audit_logsCreateManyInput | todo_list_audit_logsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_audit_logs createManyAndReturn\n   */\n  export type todo_list_audit_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_audit_logs.\n     */\n    data: todo_list_audit_logsCreateManyInput | todo_list_audit_logsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_audit_logs update\n   */\n  export type todo_list_audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_audit_logs.\n     */\n    data: XOR<todo_list_audit_logsUpdateInput, todo_list_audit_logsUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_audit_logs to update.\n     */\n    where: todo_list_audit_logsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_audit_logs updateMany\n   */\n  export type todo_list_audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_audit_logs.\n     */\n    data: XOR<todo_list_audit_logsUpdateManyMutationInput, todo_list_audit_logsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_audit_logs to update\n     */\n    where?: todo_list_audit_logsWhereInput\n    /**\n     * Limit how many todo_list_audit_logs to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_audit_logs updateManyAndReturn\n   */\n  export type todo_list_audit_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_audit_logs.\n     */\n    data: XOR<todo_list_audit_logsUpdateManyMutationInput, todo_list_audit_logsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_audit_logs to update\n     */\n    where?: todo_list_audit_logsWhereInput\n    /**\n     * Limit how many todo_list_audit_logs to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_audit_logs upsert\n   */\n  export type todo_list_audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_audit_logs to update in case it exists.\n     */\n    where: todo_list_audit_logsWhereUniqueInput\n    /**\n     * In case the todo_list_audit_logs found by the `where` argument doesn't exist, create a new todo_list_audit_logs with this data.\n     */\n    create: XOR<todo_list_audit_logsCreateInput, todo_list_audit_logsUncheckedCreateInput>\n    /**\n     * In case the todo_list_audit_logs was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_audit_logsUpdateInput, todo_list_audit_logsUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_audit_logs delete\n   */\n  export type todo_list_audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_audit_logs to delete.\n     */\n    where: todo_list_audit_logsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_audit_logs deleteMany\n   */\n  export type todo_list_audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_audit_logs to delete\n     */\n    where?: todo_list_audit_logsWhereInput\n    /**\n     * Limit how many todo_list_audit_logs to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_audit_logs without action\n   */\n  export type todo_list_audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_audit_logs\n     */\n    select?: todo_list_audit_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_audit_logs\n     */\n    omit?: todo_list_audit_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_audit_logsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Todo_list_usersScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    name: 'name',\n    avatar_uri: 'avatar_uri',\n    status: 'status',\n    last_login_at: 'last_login_at',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Todo_list_usersScalarFieldEnum = (typeof Todo_list_usersScalarFieldEnum)[keyof typeof Todo_list_usersScalarFieldEnum]\n\n\n  export const Todo_list_adminsScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    name: 'name',\n    avatar_uri: 'avatar_uri',\n    status: 'status',\n    privilege_level: 'privilege_level',\n    last_admin_action_at: 'last_admin_action_at',\n    last_login_at: 'last_login_at',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Todo_list_adminsScalarFieldEnum = (typeof Todo_list_adminsScalarFieldEnum)[keyof typeof Todo_list_adminsScalarFieldEnum]\n\n\n  export const Todo_list_todosScalarFieldEnum: {\n    id: 'id',\n    todo_list_user_id: 'todo_list_user_id',\n    content: 'content',\n    due_date: 'due_date',\n    completed: 'completed',\n    completed_at: 'completed_at',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Todo_list_todosScalarFieldEnum = (typeof Todo_list_todosScalarFieldEnum)[keyof typeof Todo_list_todosScalarFieldEnum]\n\n\n  export const Todo_list_audit_logsScalarFieldEnum: {\n    id: 'id',\n    todo_list_admin_id: 'todo_list_admin_id',\n    todo_list_user_id: 'todo_list_user_id',\n    todo_list_todo_id: 'todo_list_todo_id',\n    action: 'action',\n    rationale: 'rationale',\n    created_at: 'created_at'\n  };\n\n  export type Todo_list_audit_logsScalarFieldEnum = (typeof Todo_list_audit_logsScalarFieldEnum)[keyof typeof Todo_list_audit_logsScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Boolean'\n   */\n  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type todo_list_usersWhereInput = {\n    AND?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    OR?: todo_list_usersWhereInput[]\n    NOT?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    id?: UuidFilter<\"todo_list_users\"> | string\n    email?: StringFilter<\"todo_list_users\"> | string\n    password_hash?: StringFilter<\"todo_list_users\"> | string\n    name?: StringNullableFilter<\"todo_list_users\"> | string | null\n    avatar_uri?: StringNullableFilter<\"todo_list_users\"> | string | null\n    status?: StringFilter<\"todo_list_users\"> | string\n    last_login_at?: DateTimeNullableFilter<\"todo_list_users\"> | Date | string | null\n    created_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_list_users\"> | Date | string | null\n    todo_list_todos?: Todo_list_todosListRelationFilter\n    todo_list_audit_logs?: Todo_list_audit_logsListRelationFilter\n  }\n\n  export type todo_list_usersOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrderInput | SortOrder\n    avatar_uri?: SortOrderInput | SortOrder\n    status?: SortOrder\n    last_login_at?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    todo_list_todos?: todo_list_todosOrderByRelationAggregateInput\n    todo_list_audit_logs?: todo_list_audit_logsOrderByRelationAggregateInput\n  }\n\n  export type todo_list_usersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    OR?: todo_list_usersWhereInput[]\n    NOT?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    password_hash?: StringFilter<\"todo_list_users\"> | string\n    name?: StringNullableFilter<\"todo_list_users\"> | string | null\n    avatar_uri?: StringNullableFilter<\"todo_list_users\"> | string | null\n    status?: StringFilter<\"todo_list_users\"> | string\n    last_login_at?: DateTimeNullableFilter<\"todo_list_users\"> | Date | string | null\n    created_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_list_users\"> | Date | string | null\n    todo_list_todos?: Todo_list_todosListRelationFilter\n    todo_list_audit_logs?: Todo_list_audit_logsListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type todo_list_usersOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrderInput | SortOrder\n    avatar_uri?: SortOrderInput | SortOrder\n    status?: SortOrder\n    last_login_at?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: todo_list_usersCountOrderByAggregateInput\n    _max?: todo_list_usersMaxOrderByAggregateInput\n    _min?: todo_list_usersMinOrderByAggregateInput\n  }\n\n  export type todo_list_usersScalarWhereWithAggregatesInput = {\n    AND?: todo_list_usersScalarWhereWithAggregatesInput | todo_list_usersScalarWhereWithAggregatesInput[]\n    OR?: todo_list_usersScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_usersScalarWhereWithAggregatesInput | todo_list_usersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_users\"> | string\n    email?: StringWithAggregatesFilter<\"todo_list_users\"> | string\n    password_hash?: StringWithAggregatesFilter<\"todo_list_users\"> | string\n    name?: StringNullableWithAggregatesFilter<\"todo_list_users\"> | string | null\n    avatar_uri?: StringNullableWithAggregatesFilter<\"todo_list_users\"> | string | null\n    status?: StringWithAggregatesFilter<\"todo_list_users\"> | string\n    last_login_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_users\"> | Date | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_users\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_users\"> | Date | string | null\n  }\n\n  export type todo_list_adminsWhereInput = {\n    AND?: todo_list_adminsWhereInput | todo_list_adminsWhereInput[]\n    OR?: todo_list_adminsWhereInput[]\n    NOT?: todo_list_adminsWhereInput | todo_list_adminsWhereInput[]\n    id?: UuidFilter<\"todo_list_admins\"> | string\n    email?: StringFilter<\"todo_list_admins\"> | string\n    password_hash?: StringFilter<\"todo_list_admins\"> | string\n    name?: StringNullableFilter<\"todo_list_admins\"> | string | null\n    avatar_uri?: StringNullableFilter<\"todo_list_admins\"> | string | null\n    status?: StringFilter<\"todo_list_admins\"> | string\n    privilege_level?: StringFilter<\"todo_list_admins\"> | string\n    last_admin_action_at?: DateTimeNullableFilter<\"todo_list_admins\"> | Date | string | null\n    last_login_at?: DateTimeNullableFilter<\"todo_list_admins\"> | Date | string | null\n    created_at?: DateTimeFilter<\"todo_list_admins\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_admins\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_list_admins\"> | Date | string | null\n    todo_list_audit_logs?: Todo_list_audit_logsListRelationFilter\n  }\n\n  export type todo_list_adminsOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrderInput | SortOrder\n    avatar_uri?: SortOrderInput | SortOrder\n    status?: SortOrder\n    privilege_level?: SortOrder\n    last_admin_action_at?: SortOrderInput | SortOrder\n    last_login_at?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    todo_list_audit_logs?: todo_list_audit_logsOrderByRelationAggregateInput\n  }\n\n  export type todo_list_adminsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: todo_list_adminsWhereInput | todo_list_adminsWhereInput[]\n    OR?: todo_list_adminsWhereInput[]\n    NOT?: todo_list_adminsWhereInput | todo_list_adminsWhereInput[]\n    password_hash?: StringFilter<\"todo_list_admins\"> | string\n    name?: StringNullableFilter<\"todo_list_admins\"> | string | null\n    avatar_uri?: StringNullableFilter<\"todo_list_admins\"> | string | null\n    status?: StringFilter<\"todo_list_admins\"> | string\n    privilege_level?: StringFilter<\"todo_list_admins\"> | string\n    last_admin_action_at?: DateTimeNullableFilter<\"todo_list_admins\"> | Date | string | null\n    last_login_at?: DateTimeNullableFilter<\"todo_list_admins\"> | Date | string | null\n    created_at?: DateTimeFilter<\"todo_list_admins\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_admins\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_list_admins\"> | Date | string | null\n    todo_list_audit_logs?: Todo_list_audit_logsListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type todo_list_adminsOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrderInput | SortOrder\n    avatar_uri?: SortOrderInput | SortOrder\n    status?: SortOrder\n    privilege_level?: SortOrder\n    last_admin_action_at?: SortOrderInput | SortOrder\n    last_login_at?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: todo_list_adminsCountOrderByAggregateInput\n    _max?: todo_list_adminsMaxOrderByAggregateInput\n    _min?: todo_list_adminsMinOrderByAggregateInput\n  }\n\n  export type todo_list_adminsScalarWhereWithAggregatesInput = {\n    AND?: todo_list_adminsScalarWhereWithAggregatesInput | todo_list_adminsScalarWhereWithAggregatesInput[]\n    OR?: todo_list_adminsScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_adminsScalarWhereWithAggregatesInput | todo_list_adminsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_admins\"> | string\n    email?: StringWithAggregatesFilter<\"todo_list_admins\"> | string\n    password_hash?: StringWithAggregatesFilter<\"todo_list_admins\"> | string\n    name?: StringNullableWithAggregatesFilter<\"todo_list_admins\"> | string | null\n    avatar_uri?: StringNullableWithAggregatesFilter<\"todo_list_admins\"> | string | null\n    status?: StringWithAggregatesFilter<\"todo_list_admins\"> | string\n    privilege_level?: StringWithAggregatesFilter<\"todo_list_admins\"> | string\n    last_admin_action_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_admins\"> | Date | string | null\n    last_login_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_admins\"> | Date | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_admins\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_admins\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_admins\"> | Date | string | null\n  }\n\n  export type todo_list_todosWhereInput = {\n    AND?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    OR?: todo_list_todosWhereInput[]\n    NOT?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    id?: UuidFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    content?: StringFilter<\"todo_list_todos\"> | string\n    due_date?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    user?: XOR<Todo_list_usersScalarRelationFilter, todo_list_usersWhereInput>\n    todo_list_audit_logs?: Todo_list_audit_logsListRelationFilter\n  }\n\n  export type todo_list_todosOrderByWithRelationInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    content?: SortOrder\n    due_date?: SortOrderInput | SortOrder\n    completed?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    user?: todo_list_usersOrderByWithRelationInput\n    todo_list_audit_logs?: todo_list_audit_logsOrderByRelationAggregateInput\n  }\n\n  export type todo_list_todosWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    todo_list_user_id_content?: todo_list_todosTodo_list_user_idContentCompoundUniqueInput\n    AND?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    OR?: todo_list_todosWhereInput[]\n    NOT?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    content?: StringFilter<\"todo_list_todos\"> | string\n    due_date?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    user?: XOR<Todo_list_usersScalarRelationFilter, todo_list_usersWhereInput>\n    todo_list_audit_logs?: Todo_list_audit_logsListRelationFilter\n  }, \"id\" | \"todo_list_user_id_content\">\n\n  export type todo_list_todosOrderByWithAggregationInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    content?: SortOrder\n    due_date?: SortOrderInput | SortOrder\n    completed?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: todo_list_todosCountOrderByAggregateInput\n    _max?: todo_list_todosMaxOrderByAggregateInput\n    _min?: todo_list_todosMinOrderByAggregateInput\n  }\n\n  export type todo_list_todosScalarWhereWithAggregatesInput = {\n    AND?: todo_list_todosScalarWhereWithAggregatesInput | todo_list_todosScalarWhereWithAggregatesInput[]\n    OR?: todo_list_todosScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_todosScalarWhereWithAggregatesInput | todo_list_todosScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidWithAggregatesFilter<\"todo_list_todos\"> | string\n    content?: StringWithAggregatesFilter<\"todo_list_todos\"> | string\n    due_date?: DateTimeNullableWithAggregatesFilter<\"todo_list_todos\"> | Date | string | null\n    completed?: BoolWithAggregatesFilter<\"todo_list_todos\"> | boolean\n    completed_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_todos\"> | Date | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_todos\"> | Date | string\n  }\n\n  export type todo_list_audit_logsWhereInput = {\n    AND?: todo_list_audit_logsWhereInput | todo_list_audit_logsWhereInput[]\n    OR?: todo_list_audit_logsWhereInput[]\n    NOT?: todo_list_audit_logsWhereInput | todo_list_audit_logsWhereInput[]\n    id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    todo_list_admin_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    todo_list_todo_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    action?: StringFilter<\"todo_list_audit_logs\"> | string\n    rationale?: StringNullableFilter<\"todo_list_audit_logs\"> | string | null\n    created_at?: DateTimeFilter<\"todo_list_audit_logs\"> | Date | string\n    admin?: XOR<Todo_list_adminsScalarRelationFilter, todo_list_adminsWhereInput>\n    user?: XOR<Todo_list_usersScalarRelationFilter, todo_list_usersWhereInput>\n    todo?: XOR<Todo_list_todosScalarRelationFilter, todo_list_todosWhereInput>\n  }\n\n  export type todo_list_audit_logsOrderByWithRelationInput = {\n    id?: SortOrder\n    todo_list_admin_id?: SortOrder\n    todo_list_user_id?: SortOrder\n    todo_list_todo_id?: SortOrder\n    action?: SortOrder\n    rationale?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    admin?: todo_list_adminsOrderByWithRelationInput\n    user?: todo_list_usersOrderByWithRelationInput\n    todo?: todo_list_todosOrderByWithRelationInput\n  }\n\n  export type todo_list_audit_logsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: todo_list_audit_logsWhereInput | todo_list_audit_logsWhereInput[]\n    OR?: todo_list_audit_logsWhereInput[]\n    NOT?: todo_list_audit_logsWhereInput | todo_list_audit_logsWhereInput[]\n    todo_list_admin_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    todo_list_todo_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    action?: StringFilter<\"todo_list_audit_logs\"> | string\n    rationale?: StringNullableFilter<\"todo_list_audit_logs\"> | string | null\n    created_at?: DateTimeFilter<\"todo_list_audit_logs\"> | Date | string\n    admin?: XOR<Todo_list_adminsScalarRelationFilter, todo_list_adminsWhereInput>\n    user?: XOR<Todo_list_usersScalarRelationFilter, todo_list_usersWhereInput>\n    todo?: XOR<Todo_list_todosScalarRelationFilter, todo_list_todosWhereInput>\n  }, \"id\">\n\n  export type todo_list_audit_logsOrderByWithAggregationInput = {\n    id?: SortOrder\n    todo_list_admin_id?: SortOrder\n    todo_list_user_id?: SortOrder\n    todo_list_todo_id?: SortOrder\n    action?: SortOrder\n    rationale?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    _count?: todo_list_audit_logsCountOrderByAggregateInput\n    _max?: todo_list_audit_logsMaxOrderByAggregateInput\n    _min?: todo_list_audit_logsMinOrderByAggregateInput\n  }\n\n  export type todo_list_audit_logsScalarWhereWithAggregatesInput = {\n    AND?: todo_list_audit_logsScalarWhereWithAggregatesInput | todo_list_audit_logsScalarWhereWithAggregatesInput[]\n    OR?: todo_list_audit_logsScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_audit_logsScalarWhereWithAggregatesInput | todo_list_audit_logsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_audit_logs\"> | string\n    todo_list_admin_id?: UuidWithAggregatesFilter<\"todo_list_audit_logs\"> | string\n    todo_list_user_id?: UuidWithAggregatesFilter<\"todo_list_audit_logs\"> | string\n    todo_list_todo_id?: UuidWithAggregatesFilter<\"todo_list_audit_logs\"> | string\n    action?: StringWithAggregatesFilter<\"todo_list_audit_logs\"> | string\n    rationale?: StringNullableWithAggregatesFilter<\"todo_list_audit_logs\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_audit_logs\"> | Date | string\n  }\n\n  export type todo_list_usersCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_todos?: todo_list_todosCreateNestedManyWithoutUserInput\n    todo_list_audit_logs?: todo_list_audit_logsCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_todos?: todo_list_todosUncheckedCreateNestedManyWithoutUserInput\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_todos?: todo_list_todosUpdateManyWithoutUserNestedInput\n    todo_list_audit_logs?: todo_list_audit_logsUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_usersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_todos?: todo_list_todosUncheckedUpdateManyWithoutUserNestedInput\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_usersCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_usersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_usersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_adminsCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    privilege_level: string\n    last_admin_action_at?: Date | string | null\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_audit_logs?: todo_list_audit_logsCreateNestedManyWithoutAdminInput\n  }\n\n  export type todo_list_adminsUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    privilege_level: string\n    last_admin_action_at?: Date | string | null\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedCreateNestedManyWithoutAdminInput\n  }\n\n  export type todo_list_adminsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    privilege_level?: StringFieldUpdateOperationsInput | string\n    last_admin_action_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_audit_logs?: todo_list_audit_logsUpdateManyWithoutAdminNestedInput\n  }\n\n  export type todo_list_adminsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    privilege_level?: StringFieldUpdateOperationsInput | string\n    last_admin_action_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedUpdateManyWithoutAdminNestedInput\n  }\n\n  export type todo_list_adminsCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    privilege_level: string\n    last_admin_action_at?: Date | string | null\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_adminsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    privilege_level?: StringFieldUpdateOperationsInput | string\n    last_admin_action_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_adminsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    privilege_level?: StringFieldUpdateOperationsInput | string\n    last_admin_action_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosCreateInput = {\n    id: string\n    content: string\n    due_date?: Date | string | null\n    completed: boolean\n    completed_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    user: todo_list_usersCreateNestedOneWithoutTodo_list_todosInput\n    todo_list_audit_logs?: todo_list_audit_logsCreateNestedManyWithoutTodoInput\n  }\n\n  export type todo_list_todosUncheckedCreateInput = {\n    id: string\n    todo_list_user_id: string\n    content: string\n    due_date?: Date | string | null\n    completed: boolean\n    completed_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedCreateNestedManyWithoutTodoInput\n  }\n\n  export type todo_list_todosUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: todo_list_usersUpdateOneRequiredWithoutTodo_list_todosNestedInput\n    todo_list_audit_logs?: todo_list_audit_logsUpdateManyWithoutTodoNestedInput\n  }\n\n  export type todo_list_todosUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedUpdateManyWithoutTodoNestedInput\n  }\n\n  export type todo_list_todosCreateManyInput = {\n    id: string\n    todo_list_user_id: string\n    content: string\n    due_date?: Date | string | null\n    completed: boolean\n    completed_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_todosUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_todosUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsCreateInput = {\n    id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n    admin: todo_list_adminsCreateNestedOneWithoutTodo_list_audit_logsInput\n    user: todo_list_usersCreateNestedOneWithoutTodo_list_audit_logsInput\n    todo: todo_list_todosCreateNestedOneWithoutTodo_list_audit_logsInput\n  }\n\n  export type todo_list_audit_logsUncheckedCreateInput = {\n    id: string\n    todo_list_admin_id: string\n    todo_list_user_id: string\n    todo_list_todo_id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_list_audit_logsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    admin?: todo_list_adminsUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n    user?: todo_list_usersUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n    todo?: todo_list_todosUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_admin_id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    todo_list_todo_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsCreateManyInput = {\n    id: string\n    todo_list_admin_id: string\n    todo_list_user_id: string\n    todo_list_todo_id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_list_audit_logsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_admin_id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    todo_list_todo_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type Todo_list_todosListRelationFilter = {\n    every?: todo_list_todosWhereInput\n    some?: todo_list_todosWhereInput\n    none?: todo_list_todosWhereInput\n  }\n\n  export type Todo_list_audit_logsListRelationFilter = {\n    every?: todo_list_audit_logsWhereInput\n    some?: todo_list_audit_logsWhereInput\n    none?: todo_list_audit_logsWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type todo_list_todosOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type todo_list_audit_logsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type todo_list_usersCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    avatar_uri?: SortOrder\n    status?: SortOrder\n    last_login_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_list_usersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    avatar_uri?: SortOrder\n    status?: SortOrder\n    last_login_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_list_usersMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    avatar_uri?: SortOrder\n    status?: SortOrder\n    last_login_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type todo_list_adminsCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    avatar_uri?: SortOrder\n    status?: SortOrder\n    privilege_level?: SortOrder\n    last_admin_action_at?: SortOrder\n    last_login_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_list_adminsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    avatar_uri?: SortOrder\n    status?: SortOrder\n    privilege_level?: SortOrder\n    last_admin_action_at?: SortOrder\n    last_login_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_list_adminsMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    avatar_uri?: SortOrder\n    status?: SortOrder\n    privilege_level?: SortOrder\n    last_admin_action_at?: SortOrder\n    last_login_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type BoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type Todo_list_usersScalarRelationFilter = {\n    is?: todo_list_usersWhereInput\n    isNot?: todo_list_usersWhereInput\n  }\n\n  export type todo_list_todosTodo_list_user_idContentCompoundUniqueInput = {\n    todo_list_user_id: string\n    content: string\n  }\n\n  export type todo_list_todosCountOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    content?: SortOrder\n    due_date?: SortOrder\n    completed?: SortOrder\n    completed_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_todosMaxOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    content?: SortOrder\n    due_date?: SortOrder\n    completed?: SortOrder\n    completed_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_todosMinOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    content?: SortOrder\n    due_date?: SortOrder\n    completed?: SortOrder\n    completed_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type BoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type Todo_list_adminsScalarRelationFilter = {\n    is?: todo_list_adminsWhereInput\n    isNot?: todo_list_adminsWhereInput\n  }\n\n  export type Todo_list_todosScalarRelationFilter = {\n    is?: todo_list_todosWhereInput\n    isNot?: todo_list_todosWhereInput\n  }\n\n  export type todo_list_audit_logsCountOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_admin_id?: SortOrder\n    todo_list_user_id?: SortOrder\n    todo_list_todo_id?: SortOrder\n    action?: SortOrder\n    rationale?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type todo_list_audit_logsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_admin_id?: SortOrder\n    todo_list_user_id?: SortOrder\n    todo_list_todo_id?: SortOrder\n    action?: SortOrder\n    rationale?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type todo_list_audit_logsMinOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_admin_id?: SortOrder\n    todo_list_user_id?: SortOrder\n    todo_list_todo_id?: SortOrder\n    action?: SortOrder\n    rationale?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type todo_list_todosCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n  }\n\n  export type todo_list_audit_logsCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutUserInput, todo_list_audit_logsUncheckedCreateWithoutUserInput> | todo_list_audit_logsCreateWithoutUserInput[] | todo_list_audit_logsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutUserInput | todo_list_audit_logsCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_audit_logsCreateManyUserInputEnvelope\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n  }\n\n  export type todo_list_todosUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n  }\n\n  export type todo_list_audit_logsUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutUserInput, todo_list_audit_logsUncheckedCreateWithoutUserInput> | todo_list_audit_logsCreateWithoutUserInput[] | todo_list_audit_logsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutUserInput | todo_list_audit_logsCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_audit_logsCreateManyUserInputEnvelope\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type todo_list_todosUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_todosUpsertWithWhereUniqueWithoutUserInput | todo_list_todosUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    set?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    disconnect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    delete?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    update?: todo_list_todosUpdateWithWhereUniqueWithoutUserInput | todo_list_todosUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_todosUpdateManyWithWhereWithoutUserInput | todo_list_todosUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n  }\n\n  export type todo_list_audit_logsUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutUserInput, todo_list_audit_logsUncheckedCreateWithoutUserInput> | todo_list_audit_logsCreateWithoutUserInput[] | todo_list_audit_logsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutUserInput | todo_list_audit_logsCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_audit_logsUpsertWithWhereUniqueWithoutUserInput | todo_list_audit_logsUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_audit_logsCreateManyUserInputEnvelope\n    set?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    disconnect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    delete?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    update?: todo_list_audit_logsUpdateWithWhereUniqueWithoutUserInput | todo_list_audit_logsUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_audit_logsUpdateManyWithWhereWithoutUserInput | todo_list_audit_logsUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_audit_logsScalarWhereInput | todo_list_audit_logsScalarWhereInput[]\n  }\n\n  export type todo_list_todosUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_todosUpsertWithWhereUniqueWithoutUserInput | todo_list_todosUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    set?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    disconnect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    delete?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    update?: todo_list_todosUpdateWithWhereUniqueWithoutUserInput | todo_list_todosUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_todosUpdateManyWithWhereWithoutUserInput | todo_list_todosUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutUserInput, todo_list_audit_logsUncheckedCreateWithoutUserInput> | todo_list_audit_logsCreateWithoutUserInput[] | todo_list_audit_logsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutUserInput | todo_list_audit_logsCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_audit_logsUpsertWithWhereUniqueWithoutUserInput | todo_list_audit_logsUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_audit_logsCreateManyUserInputEnvelope\n    set?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    disconnect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    delete?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    update?: todo_list_audit_logsUpdateWithWhereUniqueWithoutUserInput | todo_list_audit_logsUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_audit_logsUpdateManyWithWhereWithoutUserInput | todo_list_audit_logsUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_audit_logsScalarWhereInput | todo_list_audit_logsScalarWhereInput[]\n  }\n\n  export type todo_list_audit_logsCreateNestedManyWithoutAdminInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutAdminInput, todo_list_audit_logsUncheckedCreateWithoutAdminInput> | todo_list_audit_logsCreateWithoutAdminInput[] | todo_list_audit_logsUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutAdminInput | todo_list_audit_logsCreateOrConnectWithoutAdminInput[]\n    createMany?: todo_list_audit_logsCreateManyAdminInputEnvelope\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n  }\n\n  export type todo_list_audit_logsUncheckedCreateNestedManyWithoutAdminInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutAdminInput, todo_list_audit_logsUncheckedCreateWithoutAdminInput> | todo_list_audit_logsCreateWithoutAdminInput[] | todo_list_audit_logsUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutAdminInput | todo_list_audit_logsCreateOrConnectWithoutAdminInput[]\n    createMany?: todo_list_audit_logsCreateManyAdminInputEnvelope\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n  }\n\n  export type todo_list_audit_logsUpdateManyWithoutAdminNestedInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutAdminInput, todo_list_audit_logsUncheckedCreateWithoutAdminInput> | todo_list_audit_logsCreateWithoutAdminInput[] | todo_list_audit_logsUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutAdminInput | todo_list_audit_logsCreateOrConnectWithoutAdminInput[]\n    upsert?: todo_list_audit_logsUpsertWithWhereUniqueWithoutAdminInput | todo_list_audit_logsUpsertWithWhereUniqueWithoutAdminInput[]\n    createMany?: todo_list_audit_logsCreateManyAdminInputEnvelope\n    set?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    disconnect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    delete?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    update?: todo_list_audit_logsUpdateWithWhereUniqueWithoutAdminInput | todo_list_audit_logsUpdateWithWhereUniqueWithoutAdminInput[]\n    updateMany?: todo_list_audit_logsUpdateManyWithWhereWithoutAdminInput | todo_list_audit_logsUpdateManyWithWhereWithoutAdminInput[]\n    deleteMany?: todo_list_audit_logsScalarWhereInput | todo_list_audit_logsScalarWhereInput[]\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateManyWithoutAdminNestedInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutAdminInput, todo_list_audit_logsUncheckedCreateWithoutAdminInput> | todo_list_audit_logsCreateWithoutAdminInput[] | todo_list_audit_logsUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutAdminInput | todo_list_audit_logsCreateOrConnectWithoutAdminInput[]\n    upsert?: todo_list_audit_logsUpsertWithWhereUniqueWithoutAdminInput | todo_list_audit_logsUpsertWithWhereUniqueWithoutAdminInput[]\n    createMany?: todo_list_audit_logsCreateManyAdminInputEnvelope\n    set?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    disconnect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    delete?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    update?: todo_list_audit_logsUpdateWithWhereUniqueWithoutAdminInput | todo_list_audit_logsUpdateWithWhereUniqueWithoutAdminInput[]\n    updateMany?: todo_list_audit_logsUpdateManyWithWhereWithoutAdminInput | todo_list_audit_logsUpdateManyWithWhereWithoutAdminInput[]\n    deleteMany?: todo_list_audit_logsScalarWhereInput | todo_list_audit_logsScalarWhereInput[]\n  }\n\n  export type todo_list_usersCreateNestedOneWithoutTodo_list_todosInput = {\n    create?: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    connectOrCreate?: todo_list_usersCreateOrConnectWithoutTodo_list_todosInput\n    connect?: todo_list_usersWhereUniqueInput\n  }\n\n  export type todo_list_audit_logsCreateNestedManyWithoutTodoInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutTodoInput, todo_list_audit_logsUncheckedCreateWithoutTodoInput> | todo_list_audit_logsCreateWithoutTodoInput[] | todo_list_audit_logsUncheckedCreateWithoutTodoInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutTodoInput | todo_list_audit_logsCreateOrConnectWithoutTodoInput[]\n    createMany?: todo_list_audit_logsCreateManyTodoInputEnvelope\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n  }\n\n  export type todo_list_audit_logsUncheckedCreateNestedManyWithoutTodoInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutTodoInput, todo_list_audit_logsUncheckedCreateWithoutTodoInput> | todo_list_audit_logsCreateWithoutTodoInput[] | todo_list_audit_logsUncheckedCreateWithoutTodoInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutTodoInput | todo_list_audit_logsCreateOrConnectWithoutTodoInput[]\n    createMany?: todo_list_audit_logsCreateManyTodoInputEnvelope\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n  }\n\n  export type BoolFieldUpdateOperationsInput = {\n    set?: boolean\n  }\n\n  export type todo_list_usersUpdateOneRequiredWithoutTodo_list_todosNestedInput = {\n    create?: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    connectOrCreate?: todo_list_usersCreateOrConnectWithoutTodo_list_todosInput\n    upsert?: todo_list_usersUpsertWithoutTodo_list_todosInput\n    connect?: todo_list_usersWhereUniqueInput\n    update?: XOR<XOR<todo_list_usersUpdateToOneWithWhereWithoutTodo_list_todosInput, todo_list_usersUpdateWithoutTodo_list_todosInput>, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n  }\n\n  export type todo_list_audit_logsUpdateManyWithoutTodoNestedInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutTodoInput, todo_list_audit_logsUncheckedCreateWithoutTodoInput> | todo_list_audit_logsCreateWithoutTodoInput[] | todo_list_audit_logsUncheckedCreateWithoutTodoInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutTodoInput | todo_list_audit_logsCreateOrConnectWithoutTodoInput[]\n    upsert?: todo_list_audit_logsUpsertWithWhereUniqueWithoutTodoInput | todo_list_audit_logsUpsertWithWhereUniqueWithoutTodoInput[]\n    createMany?: todo_list_audit_logsCreateManyTodoInputEnvelope\n    set?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    disconnect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    delete?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    update?: todo_list_audit_logsUpdateWithWhereUniqueWithoutTodoInput | todo_list_audit_logsUpdateWithWhereUniqueWithoutTodoInput[]\n    updateMany?: todo_list_audit_logsUpdateManyWithWhereWithoutTodoInput | todo_list_audit_logsUpdateManyWithWhereWithoutTodoInput[]\n    deleteMany?: todo_list_audit_logsScalarWhereInput | todo_list_audit_logsScalarWhereInput[]\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateManyWithoutTodoNestedInput = {\n    create?: XOR<todo_list_audit_logsCreateWithoutTodoInput, todo_list_audit_logsUncheckedCreateWithoutTodoInput> | todo_list_audit_logsCreateWithoutTodoInput[] | todo_list_audit_logsUncheckedCreateWithoutTodoInput[]\n    connectOrCreate?: todo_list_audit_logsCreateOrConnectWithoutTodoInput | todo_list_audit_logsCreateOrConnectWithoutTodoInput[]\n    upsert?: todo_list_audit_logsUpsertWithWhereUniqueWithoutTodoInput | todo_list_audit_logsUpsertWithWhereUniqueWithoutTodoInput[]\n    createMany?: todo_list_audit_logsCreateManyTodoInputEnvelope\n    set?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    disconnect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    delete?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    connect?: todo_list_audit_logsWhereUniqueInput | todo_list_audit_logsWhereUniqueInput[]\n    update?: todo_list_audit_logsUpdateWithWhereUniqueWithoutTodoInput | todo_list_audit_logsUpdateWithWhereUniqueWithoutTodoInput[]\n    updateMany?: todo_list_audit_logsUpdateManyWithWhereWithoutTodoInput | todo_list_audit_logsUpdateManyWithWhereWithoutTodoInput[]\n    deleteMany?: todo_list_audit_logsScalarWhereInput | todo_list_audit_logsScalarWhereInput[]\n  }\n\n  export type todo_list_adminsCreateNestedOneWithoutTodo_list_audit_logsInput = {\n    create?: XOR<todo_list_adminsCreateWithoutTodo_list_audit_logsInput, todo_list_adminsUncheckedCreateWithoutTodo_list_audit_logsInput>\n    connectOrCreate?: todo_list_adminsCreateOrConnectWithoutTodo_list_audit_logsInput\n    connect?: todo_list_adminsWhereUniqueInput\n  }\n\n  export type todo_list_usersCreateNestedOneWithoutTodo_list_audit_logsInput = {\n    create?: XOR<todo_list_usersCreateWithoutTodo_list_audit_logsInput, todo_list_usersUncheckedCreateWithoutTodo_list_audit_logsInput>\n    connectOrCreate?: todo_list_usersCreateOrConnectWithoutTodo_list_audit_logsInput\n    connect?: todo_list_usersWhereUniqueInput\n  }\n\n  export type todo_list_todosCreateNestedOneWithoutTodo_list_audit_logsInput = {\n    create?: XOR<todo_list_todosCreateWithoutTodo_list_audit_logsInput, todo_list_todosUncheckedCreateWithoutTodo_list_audit_logsInput>\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutTodo_list_audit_logsInput\n    connect?: todo_list_todosWhereUniqueInput\n  }\n\n  export type todo_list_adminsUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput = {\n    create?: XOR<todo_list_adminsCreateWithoutTodo_list_audit_logsInput, todo_list_adminsUncheckedCreateWithoutTodo_list_audit_logsInput>\n    connectOrCreate?: todo_list_adminsCreateOrConnectWithoutTodo_list_audit_logsInput\n    upsert?: todo_list_adminsUpsertWithoutTodo_list_audit_logsInput\n    connect?: todo_list_adminsWhereUniqueInput\n    update?: XOR<XOR<todo_list_adminsUpdateToOneWithWhereWithoutTodo_list_audit_logsInput, todo_list_adminsUpdateWithoutTodo_list_audit_logsInput>, todo_list_adminsUncheckedUpdateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type todo_list_usersUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput = {\n    create?: XOR<todo_list_usersCreateWithoutTodo_list_audit_logsInput, todo_list_usersUncheckedCreateWithoutTodo_list_audit_logsInput>\n    connectOrCreate?: todo_list_usersCreateOrConnectWithoutTodo_list_audit_logsInput\n    upsert?: todo_list_usersUpsertWithoutTodo_list_audit_logsInput\n    connect?: todo_list_usersWhereUniqueInput\n    update?: XOR<XOR<todo_list_usersUpdateToOneWithWhereWithoutTodo_list_audit_logsInput, todo_list_usersUpdateWithoutTodo_list_audit_logsInput>, todo_list_usersUncheckedUpdateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type todo_list_todosUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput = {\n    create?: XOR<todo_list_todosCreateWithoutTodo_list_audit_logsInput, todo_list_todosUncheckedCreateWithoutTodo_list_audit_logsInput>\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutTodo_list_audit_logsInput\n    upsert?: todo_list_todosUpsertWithoutTodo_list_audit_logsInput\n    connect?: todo_list_todosWhereUniqueInput\n    update?: XOR<XOR<todo_list_todosUpdateToOneWithWhereWithoutTodo_list_audit_logsInput, todo_list_todosUpdateWithoutTodo_list_audit_logsInput>, todo_list_todosUncheckedUpdateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedBoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type todo_list_todosCreateWithoutUserInput = {\n    id: string\n    content: string\n    due_date?: Date | string | null\n    completed: boolean\n    completed_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    todo_list_audit_logs?: todo_list_audit_logsCreateNestedManyWithoutTodoInput\n  }\n\n  export type todo_list_todosUncheckedCreateWithoutUserInput = {\n    id: string\n    content: string\n    due_date?: Date | string | null\n    completed: boolean\n    completed_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedCreateNestedManyWithoutTodoInput\n  }\n\n  export type todo_list_todosCreateOrConnectWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    create: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_todosCreateManyUserInputEnvelope = {\n    data: todo_list_todosCreateManyUserInput | todo_list_todosCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_list_audit_logsCreateWithoutUserInput = {\n    id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n    admin: todo_list_adminsCreateNestedOneWithoutTodo_list_audit_logsInput\n    todo: todo_list_todosCreateNestedOneWithoutTodo_list_audit_logsInput\n  }\n\n  export type todo_list_audit_logsUncheckedCreateWithoutUserInput = {\n    id: string\n    todo_list_admin_id: string\n    todo_list_todo_id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_list_audit_logsCreateOrConnectWithoutUserInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    create: XOR<todo_list_audit_logsCreateWithoutUserInput, todo_list_audit_logsUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_audit_logsCreateManyUserInputEnvelope = {\n    data: todo_list_audit_logsCreateManyUserInput | todo_list_audit_logsCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_list_todosUpsertWithWhereUniqueWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    update: XOR<todo_list_todosUpdateWithoutUserInput, todo_list_todosUncheckedUpdateWithoutUserInput>\n    create: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_todosUpdateWithWhereUniqueWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    data: XOR<todo_list_todosUpdateWithoutUserInput, todo_list_todosUncheckedUpdateWithoutUserInput>\n  }\n\n  export type todo_list_todosUpdateManyWithWhereWithoutUserInput = {\n    where: todo_list_todosScalarWhereInput\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type todo_list_todosScalarWhereInput = {\n    AND?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n    OR?: todo_list_todosScalarWhereInput[]\n    NOT?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n    id?: UuidFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    content?: StringFilter<\"todo_list_todos\"> | string\n    due_date?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n  }\n\n  export type todo_list_audit_logsUpsertWithWhereUniqueWithoutUserInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    update: XOR<todo_list_audit_logsUpdateWithoutUserInput, todo_list_audit_logsUncheckedUpdateWithoutUserInput>\n    create: XOR<todo_list_audit_logsCreateWithoutUserInput, todo_list_audit_logsUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_audit_logsUpdateWithWhereUniqueWithoutUserInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    data: XOR<todo_list_audit_logsUpdateWithoutUserInput, todo_list_audit_logsUncheckedUpdateWithoutUserInput>\n  }\n\n  export type todo_list_audit_logsUpdateManyWithWhereWithoutUserInput = {\n    where: todo_list_audit_logsScalarWhereInput\n    data: XOR<todo_list_audit_logsUpdateManyMutationInput, todo_list_audit_logsUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type todo_list_audit_logsScalarWhereInput = {\n    AND?: todo_list_audit_logsScalarWhereInput | todo_list_audit_logsScalarWhereInput[]\n    OR?: todo_list_audit_logsScalarWhereInput[]\n    NOT?: todo_list_audit_logsScalarWhereInput | todo_list_audit_logsScalarWhereInput[]\n    id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    todo_list_admin_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    todo_list_todo_id?: UuidFilter<\"todo_list_audit_logs\"> | string\n    action?: StringFilter<\"todo_list_audit_logs\"> | string\n    rationale?: StringNullableFilter<\"todo_list_audit_logs\"> | string | null\n    created_at?: DateTimeFilter<\"todo_list_audit_logs\"> | Date | string\n  }\n\n  export type todo_list_audit_logsCreateWithoutAdminInput = {\n    id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n    user: todo_list_usersCreateNestedOneWithoutTodo_list_audit_logsInput\n    todo: todo_list_todosCreateNestedOneWithoutTodo_list_audit_logsInput\n  }\n\n  export type todo_list_audit_logsUncheckedCreateWithoutAdminInput = {\n    id: string\n    todo_list_user_id: string\n    todo_list_todo_id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_list_audit_logsCreateOrConnectWithoutAdminInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    create: XOR<todo_list_audit_logsCreateWithoutAdminInput, todo_list_audit_logsUncheckedCreateWithoutAdminInput>\n  }\n\n  export type todo_list_audit_logsCreateManyAdminInputEnvelope = {\n    data: todo_list_audit_logsCreateManyAdminInput | todo_list_audit_logsCreateManyAdminInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_list_audit_logsUpsertWithWhereUniqueWithoutAdminInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    update: XOR<todo_list_audit_logsUpdateWithoutAdminInput, todo_list_audit_logsUncheckedUpdateWithoutAdminInput>\n    create: XOR<todo_list_audit_logsCreateWithoutAdminInput, todo_list_audit_logsUncheckedCreateWithoutAdminInput>\n  }\n\n  export type todo_list_audit_logsUpdateWithWhereUniqueWithoutAdminInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    data: XOR<todo_list_audit_logsUpdateWithoutAdminInput, todo_list_audit_logsUncheckedUpdateWithoutAdminInput>\n  }\n\n  export type todo_list_audit_logsUpdateManyWithWhereWithoutAdminInput = {\n    where: todo_list_audit_logsScalarWhereInput\n    data: XOR<todo_list_audit_logsUpdateManyMutationInput, todo_list_audit_logsUncheckedUpdateManyWithoutAdminInput>\n  }\n\n  export type todo_list_usersCreateWithoutTodo_list_todosInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_audit_logs?: todo_list_audit_logsCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersUncheckedCreateWithoutTodo_list_todosInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersCreateOrConnectWithoutTodo_list_todosInput = {\n    where: todo_list_usersWhereUniqueInput\n    create: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n  }\n\n  export type todo_list_audit_logsCreateWithoutTodoInput = {\n    id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n    admin: todo_list_adminsCreateNestedOneWithoutTodo_list_audit_logsInput\n    user: todo_list_usersCreateNestedOneWithoutTodo_list_audit_logsInput\n  }\n\n  export type todo_list_audit_logsUncheckedCreateWithoutTodoInput = {\n    id: string\n    todo_list_admin_id: string\n    todo_list_user_id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_list_audit_logsCreateOrConnectWithoutTodoInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    create: XOR<todo_list_audit_logsCreateWithoutTodoInput, todo_list_audit_logsUncheckedCreateWithoutTodoInput>\n  }\n\n  export type todo_list_audit_logsCreateManyTodoInputEnvelope = {\n    data: todo_list_audit_logsCreateManyTodoInput | todo_list_audit_logsCreateManyTodoInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_list_usersUpsertWithoutTodo_list_todosInput = {\n    update: XOR<todo_list_usersUpdateWithoutTodo_list_todosInput, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n    create: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    where?: todo_list_usersWhereInput\n  }\n\n  export type todo_list_usersUpdateToOneWithWhereWithoutTodo_list_todosInput = {\n    where?: todo_list_usersWhereInput\n    data: XOR<todo_list_usersUpdateWithoutTodo_list_todosInput, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n  }\n\n  export type todo_list_usersUpdateWithoutTodo_list_todosInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_audit_logs?: todo_list_audit_logsUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_audit_logsUpsertWithWhereUniqueWithoutTodoInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    update: XOR<todo_list_audit_logsUpdateWithoutTodoInput, todo_list_audit_logsUncheckedUpdateWithoutTodoInput>\n    create: XOR<todo_list_audit_logsCreateWithoutTodoInput, todo_list_audit_logsUncheckedCreateWithoutTodoInput>\n  }\n\n  export type todo_list_audit_logsUpdateWithWhereUniqueWithoutTodoInput = {\n    where: todo_list_audit_logsWhereUniqueInput\n    data: XOR<todo_list_audit_logsUpdateWithoutTodoInput, todo_list_audit_logsUncheckedUpdateWithoutTodoInput>\n  }\n\n  export type todo_list_audit_logsUpdateManyWithWhereWithoutTodoInput = {\n    where: todo_list_audit_logsScalarWhereInput\n    data: XOR<todo_list_audit_logsUpdateManyMutationInput, todo_list_audit_logsUncheckedUpdateManyWithoutTodoInput>\n  }\n\n  export type todo_list_adminsCreateWithoutTodo_list_audit_logsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    privilege_level: string\n    last_admin_action_at?: Date | string | null\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_adminsUncheckedCreateWithoutTodo_list_audit_logsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    privilege_level: string\n    last_admin_action_at?: Date | string | null\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_adminsCreateOrConnectWithoutTodo_list_audit_logsInput = {\n    where: todo_list_adminsWhereUniqueInput\n    create: XOR<todo_list_adminsCreateWithoutTodo_list_audit_logsInput, todo_list_adminsUncheckedCreateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type todo_list_usersCreateWithoutTodo_list_audit_logsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_todos?: todo_list_todosCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersUncheckedCreateWithoutTodo_list_audit_logsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name?: string | null\n    avatar_uri?: string | null\n    status: string\n    last_login_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_todos?: todo_list_todosUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersCreateOrConnectWithoutTodo_list_audit_logsInput = {\n    where: todo_list_usersWhereUniqueInput\n    create: XOR<todo_list_usersCreateWithoutTodo_list_audit_logsInput, todo_list_usersUncheckedCreateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type todo_list_todosCreateWithoutTodo_list_audit_logsInput = {\n    id: string\n    content: string\n    due_date?: Date | string | null\n    completed: boolean\n    completed_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    user: todo_list_usersCreateNestedOneWithoutTodo_list_todosInput\n  }\n\n  export type todo_list_todosUncheckedCreateWithoutTodo_list_audit_logsInput = {\n    id: string\n    todo_list_user_id: string\n    content: string\n    due_date?: Date | string | null\n    completed: boolean\n    completed_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_todosCreateOrConnectWithoutTodo_list_audit_logsInput = {\n    where: todo_list_todosWhereUniqueInput\n    create: XOR<todo_list_todosCreateWithoutTodo_list_audit_logsInput, todo_list_todosUncheckedCreateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type todo_list_adminsUpsertWithoutTodo_list_audit_logsInput = {\n    update: XOR<todo_list_adminsUpdateWithoutTodo_list_audit_logsInput, todo_list_adminsUncheckedUpdateWithoutTodo_list_audit_logsInput>\n    create: XOR<todo_list_adminsCreateWithoutTodo_list_audit_logsInput, todo_list_adminsUncheckedCreateWithoutTodo_list_audit_logsInput>\n    where?: todo_list_adminsWhereInput\n  }\n\n  export type todo_list_adminsUpdateToOneWithWhereWithoutTodo_list_audit_logsInput = {\n    where?: todo_list_adminsWhereInput\n    data: XOR<todo_list_adminsUpdateWithoutTodo_list_audit_logsInput, todo_list_adminsUncheckedUpdateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type todo_list_adminsUpdateWithoutTodo_list_audit_logsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    privilege_level?: StringFieldUpdateOperationsInput | string\n    last_admin_action_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_adminsUncheckedUpdateWithoutTodo_list_audit_logsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    privilege_level?: StringFieldUpdateOperationsInput | string\n    last_admin_action_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_usersUpsertWithoutTodo_list_audit_logsInput = {\n    update: XOR<todo_list_usersUpdateWithoutTodo_list_audit_logsInput, todo_list_usersUncheckedUpdateWithoutTodo_list_audit_logsInput>\n    create: XOR<todo_list_usersCreateWithoutTodo_list_audit_logsInput, todo_list_usersUncheckedCreateWithoutTodo_list_audit_logsInput>\n    where?: todo_list_usersWhereInput\n  }\n\n  export type todo_list_usersUpdateToOneWithWhereWithoutTodo_list_audit_logsInput = {\n    where?: todo_list_usersWhereInput\n    data: XOR<todo_list_usersUpdateWithoutTodo_list_audit_logsInput, todo_list_usersUncheckedUpdateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type todo_list_usersUpdateWithoutTodo_list_audit_logsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_todos?: todo_list_todosUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_usersUncheckedUpdateWithoutTodo_list_audit_logsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    avatar_uri?: NullableStringFieldUpdateOperationsInput | string | null\n    status?: StringFieldUpdateOperationsInput | string\n    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_todos?: todo_list_todosUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_todosUpsertWithoutTodo_list_audit_logsInput = {\n    update: XOR<todo_list_todosUpdateWithoutTodo_list_audit_logsInput, todo_list_todosUncheckedUpdateWithoutTodo_list_audit_logsInput>\n    create: XOR<todo_list_todosCreateWithoutTodo_list_audit_logsInput, todo_list_todosUncheckedCreateWithoutTodo_list_audit_logsInput>\n    where?: todo_list_todosWhereInput\n  }\n\n  export type todo_list_todosUpdateToOneWithWhereWithoutTodo_list_audit_logsInput = {\n    where?: todo_list_todosWhereInput\n    data: XOR<todo_list_todosUpdateWithoutTodo_list_audit_logsInput, todo_list_todosUncheckedUpdateWithoutTodo_list_audit_logsInput>\n  }\n\n  export type todo_list_todosUpdateWithoutTodo_list_audit_logsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: todo_list_usersUpdateOneRequiredWithoutTodo_list_todosNestedInput\n  }\n\n  export type todo_list_todosUncheckedUpdateWithoutTodo_list_audit_logsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_todosCreateManyUserInput = {\n    id: string\n    content: string\n    due_date?: Date | string | null\n    completed: boolean\n    completed_at?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_audit_logsCreateManyUserInput = {\n    id: string\n    todo_list_admin_id: string\n    todo_list_todo_id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_list_todosUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    todo_list_audit_logs?: todo_list_audit_logsUpdateManyWithoutTodoNestedInput\n  }\n\n  export type todo_list_todosUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    todo_list_audit_logs?: todo_list_audit_logsUncheckedUpdateManyWithoutTodoNestedInput\n  }\n\n  export type todo_list_todosUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    admin?: todo_list_adminsUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n    todo?: todo_list_todosUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_admin_id?: StringFieldUpdateOperationsInput | string\n    todo_list_todo_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_admin_id?: StringFieldUpdateOperationsInput | string\n    todo_list_todo_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsCreateManyAdminInput = {\n    id: string\n    todo_list_user_id: string\n    todo_list_todo_id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_list_audit_logsUpdateWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: todo_list_usersUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n    todo?: todo_list_todosUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    todo_list_todo_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateManyWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    todo_list_todo_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsCreateManyTodoInput = {\n    id: string\n    todo_list_admin_id: string\n    todo_list_user_id: string\n    action: string\n    rationale?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_list_audit_logsUpdateWithoutTodoInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    admin?: todo_list_adminsUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n    user?: todo_list_usersUpdateOneRequiredWithoutTodo_list_audit_logsNestedInput\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateWithoutTodoInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_admin_id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_audit_logsUncheckedUpdateManyWithoutTodoInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_admin_id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    rationale?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/client.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./default\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Actors](#actors)\n- [Todos](#todos)\n\n## Actors\n\n```mermaid\nerDiagram\n\"todo_list_users\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name \"nullable\"\n  String(80000) avatar_uri \"nullable\"\n  String status\n  DateTime last_login_at \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"todo_list_admins\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name \"nullable\"\n  String(80000) avatar_uri \"nullable\"\n  String status\n  String privilege_level\n  DateTime last_admin_action_at \"nullable\"\n  DateTime last_login_at \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n```\n\n### `todo_list_users`\n\nApplication users table. Stores core account/authentication credentials,\nregistration data, profile fields, and business status for each user.\nUsed to verify personal identity, manage sessions, and enforce\nuser-specific business rules. Core relationships: owns many todos (see\n[todo_list_todos](#todo_list_todos)), is target for logs. Cannot perform privileged\nadmin actions. Users are independently managed entities representing the\nmain service customer base.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`\n  > User's unique login email address. Used for authentication and\n  > identification. Must be unique for each user and serve as primary contact\n  > for registration, password recovery, and notifications.\n- `password_hash`\n  > Bcrypt/argon2 hashed password for authentication. NEVER stores plain\n  > password. Required for user login.\n- `name`\n  > Optional user display name for UI and search. Can be empty or null if not\n  > set by user. Not enforced to be unique.\n- `avatar_uri`\n  > Optional field for user's profile/avatar image URL. Useful for\n  > personalized interfaces. Null if user does not set.\n- `status`\n  > Current account status (e.g., active, locked, disabled). Used for\n  > lifecycle control, login restriction, or compliance. Business logic\n  > enforces legal values; implement as string here for flexibility.\n- `last_login_at`\n  > Timestamp of user's most recent successful login. Used for security and\n  > audit. Null if never logged in yet.\n- `created_at`: Record creation time (UTC). Used for audit trail and time-based queries.\n- `updated_at`: Timestamp of most recent data update to the user record.\n- `deleted_at`\n  > Soft-deletion timestamp. If not null, user is considered deleted (not\n  > visible in main listings, subject to compliance retention).\n\n### `todo_list_admins`\n\nAdministrator accounts table. Stores admin credentials, authentication,\nstatus, profile, and privileged operational data. Used to manage and\noperate all aspects of the Todo List service and review or delete user\ntodos as necessary. Requires auditability of all administrative actions.\nAccount is distinct from regular users for business control and\ncompliance, isolating admin roles from end-user personas.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`\n  > Administrator's unique login email. For secure privileged access only.\n  > Must be unique among admin accounts.\n- `password_hash`\n  > Hash of admin's password, as in user accounts. For login authentication\n  > (bcrypt/argon2 hash).\n- `name`\n  > Administrator's display name for UI, policy, and audit references.\n  > Nullable if not set but strongly encouraged for logging.\n- `avatar_uri`: Optional admin profile/avatar image.\n- `status`\n  > Current admin account status (e.g., active, locked, disabled, suspended).\n  > Used for controlling access to admin actions; values managed by business\n  > logic.\n- `privilege_level`\n  > Business-defined privilege level (e.g., superadmin, support, auditor).\n  > Used for assigning different sets of administrative permissions within\n  > the admin domain.\n- `last_admin_action_at`\n  > Timestamp of the admin's most recent privileged operational action (e.g.,\n  > delete user todo, set announcement). Used for audit tracking and\n  > accountability.\n- `last_login_at`\n  > Timestamp of the administrator's last successful login. Used for security\n  > and operational auditing.\n- `created_at`\n  > Admin account creation timestamp (UTC). Used for onboarding tracking and\n  > auditing.\n- `updated_at`: Most recent update timestamp, for audit and policy enforcement.\n- `deleted_at`\n  > Soft-delete timestamp; if not null, admin account is technically deleted\n  > or suspended.\n\n## Todos\n\n```mermaid\nerDiagram\n\"todo_list_todos\" {\n  String id PK\n  String todo_list_user_id FK\n  String content\n  DateTime due_date \"nullable\"\n  Boolean completed\n  DateTime completed_at \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"todo_list_audit_logs\" {\n  String id PK\n  String todo_list_admin_id FK\n  String todo_list_user_id FK\n  String todo_list_todo_id FK\n  String action\n  String rationale \"nullable\"\n  DateTime created_at\n}\n\"todo_list_audit_logs\" }o--|| \"todo_list_todos\" : todo\n```\n\n### `todo_list_todos`\n\nRepresents individual tasks (todos) created and owned by users. Each todo\ncan have content (with a business rule of maximum 255 characters),\noptional due date, and a completed status. Only the owner (or an admin)\ncan view, edit, mark complete/incomplete, or delete each todo. This table\nsupports per-user task management, access enforcement, and core\nproductivity operations. Cross-references todo_list_users for ownership\nlinkage.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `todo_list_user_id`\n  > Owner user's [todo_list_users.id](#todo_list_users). Indicates which user this todo\n  > belongs to.\n- `content`\n  > The textual content of the todo. Maximum 255 characters, trimmed of\n  > whitespace, must not be empty or only whitespace. Validated business\n  > rules (no control characters, required).\n- `due_date`\n  > Optional due date for the todo, null if not set. If present, must be an\n  > ISO date not before creation date.\n- `completed`\n  > Whether the todo has been marked as completed. Defaults to false on\n  > creation, toggled by user action.\n- `completed_at`: Timestamp when the todo was marked as completed. Null if not completed.\n- `created_at`: When this todo was created.\n- `updated_at`\n  > Timestamp of the last modification to this todo (edit, status change,\n  > etc).\n\n### `todo_list_audit_logs`\n\nRecords all admin-initiated actions affecting any user's todos, such as\nviewing or deleting a user's todo for compliance or security purposes.\nCaptures admin username, affected user, target todo, admin action (enum:\n'view', 'delete'), rationale (optional free text), and audit timestamp.\nSupports privacy compliance, monitoring, and traceability in accordance\nwith business and legal policy.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `todo_list_admin_id`: Admin's [todo_list_admins.id](#todo_list_admins) who performed the action.\n- `todo_list_user_id`\n  > Target user's [todo_list_users.id](#todo_list_users) whose todo was affected or\n  > accessed.\n- `todo_list_todo_id`: Target todo's [todo_list_todos.id](#todo_list_todos) affected by the admin action.\n- `action`: Admin action type on the todo. Enum: 'view', 'delete'.\n- `rationale`\n  > Optional explanation or justification text for the admin action. Free\n  > text field; null allowed for non-sensitive actions.\n- `created_at`: Timestamp when this audit log entry was created.\n","diagrams":{"Actors":"```mermaid\nerDiagram\n\"todo_list_users\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name \"nullable\"\n  String(80000) avatar_uri \"nullable\"\n  String status\n  DateTime last_login_at \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"todo_list_admins\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name \"nullable\"\n  String(80000) avatar_uri \"nullable\"\n  String status\n  String privilege_level\n  DateTime last_admin_action_at \"nullable\"\n  DateTime last_login_at \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n```","Todos":"```mermaid\nerDiagram\n\"todo_list_todos\" {\n  String id PK\n  String todo_list_user_id FK\n  String content\n  DateTime due_date \"nullable\"\n  Boolean completed\n  DateTime completed_at \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"todo_list_audit_logs\" {\n  String id PK\n  String todo_list_admin_id FK\n  String todo_list_user_id FK\n  String todo_list_todo_id FK\n  String action\n  String rationale \"nullable\"\n  DateTime created_at\n}\n\"todo_list_audit_logs\" }o--|| \"todo_list_todos\" : todo\n```"}},"created_at":"2025-09-23T05:53:04.389Z","completed_at":"2025-09-23T05:55:22.442Z","step":0},{"type":"interface","id":"0199752c-6ac0-7788-bf9e-5a088205f16c","reason":"Step to the interface designing after DB schema generation","authorizations":[{"role":"user","operations":[{"specification":"User account registration (join) for regular users. This endpoint is responsible for accepting new user credentials (email, password_hash) and creating a new row in the todo_list_users table. When a registration request is received, it validates the uniqueness of the email field by checking todo_list_users.email, hashes the provided password, and sets initial account status to a value required for new accounts (e.g., 'active' or 'pending', according to business logic). After successful insertion, the service issues initial JWT access and refresh tokens, encoding the user's id and role. Only fields existing in todo_list_users are used for DB record creation. All validation logic for fields (uniqueness, required, max lengths) must reference the todo_list_users Prisma schema documentation. This operation is critical in the onboarding flow and must provide secure error handling for registration failures. It is not available to already authenticated users and requires no prior authentication.","authorizationType":"join","description":"This API operation allows creation of a new user account for the regular user role, referencing the todo_list_users table in the Prisma schema. The join operation enables end users to register with their email and password, provided fields are unique and conform to database constraints.\n\nThe handler validates the email is not already present in todo_list_users.email, checks that the password_hash meets required security standards, and initializes the status field (for instance 'active') according to business logic. Upon registration, only defined table fields such as email, password_hash, name (optional), and status are stored—no extraneous data is accepted. Errors arising from unique constraint violations or required field omissions are surfaced with business-appropriate messages.\n\nThe operation is only accessible to users not currently authenticated. Registration success results in issuing a JWT access token plus a refresh token, encoding user id from todo_list_users.id and assigning the \"user\" role. The response conforms to the ITodoListUser.IAuthorized DTO format. Any edge cases, such as attempting to register with a deactivated, suspended, or previously soft-deleted email, are handled in accordance with the current value of the deleted_at and status columns in todo_list_users.\n\nThis endpoint is foundational for onboarding, integrating directly with the login, refresh, and password management endpoints within the user authentication flow. If registration is unsuccessful, the operation does not leak details about which field(s) caused failure beyond standard error handling. It is closely related to the todo_list_users Prisma DB model and must align with all its business documentation.","summary":"Register a new user account in todo_list_users and provision JWT tokens (role: user)","parameters":[],"requestBody":{"description":"Information required to create a new user account (email, password_hash, optional name/avatar for profile, initial status as per business logic).","typeName":"ITodoListUser.IJoin"},"responseBody":{"description":"Authorized session object with access/refresh JWT, user/basic profile per todo_list_users, and role context for the new user.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"join","path":"/auth/user/join","method":"post"},{"specification":"Standard login endpoint for user accounts in the todo_list_users table. When a login request is received (email + password), the system validates credentials by looking up the supplied email in todo_list_users and comparing the hash of the submitted password to the stored password_hash. Only active accounts (matching status as defined in schema and not having deleted_at set) may authenticate. Upon successful authentication, issues new JWT access/refresh tokens (encoding user id and role) and logs the login event (updates last_login_at). Enforces error-handling per business requirements and never reveals which credential was incorrect. Operation uses fields defined in todo_list_users exclusively for credential and status verification.","authorizationType":"login","description":"This operation enables existing registered users to authenticate to the todo list application via email and password, as stored in the todo_list_users table. The system hashes the supplied password and matches it against todo_list_users.password_hash for the email record. Logins are allowed only for users with status indicating active account and a null value for deleted_at. On a successful login, new JWT access and refresh tokens are generated as specified by business rules, with the user id and \"user\" role included in tokens. The last_login_at field is updated to the present time for audit and security tracking.\n\nIf authentication fails, the system returns a standard login error message, never exposing which field—email or password—caused failure. Error reporting follows business guidelines and must not enable user enumeration attacks. The system checks only real schema fields (email, password_hash, status, deleted_at).\n\nSuccessful logins enable access to all authorized API endpoints for the user role. This operation seamlessly connects to related endpoints such as refresh, password-reset (if implemented), and general user session management. It is always consistent with the todo_list_users schema and omits extraneous logic or fields.","summary":"Authenticate a user from todo_list_users, issue new JWT session tokens (role: user)","parameters":[],"requestBody":{"description":"User login credentials: email address and raw password (to be hashed before comparison).","typeName":"ITodoListUser.ILogin"},"responseBody":{"description":"Authorized session object including JWT tokens, role, and user profile context.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"login","path":"/auth/user/login","method":"post"},{"specification":"Refresh endpoint for user accounts in todo_list_users. When invoked, this endpoint accepts an existing, valid refresh token (typically issued after login or join operations) and, upon verifying its validity and that the referenced user account is still active (status, deleted_at), issues a new set of JWT access and refresh tokens for continued session. No credential resubmission required; the system uses the embedded user id and role in the refresh token payload for account lookup. Operation checks only real fields in the todo_list_users schema.","authorizationType":"refresh","description":"This API operation allows registered user accounts to renew their JWT session using a valid refresh token referencing an active record in todo_list_users. The handler extracts and verifies the token, checks the status and ensures deleted_at is null for the related user, then issues a fresh JWT access/refresh token pair. If the token is expired, revoked, or references an ineligible account (wrong status or soft-deleted), errors are reported per business rules.\n\nOnly fields actually defined in the schema (status, deleted_at, etc.) are used for account checks. Upon a successful refresh, the service updates the last_login_at if specified in application logic. No credentials are required in the request; all context comes from the presented refresh token.\n\nThis operation is related to login, join, and any password/session management flows, forming the core of the user's ongoing authentication lifecycle. Only operations present in todo_list_users, including necessary validation fields, are referenced.","summary":"Renew JWT session tokens for a user by validating a refresh token against todo_list_users","parameters":[],"requestBody":{"description":"Valid JWT refresh token referencing a todo_list_users account for session renewal.","typeName":"ITodoListUser.IRefresh"},"responseBody":{"description":"Authorized session object with renewed tokens and user context (role: user).","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"refresh","path":"/auth/user/refresh","method":"post"}]},{"role":"admin","operations":[{"specification":"Implements the administrator registration (join) operation. This endpoint allows the creation of a new administrator account in the todo_list_admins table. It requires a unique email and a hashed password, as defined by the password_hash field in the schema. Upon successful registration, the admin's profile is initialized with a default status, and user-provided name/avatar are optional. The new admin account can be used to log in, manage platform settings, or perform privileged actions. The JWT payload for the admin includes relevant privilege and identification fields.\n\nThis endpoint is public and does not require prior authentication as it is used to bootstrap new admin accounts. Business logic ensures email uniqueness and uses secure password validation, referencing the email, password_hash, and status fields from the todo_list_admins schema. If an email is already registered, an appropriate error is returned, and no account is created. The response includes an authorized admin DTO as per authentication conventions.\n\nThis operation is required for initial admin provisioning, security, and platform bootstrap. It is referenced by all admin onboarding and admin API authentication workflows. Related operations: admin login and admin token refresh.","authorizationType":"join","description":"This endpoint registers a new administrator account by creating a record in the todo_list_admins table. Email uniqueness is enforced by the @@unique constraint. The password_hash field must contain a securely hashed password. Optional fields, such as name and avatar_uri, may be set by the admin upon creation. The status field controls active/inactive state. Upon successful join, an authentication token (JWT) is issued that includes privileges from the privilege_level and status fields. Security ensures emails cannot be enumerated, and only valid registration requests are accepted. If registration fails due to constraint violation (e.g., email reuse), the operation returns a business-level error with no sensitive detail.\n\nThis endpoint is public-facing, and account creation is allowed until registration policies change. Further admin authentication uses the credentials established here. Password reset and privilege escalation require additional operations. All admin-centric onboarding flows reference this join endpoint for initial registration.","summary":"Registers a new administrator in the todo_list_admins table.","parameters":[],"requestBody":{"description":"Details for creating a new administrator account.","typeName":"ITodoListAdmin.IJoin"},"responseBody":{"description":"Created administrator account with authorization token information.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"join","path":"/auth/admin/join","method":"post"},{"specification":"Implements the administrator login operation. This endpoint authenticates an admin user attempting to log in via email and password. It references the todo_list_admins table for credentials: the provided email MUST match an existing admin account, and the password is validated against password_hash. Upon successful login, issues a new JWT token with claims reflecting the admin's id, status, and privilege_level fields.\n\nAuthentication failure (due to incorrect credentials, non-existent email, or status!=active) returns an appropriate error message, never exposing which emails exist for security best practices. This login is required for all subsequent admin operations, including platform management and user support actions. Related endpoints include admin join (registration) and admin token refresh. JWT access and refresh tokens are managed according to security policy.","authorizationType":"login","description":"Authenticates administrator credentials (email, password) against records in the todo_list_admins table. Requires the email field to match an existing administrator and the password to validate against the password_hash using a secure comparison. Successful login issues JWT access and refresh tokens, with claims constructed from the id, email, privilege_level, and status fields. Only admin accounts with status indicating active are permitted to login. If login fails due to incorrect credentials, inactive status, or account lockout, a safe generic error is returned. Rate limits and lockout policy may be enforced to prevent brute force attacks.\n\nThis operation is foundational for all secure administrative actions. Follow-up actions such as password reset, 2FA, or session management are supported in dedicated endpoints. Logging is used for all admin authentication events to ensure traceability.","summary":"Authenticates admin credentials for todo_list_admins. Issues JWT tokens if valid.","parameters":[],"requestBody":{"description":"Administrator login credentials (email & password).","typeName":"ITodoListAdmin.ILogin"},"responseBody":{"description":"Administrator JWT tokens and authorization payload.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"login","path":"/auth/admin/login","method":"post"},{"specification":"Implements administrator JWT refresh operation. This endpoint allows a currently authenticated admin to request fresh access and refresh tokens using a valid (non-expired, non-revoked) refresh token. Underlying logic checks the existence, validity, and status of the admin in the todo_list_admins table (id, status) before reissuing new tokens. Refresh process prohibits refresh for deleted, disabled, or non-existent admin accounts by referencing the deleted_at and status fields.\n\nThe operation is essential for secure long-lived admin sessions and to support seamless administrative workflows without requiring repeated logins. On success, new JWT tokens with matching claims to the admin's records are issued. On failure (e.g., invalid/expired refresh token or revoked admin status), a business-appropriate error is returned and no tokens are issued.","authorizationType":"refresh","description":"Enables token refresh for an authenticated administrator using a valid refresh token. Validates the admin’s identity and session by verifying the refresh token and the current state of the corresponding admin record in todo_list_admins. Uses the deleted_at and status fields to determine eligibility for refresh—accounts marked deleted, locked, or disabled cannot refresh tokens. New JWT tokens, with claims that reflect the up-to-date privilege_level and status, are issued to maintain secure admin session continuity. Audit logs are updated for refresh activity. Errors are returned for any token or status issue.","summary":"Refreshes administrator JWT tokens if current credentials are valid (todo_list_admins).","parameters":[],"requestBody":{"description":"Administrator refresh token credentials.","typeName":"ITodoListAdmin.IRefresh"},"responseBody":{"description":"New JWT tokens and corresponding admin authorization DTO.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"refresh","path":"/auth/admin/refresh","method":"post"}]}],"document":{"operations":[{"specification":"User account registration (join) for regular users. This endpoint is responsible for accepting new user credentials (email, password_hash) and creating a new row in the todo_list_users table. When a registration request is received, it validates the uniqueness of the email field by checking todo_list_users.email, hashes the provided password, and sets initial account status to a value required for new accounts (e.g., 'active' or 'pending', according to business logic). After successful insertion, the service issues initial JWT access and refresh tokens, encoding the user's id and role. Only fields existing in todo_list_users are used for DB record creation. All validation logic for fields (uniqueness, required, max lengths) must reference the todo_list_users Prisma schema documentation. This operation is critical in the onboarding flow and must provide secure error handling for registration failures. It is not available to already authenticated users and requires no prior authentication.","authorizationType":"join","description":"This API operation allows creation of a new user account for the regular user role, referencing the todo_list_users table in the Prisma schema. The join operation enables end users to register with their email and password, provided fields are unique and conform to database constraints.\n\nThe handler validates the email is not already present in todo_list_users.email, checks that the password_hash meets required security standards, and initializes the status field (for instance 'active') according to business logic. Upon registration, only defined table fields such as email, password_hash, name (optional), and status are stored—no extraneous data is accepted. Errors arising from unique constraint violations or required field omissions are surfaced with business-appropriate messages.\n\nThe operation is only accessible to users not currently authenticated. Registration success results in issuing a JWT access token plus a refresh token, encoding user id from todo_list_users.id and assigning the \"user\" role. The response conforms to the ITodoListUser.IAuthorized DTO format. Any edge cases, such as attempting to register with a deactivated, suspended, or previously soft-deleted email, are handled in accordance with the current value of the deleted_at and status columns in todo_list_users.\n\nThis endpoint is foundational for onboarding, integrating directly with the login, refresh, and password management endpoints within the user authentication flow. If registration is unsuccessful, the operation does not leak details about which field(s) caused failure beyond standard error handling. It is closely related to the todo_list_users Prisma DB model and must align with all its business documentation.","summary":"Register a new user account in todo_list_users and provision JWT tokens (role: user)","parameters":[],"requestBody":{"description":"Information required to create a new user account (email, password_hash, optional name/avatar for profile, initial status as per business logic).","typeName":"ITodoListUser.IJoin"},"responseBody":{"description":"Authorized session object with access/refresh JWT, user/basic profile per todo_list_users, and role context for the new user.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"join","path":"/auth/user/join","method":"post"},{"specification":"Standard login endpoint for user accounts in the todo_list_users table. When a login request is received (email + password), the system validates credentials by looking up the supplied email in todo_list_users and comparing the hash of the submitted password to the stored password_hash. Only active accounts (matching status as defined in schema and not having deleted_at set) may authenticate. Upon successful authentication, issues new JWT access/refresh tokens (encoding user id and role) and logs the login event (updates last_login_at). Enforces error-handling per business requirements and never reveals which credential was incorrect. Operation uses fields defined in todo_list_users exclusively for credential and status verification.","authorizationType":"login","description":"This operation enables existing registered users to authenticate to the todo list application via email and password, as stored in the todo_list_users table. The system hashes the supplied password and matches it against todo_list_users.password_hash for the email record. Logins are allowed only for users with status indicating active account and a null value for deleted_at. On a successful login, new JWT access and refresh tokens are generated as specified by business rules, with the user id and \"user\" role included in tokens. The last_login_at field is updated to the present time for audit and security tracking.\n\nIf authentication fails, the system returns a standard login error message, never exposing which field—email or password—caused failure. Error reporting follows business guidelines and must not enable user enumeration attacks. The system checks only real schema fields (email, password_hash, status, deleted_at).\n\nSuccessful logins enable access to all authorized API endpoints for the user role. This operation seamlessly connects to related endpoints such as refresh, password-reset (if implemented), and general user session management. It is always consistent with the todo_list_users schema and omits extraneous logic or fields.","summary":"Authenticate a user from todo_list_users, issue new JWT session tokens (role: user)","parameters":[],"requestBody":{"description":"User login credentials: email address and raw password (to be hashed before comparison).","typeName":"ITodoListUser.ILogin"},"responseBody":{"description":"Authorized session object including JWT tokens, role, and user profile context.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"login","path":"/auth/user/login","method":"post"},{"specification":"Refresh endpoint for user accounts in todo_list_users. When invoked, this endpoint accepts an existing, valid refresh token (typically issued after login or join operations) and, upon verifying its validity and that the referenced user account is still active (status, deleted_at), issues a new set of JWT access and refresh tokens for continued session. No credential resubmission required; the system uses the embedded user id and role in the refresh token payload for account lookup. Operation checks only real fields in the todo_list_users schema.","authorizationType":"refresh","description":"This API operation allows registered user accounts to renew their JWT session using a valid refresh token referencing an active record in todo_list_users. The handler extracts and verifies the token, checks the status and ensures deleted_at is null for the related user, then issues a fresh JWT access/refresh token pair. If the token is expired, revoked, or references an ineligible account (wrong status or soft-deleted), errors are reported per business rules.\n\nOnly fields actually defined in the schema (status, deleted_at, etc.) are used for account checks. Upon a successful refresh, the service updates the last_login_at if specified in application logic. No credentials are required in the request; all context comes from the presented refresh token.\n\nThis operation is related to login, join, and any password/session management flows, forming the core of the user's ongoing authentication lifecycle. Only operations present in todo_list_users, including necessary validation fields, are referenced.","summary":"Renew JWT session tokens for a user by validating a refresh token against todo_list_users","parameters":[],"requestBody":{"description":"Valid JWT refresh token referencing a todo_list_users account for session renewal.","typeName":"ITodoListUser.IRefresh"},"responseBody":{"description":"Authorized session object with renewed tokens and user context (role: user).","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"refresh","path":"/auth/user/refresh","method":"post"},{"specification":"Implements the administrator registration (join) operation. This endpoint allows the creation of a new administrator account in the todo_list_admins table. It requires a unique email and a hashed password, as defined by the password_hash field in the schema. Upon successful registration, the admin's profile is initialized with a default status, and user-provided name/avatar are optional. The new admin account can be used to log in, manage platform settings, or perform privileged actions. The JWT payload for the admin includes relevant privilege and identification fields.\n\nThis endpoint is public and does not require prior authentication as it is used to bootstrap new admin accounts. Business logic ensures email uniqueness and uses secure password validation, referencing the email, password_hash, and status fields from the todo_list_admins schema. If an email is already registered, an appropriate error is returned, and no account is created. The response includes an authorized admin DTO as per authentication conventions.\n\nThis operation is required for initial admin provisioning, security, and platform bootstrap. It is referenced by all admin onboarding and admin API authentication workflows. Related operations: admin login and admin token refresh.","authorizationType":"join","description":"This endpoint registers a new administrator account by creating a record in the todo_list_admins table. Email uniqueness is enforced by the @@unique constraint. The password_hash field must contain a securely hashed password. Optional fields, such as name and avatar_uri, may be set by the admin upon creation. The status field controls active/inactive state. Upon successful join, an authentication token (JWT) is issued that includes privileges from the privilege_level and status fields. Security ensures emails cannot be enumerated, and only valid registration requests are accepted. If registration fails due to constraint violation (e.g., email reuse), the operation returns a business-level error with no sensitive detail.\n\nThis endpoint is public-facing, and account creation is allowed until registration policies change. Further admin authentication uses the credentials established here. Password reset and privilege escalation require additional operations. All admin-centric onboarding flows reference this join endpoint for initial registration.","summary":"Registers a new administrator in the todo_list_admins table.","parameters":[],"requestBody":{"description":"Details for creating a new administrator account.","typeName":"ITodoListAdmin.IJoin"},"responseBody":{"description":"Created administrator account with authorization token information.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"join","path":"/auth/admin/join","method":"post"},{"specification":"Implements the administrator login operation. This endpoint authenticates an admin user attempting to log in via email and password. It references the todo_list_admins table for credentials: the provided email MUST match an existing admin account, and the password is validated against password_hash. Upon successful login, issues a new JWT token with claims reflecting the admin's id, status, and privilege_level fields.\n\nAuthentication failure (due to incorrect credentials, non-existent email, or status!=active) returns an appropriate error message, never exposing which emails exist for security best practices. This login is required for all subsequent admin operations, including platform management and user support actions. Related endpoints include admin join (registration) and admin token refresh. JWT access and refresh tokens are managed according to security policy.","authorizationType":"login","description":"Authenticates administrator credentials (email, password) against records in the todo_list_admins table. Requires the email field to match an existing administrator and the password to validate against the password_hash using a secure comparison. Successful login issues JWT access and refresh tokens, with claims constructed from the id, email, privilege_level, and status fields. Only admin accounts with status indicating active are permitted to login. If login fails due to incorrect credentials, inactive status, or account lockout, a safe generic error is returned. Rate limits and lockout policy may be enforced to prevent brute force attacks.\n\nThis operation is foundational for all secure administrative actions. Follow-up actions such as password reset, 2FA, or session management are supported in dedicated endpoints. Logging is used for all admin authentication events to ensure traceability.","summary":"Authenticates admin credentials for todo_list_admins. Issues JWT tokens if valid.","parameters":[],"requestBody":{"description":"Administrator login credentials (email & password).","typeName":"ITodoListAdmin.ILogin"},"responseBody":{"description":"Administrator JWT tokens and authorization payload.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"login","path":"/auth/admin/login","method":"post"},{"specification":"Implements administrator JWT refresh operation. This endpoint allows a currently authenticated admin to request fresh access and refresh tokens using a valid (non-expired, non-revoked) refresh token. Underlying logic checks the existence, validity, and status of the admin in the todo_list_admins table (id, status) before reissuing new tokens. Refresh process prohibits refresh for deleted, disabled, or non-existent admin accounts by referencing the deleted_at and status fields.\n\nThe operation is essential for secure long-lived admin sessions and to support seamless administrative workflows without requiring repeated logins. On success, new JWT tokens with matching claims to the admin's records are issued. On failure (e.g., invalid/expired refresh token or revoked admin status), a business-appropriate error is returned and no tokens are issued.","authorizationType":"refresh","description":"Enables token refresh for an authenticated administrator using a valid refresh token. Validates the admin’s identity and session by verifying the refresh token and the current state of the corresponding admin record in todo_list_admins. Uses the deleted_at and status fields to determine eligibility for refresh—accounts marked deleted, locked, or disabled cannot refresh tokens. New JWT tokens, with claims that reflect the up-to-date privilege_level and status, are issued to maintain secure admin session continuity. Audit logs are updated for refresh activity. Errors are returned for any token or status issue.","summary":"Refreshes administrator JWT tokens if current credentials are valid (todo_list_admins).","parameters":[],"requestBody":{"description":"Administrator refresh token credentials.","typeName":"ITodoListAdmin.IRefresh"},"responseBody":{"description":"New JWT tokens and corresponding admin authorization DTO.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"refresh","path":"/auth/admin/refresh","method":"post"},{"specification":"This operation searches and retrieves a paginated list of user accounts from the todo_list_users table. It leverages advanced filtering and sorting to allow administrators to review user information, account status, registration dates, and recent activity. The endpoint enables efficient user management, oversight, and compliance audits through secure, role-based access. Admins may use this to locate users by email, status, or time of creation, helping to monitor service usage and respond to support needs. Sensitive credential information (e.g., password_hash) is never included in the API response.\n\nThis operation supports pagination, free-text search in the user's name and email, and sorting by creation date or last login. Only administrators may access this endpoint, ensuring that private user information remains protected and only visible to privileged users. Rate limiting and search throttling may be applied to prevent misuse. All query criteria are validated for compliance, and any error (e.g., invalid search value) generates a clear message. The response includes summary details for each user, supporting further navigation to user-specific detail or management operations.","path":"/todoList/admin/users","method":"patch","summary":"Advanced search and pagination of all user accounts (todo_list_users table) for administrators.","description":"This PATCH /users operation lets admin users search, filter, and page through the entire set of registered user accounts. Common use cases include support intervention, compliance review, and operational monitoring. It incorporates fields such as user ID, email, display name, account status, last login time, and creation date. No password or sensitive token information is ever included in responses.\n\nSecurity is a priority: only authenticated users with the 'admin' role can invoke this endpoint. All search and pagination inputs are validated against business rules to prevent unauthorized enumeration or injection. The underlying implementation conforms to the unique and indexed constraints defined in the schema. System administrators should log access to this endpoint for audit purposes.\n\nRelevant Prisma schema: todo_list_users. This operation supports business reporting, account management, and acts as an entry point to further user-specific admin actions.","parameters":[],"requestBody":{"description":"Filter conditions, search queries, and pagination/sorting parameters for admin user search.","typeName":"ITodoListUser.IRequest"},"responseBody":{"description":"Paginated list of user summaries matching search conditions, excluding sensitive credentials.","typeName":"IPageITodoListUser.ISummary"},"authorizationRoles":["admin"],"name":"index","authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves the full profile of a specific user account from the todo_list_users table, identified by userId. Admins may use this detailed view to verify account ownership, investigate issues, or prepare for compliance actions. The endpoint does not reveal credential hashes and enforces strict access control, logging all access for auditability. The provided userId must exist; otherwise, a not-found error is returned.","path":"/todoList/admin/users/{userId}","method":"get","summary":"Retrieve a specific user's detailed profile (todo_list_users table) using their unique userId.","description":"This GET /users/{userId} operation allows an admin user to access full details of any user account for business or support needs. The returned data includes all core fields: id, email, name, avatar_uri, status, last_login_at, created_at, updated_at, and soft-deletion state (deleted_at), excluding any sensitive password_hash. This operation is essential for compliance reviews, user support, and operational monitoring.\n\nAuthorization is strictly enforced: only 'admin' role users are permitted. Each access is logged as per compliance and audit policy. If the userId parameter does not correspond to an existing user, the operation returns a 'not found' error. Input validation ensures the userId is a proper UUID before proceeding. This operation supports the overall goal of accountable and transparent user management.","parameters":[{"name":"userId","description":"Unique identifier (UUID) of the user account to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full detail object for the requested user account. Excludes credential hash.","typeName":"ITodoListUser"},"authorizationRoles":["admin"],"name":"at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation updates an existing user account in the todo_list_users table using the unique userId. It enables admins to modify fields such as name, avatar_uri, or status, in accordance with business rules. Credential-related fields (email, password_hash) may be updatable for support or account recovery purposes, but only by admins. All changes are validated to meet system constraints—e.g., unique email, valid statuses. Passwords supplied in updates are assumed pre-hashed before entering the database. Actions and modifications are logged for compliance and rollback.","path":"/todoList/admin/users/{userId}","method":"put","summary":"Update fields of a specific user account (todo_list_users) by admin, including profile and status changes.","description":"This PUT /users/{userId} endpoint lets admin users update details in any user account. Allowed fields include display name, status, avatar_uri, and optionally email or password_hash for support scenarios (e.g., account recovery). Updates to the email must maintain unique index constraints and comply with validation established by the business. Any password_hash provided must be securely pre-hashed on the client side.\n\nOnly administrators are authorized to use this; audit logs record every modification for compliance. On success, the updated user record (excluding credential hash) is returned, reflecting all applied changes. If the provided userId is invalid or does not exist, a clear error is returned. Business rules ensure that soft-deleted users are not updated unless explicitly restored. This operation supports robust account lifecycle management in accordance with privacy and compliance objectives.","parameters":[{"name":"userId","description":"Unique identifier (UUID) of the user account to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Fields and their new values for the user account update. Must follow all business validation rules.","typeName":"ITodoListUser.IUpdate"},"responseBody":{"description":"The updated full user account object (excluding credential hash) after all changes have been applied.","typeName":"ITodoListUser"},"authorizationRoles":["admin"],"name":"update","authorizationRole":"admin","authorizationType":null},{"specification":"This operation permanently removes a user account from the todo_list_users table by its unique userId. It updates the deleted_at timestamp, implementing a soft-delete per schema, ensuring that the account is excluded from main listings but retained for compliance and retention policies. Only admin users can delete accounts; this action is logged for audit traceability. If the userId does not exist, a not-found error is returned. The user cannot be recovered unless a restore endpoint is implemented later.","path":"/todoList/admin/users/{userId}","method":"delete","summary":"Soft-delete a user account (todo_list_users) by setting deleted_at; admin only.","description":"This DELETE /users/{userId} endpoint lets administrators mark a user account as deleted by populating the deleted_at field (soft delete), following the schema's soft deletion pattern. Such accounts are removed from active listings but remain in the database for retention and compliance. This operation is strictly permitted only for admin users, triggering an audit log entry for every deletion.\n\nInput validation guarantees the userId is a valid UUID and that the account exists. Attempts to delete non-existent or already-deleted users return a clear error. Related todos become orphaned or are handled based on cascading rules. The operation is irreversible—no recovery possible unless a dedicated restore function is created. This endpoint supports business needs for privacy, compliance, right-to-be-forgotten scenarios, and account lifecycle control.","parameters":[{"name":"userId","description":"Unique identifier (UUID) of the user account to soft-delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin"],"name":"erase","authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves a paginated and filterable list of administrator accounts for the Todo List application. It queries the todo_list_admins table to support searching for admins based on email, name, account status, and privilege level. The operation also supports sorting and pagination parameters. Access to this information is restricted to users with administrative rights, as it includes privileged and potentially sensitive account details. Results include admin profile fields, last login times, status, and operational privilege levels for dashboard or management interfaces.","description":"This API operation enables the searching and listing of administrator accounts registered in the Todo List system. It provides a secure method to retrieve admin details, supporting filters such as partial email or name matches, privilege level, and account status (e.g., active, suspended). Returned results include all fields from the todo_list_admins Prisma table except sensitive password hashes and soft-deleted accounts (deleted_at is null).\n\nThe operation is only accessible to authenticated admins with adequate roles, ensuring that sensitive admin data is not exposed to regular users. Results are sorted in descending order of creation time by default, but sorting or pagination options can be specified in the request. This is typically used in system admin dashboards for oversight, onboarding, or compliance checks.\n\nAppropriate business validation is applied to prevent excessive query size or abuse. Audit logs may be generated for listing large admin datasets. The response does not include authentication secrets or operational logs unrelated to account registry.","summary":"List/search all Todo List administrator accounts with filtering and pagination (table: todo_list_admins)","parameters":[],"requestBody":{"description":"Search and pagination parameters for admin account filtering","typeName":"ITodoListAdmin.IRequest"},"responseBody":{"description":"Paginated list of administrator summary records matching search criteria","typeName":"IPageITodoListAdmin.ISummary"},"authorizationType":null,"authorizationRole":"admin","name":"index","path":"/todoList/admin/admins","method":"patch"},{"specification":"This operation retrieves the full detail of a single administrator account by its unique identifier. It works against the todo_list_admins table, ensuring that privileged administrator profile, status, and operational credentials can be reviewed only by other admins. This is essential for management dashboards and account reviews, supporting profile editing, compliance checks, and operational oversight.","description":"This API endpoint returns the full detail of an administrator account specified by the adminId path parameter. It pulls all non-sensitive fields from the referenced todo_list_admins schema table, supporting administrative review or management.\n\nThe endpoint requires the caller to be authenticated as an admin. Sensitive authentication data such as password_hash are excluded from the returned object. Returned fields include name, email, status, privilege_level, avatar_uri, timestamp data (created_at, updated_at, last_login_at, last_admin_action_at), and account state.\n\nSecurity enforcement is strict to ensure only admins can access other admin data. Audit logging of access can be implemented in actual business logic to comply with operational policy.","summary":"Retrieve detailed information for a specific Todo List administrator (table: todo_list_admins)","parameters":[{"name":"adminId","description":"The unique identifier (UUID) of the target administrator account.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed administrator account profile and operational data (excluding password hashes)","typeName":"ITodoListAdmin"},"authorizationType":null,"authorizationRole":"admin","name":"at","path":"/todoList/admin/admins/{adminId}","method":"get"},{"specification":"This operation updates the editable profile fields and operational status of a specific administrator account in the todo_list_admins table. It enforces business validation such as email uniqueness and status change rules. Only admins may update other admin records, supporting profile correction, privilege modification, or account suspension/resumption. Security best practices are enforced to ensure sensitive authentication data is not arbitrarily altered except in dedicated flows.","description":"This endpoint enables an authenticated admin to update the details of another admin account, referenced by the adminId path parameter. Fields eligible for update include name, avatar_uri, status, privilege_level, and account state (active/suspended/locked), but not authentication secrets or audit history. The operation validates all inputs according to business rules, with server-side enforcement of email uniqueness and privilege change constraints.\n\nPassword resets or credential changes must be performed via separate dedicated API endpoints for security. The operation is logged as an administrative action, and only fields defined in ITodoListAdmin.IUpdate may be altered by this endpoint. On success, the updated admin account object is returned.","summary":"Update the profile or status of a specific administrator account (table: todo_list_admins)","parameters":[{"name":"adminId","description":"The unique identifier (UUID) of the target administrator account to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Updated administrator account profile/status information (excluding password hash)","typeName":"ITodoListAdmin.IUpdate"},"responseBody":{"description":"The full, updated administrator account (all exposed fields from ITodoListAdmin)","typeName":"ITodoListAdmin"},"authorizationType":null,"authorizationRole":"admin","name":"update","path":"/todoList/admin/admins/{adminId}","method":"put"},{"specification":"This operation permanently removes an administrator account from the todo_list_admins table by hard-deleting the record identified by adminId. This is used for deprovisioning or removing admin accounts, e.g., on separation or privilege revocation. The action is restricted to authenticated admins and is logged for audit purposes. Accidental or malicious deletion is mitigated by requiring confirmation at the UI or via multi-factor workflows.","description":"Invoking this endpoint causes the permanent deletion (hard delete) of the administrator account identified by the adminId path parameter. The deletion action removes the todo_list_admins row and all associated relationships, except where foreign key constraints enforce cascading or retention rules defined by business logic.\n\nAccess to this operation is strictly limited to admin users, reflecting the seriousness of deleting privileged accounts. Deletion triggers audit logging for compliance, and the operation is irreversible—deleted admin records cannot be restored by normal means. Errors are returned if the target admin does not exist or has already been deleted via soft delete (deleted_at is non-null).\n\nBusiness logic may require additional administrative approval or confirmation for high-privilege removals. The endpoint does not return a response body but will signal completion or failure via standard HTTP status codes.","summary":"Permanently delete an administrator account (table: todo_list_admins, hard delete)","parameters":[{"name":"adminId","description":"The unique identifier (UUID) of the administrator account to delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"admin","name":"erase","path":"/todoList/admin/admins/{adminId}","method":"delete"},{"specification":"This operation retrieves a user's todo list as a paginated, filtered collection. It operates on the todo_list_todos table from the Prisma schema. The operation allows users to request only their own todos, or admins to retrieve todos for any user, supporting sorting (by created_at), completion status, search by content, and optional due date filtering. All pagination and filter parameters must comply with business requirements including default page size (20), query ownership (user or admin only), and visibility (ignoring soft-deleted users/todos).","description":"Retrieve the list of todos for the currently authenticated user, supporting advanced search and filtering. Users can retrieve only their own todos, while admins may access todos across users for audit or troubleshooting purposes. The results are ordered with the most recently created tasks first by default. The business rule enforces that only the owner (role: user) or an admin (role: admin) can access a user's todos; unauthorized attempts are denied and logged.\n\nThis operation applies field-level filters (content, completion status, due date window) and supports pagination parameters like page size and offset. Results exclude todos from soft-deleted users or invalid states. Input validation prevents negative page sizes or offsets, and content queries are trimmed & sanitized. This operation is critical for productivity workflows in the Todo list app, enforcing data privacy and strict row-level access control.\n\nEdge cases—such as empty results or invalid filters—are handled gracefully with clear business error messages and do not leak internal state or information.\n\nThis endpoint is paired with single-todo retrieval, creation, updating, and deletion APIs for full user task management.","summary":"Search and retrieve a filtered, paginated list of todos for a user (todo_list_todos table).","parameters":[],"requestBody":{"description":"Search criteria (content, completed, due_date), sort and pagination parameters (offset, page size) for todo list retrieval.","typeName":"ITodoListTodo.IRequest"},"responseBody":{"description":"Paginated result set of todo task summaries matching filter and search parameters.","typeName":"IPageITodoListTodo.ISummary"},"authorizationRoles":["user","admin"],"name":"index","path":"/todoList/user/todos","method":"patch","authorizationRole":"user","authorizationType":null},{"specification":"This operation retrieves a user's todo list as a paginated, filtered collection. It operates on the todo_list_todos table from the Prisma schema. The operation allows users to request only their own todos, or admins to retrieve todos for any user, supporting sorting (by created_at), completion status, search by content, and optional due date filtering. All pagination and filter parameters must comply with business requirements including default page size (20), query ownership (user or admin only), and visibility (ignoring soft-deleted users/todos).","description":"Retrieve the list of todos for the currently authenticated user, supporting advanced search and filtering. Users can retrieve only their own todos, while admins may access todos across users for audit or troubleshooting purposes. The results are ordered with the most recently created tasks first by default. The business rule enforces that only the owner (role: user) or an admin (role: admin) can access a user's todos; unauthorized attempts are denied and logged.\n\nThis operation applies field-level filters (content, completion status, due date window) and supports pagination parameters like page size and offset. Results exclude todos from soft-deleted users or invalid states. Input validation prevents negative page sizes or offsets, and content queries are trimmed & sanitized. This operation is critical for productivity workflows in the Todo list app, enforcing data privacy and strict row-level access control.\n\nEdge cases—such as empty results or invalid filters—are handled gracefully with clear business error messages and do not leak internal state or information.\n\nThis endpoint is paired with single-todo retrieval, creation, updating, and deletion APIs for full user task management.","summary":"Search and retrieve a filtered, paginated list of todos for a user (todo_list_todos table).","parameters":[],"requestBody":{"description":"Search criteria (content, completed, due_date), sort and pagination parameters (offset, page size) for todo list retrieval.","typeName":"ITodoListTodo.IRequest"},"responseBody":{"description":"Paginated result set of todo task summaries matching filter and search parameters.","typeName":"IPageITodoListTodo.ISummary"},"authorizationRoles":["user","admin"],"name":"index","path":"/todoList/admin/todos","method":"patch","authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves detailed information about a specific todo item by its unique identifier. It operates on the todo_list_todos table from the Prisma schema. Only the owner of the todo (user) or an admin may access the todo. All fields are returned, including content, completion status, due date, timestamps, and ownership references. Sensitive or meta fields are omitted if viewing as a regular user. Access violations and missing resources trigger detailed business error responses as per requirements.","description":"Retrieve a single todo item's complete details by its ID. The system verifies that the requesting user owns the todo identified by todoId, or that the requester is an admin. Unauthorized access results in a forbidden action error, and a non-existent todoId generates a not-found error with a business-appropriate message.\n\nReturned fields include: unique identifier, owner user ID, content (up to 255 characters), completion status, due date (if set), timestamps for creation, last update, and (if completed) completion, as well as relational references for audit purposes. The data model prohibits exposure of deleted or inaccessible todos.\n\nThis operation can be used together with update, mark complete/incomplete, and delete endpoints. The schema enforces ownership and data access at the business logic level for full regulatory compliance and privacy control.","summary":"Retrieve details of a single todo by its unique identifier (todo_list_todos table).","parameters":[{"name":"todoId","description":"Unique identifier of the target todo to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Complete details of the target todo task, including content, completion, due date, and audit metadata.","typeName":"ITodoListTodo"},"authorizationRoles":["user","admin"],"name":"at","path":"/todoList/user/todos/{todoId}","method":"get","authorizationRole":"user","authorizationType":null},{"specification":"This operation retrieves detailed information about a specific todo item by its unique identifier. It operates on the todo_list_todos table from the Prisma schema. Only the owner of the todo (user) or an admin may access the todo. All fields are returned, including content, completion status, due date, timestamps, and ownership references. Sensitive or meta fields are omitted if viewing as a regular user. Access violations and missing resources trigger detailed business error responses as per requirements.","description":"Retrieve a single todo item's complete details by its ID. The system verifies that the requesting user owns the todo identified by todoId, or that the requester is an admin. Unauthorized access results in a forbidden action error, and a non-existent todoId generates a not-found error with a business-appropriate message.\n\nReturned fields include: unique identifier, owner user ID, content (up to 255 characters), completion status, due date (if set), timestamps for creation, last update, and (if completed) completion, as well as relational references for audit purposes. The data model prohibits exposure of deleted or inaccessible todos.\n\nThis operation can be used together with update, mark complete/incomplete, and delete endpoints. The schema enforces ownership and data access at the business logic level for full regulatory compliance and privacy control.","summary":"Retrieve details of a single todo by its unique identifier (todo_list_todos table).","parameters":[{"name":"todoId","description":"Unique identifier of the target todo to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Complete details of the target todo task, including content, completion, due date, and audit metadata.","typeName":"ITodoListTodo"},"authorizationRoles":["user","admin"],"name":"at","path":"/todoList/admin/todos/{todoId}","method":"get","authorizationRole":"admin","authorizationType":null},{"specification":"This operation creates a new todo item for the currently authenticated user. It interfaces with the todo_list_todos table from the Prisma schema, enforcing all business validation rules such as unique (recent) content per user, maximum content length (255 characters), valid (optional) due date, and default completed status (false). On successful creation, the todo is associated with the user and all allowed fields are returned in the response. Admins do not create todos for other users.","description":"Create a new todo for the authenticated user. The input must contain valid, non-empty content (1–255 trimmed non-control characters) and may contain an optional due date (ISO 8601, not in the past). The system assigns ownership, sets completed=false, and validates that a similar todo has not been submitted within the deduplication window for this user.\n\nUpon success, returns the full todo object with assigned identifiers and all relevant business fields. Attempts to create todos for other users, bypassing business validation, or duplicating tasks within the deduplication window are denied with appropriate error messages. This operation allows only the \"user\" role to create new todos for themselves.\n\nEdge cases covered include: whitespace-only content, excessive length, invalid or past due dates, deduplication, and unauthorized submissions. Ownership and per-field validation are enforced strictly at the business logic and API entry level.","summary":"Create a new todo item for the current user (todo_list_todos table).","parameters":[],"requestBody":{"description":"Content for the new todo (1–255 chars, no control characters, not blank), and optional due date (future or today).","typeName":"ITodoListTodo.ICreate"},"responseBody":{"description":"The created todo resource with all assigned metadata and task fields.","typeName":"ITodoListTodo"},"authorizationRoles":["user"],"name":"create","path":"/todoList/user/todos","method":"post","authorizationRole":"user","authorizationType":null},{"specification":"This operation updates an existing todo item for the authenticated user by its unique identifier. It operates on the todo_list_todos table. Only the owner (user) or an admin may update a todo. Updatable fields are: content (validated: 1–255 chars, no control characters, no all-whitespace), completed status, due date (if modified, must be valid/future), or mark as completed/uncompleted. The operation returns the updated todo object. Permission and validation checks strictly enforced: a user may not modify other users' todos; admins may update for compliance purposes. All changes update last-modified timestamp.","description":"Update (edit) an existing todo item by its unique ID. The input may include a new content value (subject to strict validation), an updated due date (if allowed), or a request to change completion status. Ownership is checked: regular users may only edit their own todos, while admins may update any user's todo according to business and compliance policy, with all such actions logged for audit.\n\nAll string and field edits are validated against business logic: content length/character rules, due date not in the past or before creation, completion status consistency. The operation returns the full, updated todo on success, with proper error responses if not found, unauthorized, or validation fails. Audit logs are generated for admin-driven updates when required by business policy.\n\nThis endpoint completes the CRUD lifecycle together with create, deletion, and retrieval endpoints.","summary":"Update a todo item by its unique identifier (todo_list_todos table).","parameters":[{"name":"todoId","description":"Unique identifier of the target todo to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Update input for the target todo: content (1–255 chars), completed status, optional due date.","typeName":"ITodoListTodo.IUpdate"},"responseBody":{"description":"The updated todo with all editable fields and assigned metadata.","typeName":"ITodoListTodo"},"authorizationRoles":["user","admin"],"name":"update","path":"/todoList/user/todos/{todoId}","method":"put","authorizationRole":"user","authorizationType":null},{"specification":"This operation updates an existing todo item for the authenticated user by its unique identifier. It operates on the todo_list_todos table. Only the owner (user) or an admin may update a todo. Updatable fields are: content (validated: 1–255 chars, no control characters, no all-whitespace), completed status, due date (if modified, must be valid/future), or mark as completed/uncompleted. The operation returns the updated todo object. Permission and validation checks strictly enforced: a user may not modify other users' todos; admins may update for compliance purposes. All changes update last-modified timestamp.","description":"Update (edit) an existing todo item by its unique ID. The input may include a new content value (subject to strict validation), an updated due date (if allowed), or a request to change completion status. Ownership is checked: regular users may only edit their own todos, while admins may update any user's todo according to business and compliance policy, with all such actions logged for audit.\n\nAll string and field edits are validated against business logic: content length/character rules, due date not in the past or before creation, completion status consistency. The operation returns the full, updated todo on success, with proper error responses if not found, unauthorized, or validation fails. Audit logs are generated for admin-driven updates when required by business policy.\n\nThis endpoint completes the CRUD lifecycle together with create, deletion, and retrieval endpoints.","summary":"Update a todo item by its unique identifier (todo_list_todos table).","parameters":[{"name":"todoId","description":"Unique identifier of the target todo to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Update input for the target todo: content (1–255 chars), completed status, optional due date.","typeName":"ITodoListTodo.IUpdate"},"responseBody":{"description":"The updated todo with all editable fields and assigned metadata.","typeName":"ITodoListTodo"},"authorizationRoles":["user","admin"],"name":"update","path":"/todoList/admin/todos/{todoId}","method":"put","authorizationRole":"admin","authorizationType":null},{"specification":"This operation permanently deletes a specific todo item from the system. It acts on the todo_list_todos table of the Prisma schema, targeting an individual todo by its unique identifier (UUID). Only the owner of the todo, or an admin, may perform this deletion. The operation enforces hard delete semantics since no soft-deletion field (e.g., deleted_at) exists on the todos table, ensuring secure and irreversible removal of task data. Deletion by an admin requires appropriate audit log creation as mandated by business rules.","description":"This endpoint allows a user (or admin) to permanently remove a single todo item, identified by its UUID, from the todo_list_todos table. The deleted todo is irreversibly purged; it will not appear in listings, cannot be restored, and all links to this task are erased from the database.\n\nTo fulfill business logic, the endpoint verifies that the requesting user is either the owner of the todo or holds an admin role. If a user attempts to delete a todo they do not own, or that does not exist, the system denies the operation and returns a business-level error message.\n\nWhen an admin performs a delete, the system must create an associated audit log entry, as described in the audit_logs table specification, to ensure traceability.\n\nThere is no soft-deletion: records are removed entirely from persistent storage. This behavior is critical for both user privacy and compliance with user-level data removal (right to erasure). Error handling includes returning 'not found' if the todo was already deleted or an invalid UUID is provided.","summary":"Permanently delete a specific todo item from the user's todo list (todo_list_todos table).","path":"/todoList/user/todos/{todoId}","method":"delete","parameters":[{"name":"todoId","description":"The unique identifier (UUID) of the todo item to be deleted.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["user","admin"],"name":"erase","authorizationRole":"user","authorizationType":null},{"specification":"This operation permanently deletes a specific todo item from the system. It acts on the todo_list_todos table of the Prisma schema, targeting an individual todo by its unique identifier (UUID). Only the owner of the todo, or an admin, may perform this deletion. The operation enforces hard delete semantics since no soft-deletion field (e.g., deleted_at) exists on the todos table, ensuring secure and irreversible removal of task data. Deletion by an admin requires appropriate audit log creation as mandated by business rules.","description":"This endpoint allows a user (or admin) to permanently remove a single todo item, identified by its UUID, from the todo_list_todos table. The deleted todo is irreversibly purged; it will not appear in listings, cannot be restored, and all links to this task are erased from the database.\n\nTo fulfill business logic, the endpoint verifies that the requesting user is either the owner of the todo or holds an admin role. If a user attempts to delete a todo they do not own, or that does not exist, the system denies the operation and returns a business-level error message.\n\nWhen an admin performs a delete, the system must create an associated audit log entry, as described in the audit_logs table specification, to ensure traceability.\n\nThere is no soft-deletion: records are removed entirely from persistent storage. This behavior is critical for both user privacy and compliance with user-level data removal (right to erasure). Error handling includes returning 'not found' if the todo was already deleted or an invalid UUID is provided.","summary":"Permanently delete a specific todo item from the user's todo list (todo_list_todos table).","path":"/todoList/admin/todos/{todoId}","method":"delete","parameters":[{"name":"todoId","description":"The unique identifier (UUID) of the todo item to be deleted.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["user","admin"],"name":"erase","authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves a paginated, filterable list of all admin audit log entries. It operates on the todo_list_audit_logs table in the Prisma schema. This endpoint is intended for admin users to monitor, analyze, or export audit records concerning actions on user todos (such as viewing or deletion). Supports complex search, filtering (by admin ID, user ID, action type, date range), and sorting to aid compliance, monitoring, and operational review.","description":"The audit log list endpoint provides administrative users with advanced search capabilities for monitoring privileged actions on user todos. Admins can filter logs by action type (view or delete), target user or todo, responsible admin, time range, or rationale content. The endpoint supports pagination to efficiently browse large audit trails and includes sorting by timestamp or other relevant fields.\n\nLog records returned by this operation include full audit details—admin identity, user and todo IDs, action performed, rationale, and timestamp—enabling forensic analysis and compliance auditing. The response structure aligns with the todo_list_audit_logs schema, ensuring accurate mapping of data fields.\n\nSecurity is paramount: only users with the admin role are authorized to use this endpoint. All access is itself subject to audit logging as required by organizational policy. No unauthorized user data is returned to non-admins. System-enforced rate limiting and sensitive data protection apply.\n\nFailure scenarios include improper use by non-admins or invalid filter criteria; informative error messages are returned to guide corrective action.","summary":"Retrieve a filtered, paginated list of audit log entries from todo_list_audit_logs (admin only).","path":"/todoList/admin/auditLogs","method":"patch","parameters":[],"requestBody":{"description":"Request parameters for audit log filtering, including pagination and search options.","typeName":"ITodoListAuditLog.IRequest"},"responseBody":{"description":"Paginated list of audit log summary information matching the search and filter criteria.","typeName":"IPageITodoListAuditLog.ISummary"},"authorizationRoles":["admin"],"name":"index","authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves detailed information about a specific audit log entry from the todo_list_audit_logs table. It requires the unique identifier (UUID) of the audit log record. The operation is restricted to admins for audit, compliance, or forensic review. Returned information includes all fields of the audit log: responsible admin, target user, action type, rationale, and timestamp, for transparency and operational governance.","description":"This endpoint allows an admin to view a single, complete audit log entry identified by its UUID in the todo_list_audit_logs table. The returned details provide full visibility into the original admin action (view or delete) upon a user's todo, including all metadata required for compliance, root cause analysis, or resolving operational issues.\n\nThe operation enforces that only users with the admin role have access. Attempts to view a nonexistent or unauthorized audit log record result in an error with an informative business-level message. Each access to a detailed audit record may itself be logged for traceability, supporting the system's comprehensive oversight requirements.\n\nReturned data includes referencing fields for admin, affected user, todo ID, action type, rationale, and audit timestamp, with structure faithfully matching the todo_list_audit_logs schema.","summary":"Retrieve details of a specific audit log entry from todo_list_audit_logs (admin only).","path":"/todoList/admin/auditLogs/{auditLogId}","method":"get","parameters":[{"name":"auditLogId","description":"The unique identifier (UUID) of the audit log entry to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full details of the specified audit log entry, as defined in the todo_list_audit_logs schema.","typeName":"ITodoListAuditLog"},"authorizationRoles":["admin"],"name":"at","authorizationRole":"admin","authorizationType":null}],"components":{"authorization":[{"name":"user","description":"A registered member who can create, read, update, and delete their own todos. Can check or uncheck tasks and view a list of their todos. Cannot access or modify other users' data.","kind":"member"},{"name":"admin","description":"Has all user privileges, plus can view and delete any user's todos if necessary for administration. Can manage the service's operational settings.","kind":"admin"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageITodoListUser.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListUser.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoListAdmin.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListAdmin.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoListTodo.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListTodo.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoListAuditLog.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListAuditLog.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"ITodoListUser.IJoin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The user's unique email address. This will be the user's login and notification identifier. It must conform to the format of a valid email address and be unique in the system. The email is used for identity verification, password reset, and primary communications. This field is required during registration and is referenced in the todo_list_users Prisma schema as the unique identifier for each user.\n\nExample: user@example.com"},"password":{"type":"string","description":"The user's password in plain text, which will be securely hashed before it is stored in the database (as password_hash column). The password must comply with the system's password policy (minimum/maximum length, complexity). NEVER store or expose this value in any user response. This is only accepted as user input during registration or login."},"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional display name for the user. This can be empty or null during registration. If provided, it is used for personalized UI, notifications, or search within the application. Not enforced to be unique."},"avatar_uri":{"oneOf":[{"type":"string","maxLength":80000},{"type":"null"}],"description":"Optional URI for the user's avatar image. Can be empty or null if not provided. If set, it must be a valid URI referencing an image resource (e.g., https://example.com/image.jpg). Used for display in user interfaces and notifications. Maximum length is 80,000 characters as defined in the database schema."}},"required":["email","password"],"description":"Registration request details for creating a new user account. All fields are validated according to the todo_list_users Prisma schema. The password will be hashed server-side before actual persistence. The email must be unique, and optional profile fields may be set if desired."},"ITodoListUser.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authenticated user from the todo_list_users table."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"user":{"$ref":"#/components/schemas/ITodoListUser","description":"The complete authenticated user profile record, excluding sensitive credential fields. Used to populate user context on client side."}},"required":["id","token","user"],"description":"Authorization response containing the authenticated user's id, full user record (excluding credentials), and JWT tokens. Returned after successful join, login, or refresh. Used by clients to maintain session context."},"ITodoListUser.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The login email for the user. Must match a registered email in the todo_list_users table. Used for authentication only, and must follow the same email policy as registration."},"password":{"type":"string","description":"The plaintext password submitted for authentication. This value is never logged or stored as plain text and is only used to validate credentials at login."}},"required":["email","password"],"description":"User login request. The fields are used to authenticate an existing account, referencing the todo_list_users schema."},"ITodoListUser.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"A JWT refresh token issued to the user's session after successful login or registration. This token is used to authenticate the request for a new access/refresh token pair during session renewal. The token must be valid and not expired, revoked, or associated with a deleted or inactive account."}},"required":["refresh_token"],"description":"Request body structure for user session refresh. Accepts an issued refresh token and, if valid, returns a new set of authorization tokens. Follows best practices for session security and anti-replay enforcement."},"ITodoListUser.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique user identifier (UUID). Reference to todo_list_users.id in the database. This identifies the user and is required for all cross-entity references in business logic."},"email":{"type":"string","format":"email","description":"The user's unique email address. Acts as the primary login and communications channel. Must be unique in the system. Reference to todo_list_users.email."},"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Display name of the user for UI purposes. Optional and nullable. If not set, user interfaces may fall back to the email or show blank. Reference: todo_list_users.name."},"avatar_uri":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"URL for the user's avatar/profile image. May be used in lists, headers, or user search. Optional and nullable. Reference: todo_list_users.avatar_uri."},"status":{"type":"string","description":"The business status of the user account (e.g., 'active', 'locked'). Used for access management and support. Reference: todo_list_users.status."},"last_login_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp of the user's most recent login (ISO 8601 UTC). Null if login never occurred. Useful for admin views, analytics, or support. Reference: todo_list_users.last_login_at."},"created_at":{"type":"string","format":"date-time","description":"User registration timestamp (ISO 8601 UTC). Used for sorting and age analysis. Reference: todo_list_users.created_at."}},"required":["id","email","status","created_at"],"description":"Summary information for a user account. Suitable for admin search/results listings where credential details are never exposed. Drawn from todo_list_users table; excludes password_hash and sensitive metadata. Contains enough information for high-level management/UI purposes, but omits profile edits, token data, and deletion markers. Aligns with business requirements to avoid leakage of secure or unnecessary fields."},"ITodoListAdmin.IJoin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Administrator's unique login email. Required for secure privileged access and identity. Must be unique per admin (see Prisma @@unique constraint on todo_list_admins.email). Used for authentication and admin communication channel. Example: admin@example.com."},"password_hash":{"type":"string","description":"Password hash for administrator authentication. This must be a cryptographically secure hashed password (bcrypt/argon2), never storing plaintext. Used for login checks (see Prisma password_hash field on todo_list_admins). Accepted by API only during admin registration, not exposed in any responses. Must meet application security requirements."},"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Administrator's display name for profile and audit log references. Optional for registration and profile personalization, but recommended for traceability (see Prisma name field on todo_list_admins). May be null or omitted if not specified. Example: \"Alex Admin\"."},"avatar_uri":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional admin profile/avatar image URI. Supports personalization of admin profile in UI. May be omitted, null, or a URI string up to 80,000 characters (see Prisma avatar_uri field). Example: \"https://cdn.example.com/avatar/234512849\"."},"status":{"type":"string","description":"Current admin account status. Governs access control and operational state. Examples: \"active\", \"locked\", \"disabled\", \"suspended\". Value set per business/custom logic (see Prisma status column). Optional on registration, defaulting to business logic if omitted."},"privilege_level":{"type":"string","description":"Business-defined privilege level (e.g., 'superadmin', 'support', 'auditor'). Optional on registration. Used for admin authorization tiering per Prisma privilege_level column. Example: \"support\"."}},"required":["email","password_hash"],"description":"Request body for registering a new administrator account. Reference to todo_list_admins Prisma table for validation, including email uniqueness and required password hash. Optional fields control profile personalization and access level. All validation uses business and schema-level rules."},"ITodoListAdmin.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Admin authentication email address. Must exist in todo_list_admins."},"password":{"type":"string","description":"Administrator's raw password, to be securely transmitted and compared to password hash. Not stored after verification."}},"required":["email","password"],"description":"Admin login form accepting login email and raw password for credential verification. References todo_list_admins."},"ITodoListAdmin.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Valid JWT refresh token issued to the admin session on prior login, join, or refresh. Used for session lifecycle management."}},"required":["refresh_token"],"description":"Request body for admin token refresh. Accepts a refresh token and, if valid, returns new access and refresh tokens for continued session."},"ITodoListAdmin.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"The admin's unique identifier from todo_list_admins.id."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"admin":{"$ref":"#/components/schemas/ITodoListAdmin","description":"Full admin profile object, excluding sensitive credentials. Useful for admin dashboards and session context."}},"required":["id","token","admin"],"description":"Authorization payload for an administrator: unique id, JWT token structure, and the admin's full profile (excluding login credentials). Follows business convention for secure session establishment."},"ITodoListAdmin":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Admin's primary key identifier from todo_list_admins.id."},"email":{"type":"string","format":"email","description":"Unique login email (business/admin only) from todo_list_admins.email."},"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Display name for UI/audit; nullable."},"avatar_uri":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Admin profile/avatar image; nullable, supports personalization."},"status":{"type":"string","description":"Admin account status for security and controls."},"privilege_level":{"type":"string","description":"Admin operational privilege, e.g., superadmin/support/auditor."},"last_admin_action_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Datetime of most recent privileged admin operation."},"last_login_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Datetime of most recent login (null if never logged in)."},"created_at":{"type":"string","format":"date-time","description":"Admin account creation timestamp."},"updated_at":{"type":"string","format":"date-time","description":"Last admin record update timestamp."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Soft-deletion timestamp (null = active)."}},"required":["id","email","status","privilege_level","created_at","updated_at"],"description":"Administrator profile record from todo_list_admins. Contains full non-credential business fields and operational audit markers, but never exposes password_hash. Used for secure dashboarding, session context, and privilege management."},"ITodoListUser.IRequest":{"type":"object","properties":{"email":{"type":"string","description":"User's login email address. This is used to filter the user list by an exact email match. Must conform to the email address format as defined by the todo_list_users.email column. If omitted, no filtering by email occurs."},"name":{"type":"string","description":"Optional partial or full match filter for the user's display name. Used in admin search and compliance review interfaces. Complies with the todo_list_users.name column (nullable)."},"status":{"type":"string","description":"Account status filter. Used to locate users by specific account lifecycle state (such as active, locked, or disabled). Must match values found in the todo_list_users.status column."},"created_from":{"type":"string","format":"date-time","description":"Include only records created after or at this UTC timestamp. For ranged registration-date queries. Must parse as ISO 8601 date-time."},"created_to":{"type":"string","format":"date-time","description":"Include only users created before or at this UTC timestamp. Defines the end boundary of registration date filtering in admin queries."},"last_login_from":{"type":"string","format":"date-time","description":"Lower bound filter for last successful login time, for account activity analysis."},"last_login_to":{"type":"string","format":"date-time","description":"Upper bound filter for last successful login time."},"sort_by":{"oneOf":[{"const":"email","description":"Sorting key. Specifies which field to sort the user list by. Acceptable values reference indexed columns in todo_list_users."},{"const":"created_at","description":"Sorting key. Specifies which field to sort the user list by. Acceptable values reference indexed columns in todo_list_users."},{"const":"last_login_at","description":"Sorting key. Specifies which field to sort the user list by. Acceptable values reference indexed columns in todo_list_users."},{"const":"name","description":"Sorting key. Specifies which field to sort the user list by. Acceptable values reference indexed columns in todo_list_users."},{"const":"status","description":"Sorting key. Specifies which field to sort the user list by. Acceptable values reference indexed columns in todo_list_users."}],"description":"Sorting key. Specifies which field to sort the user list by. Acceptable values reference indexed columns in todo_list_users."},"direction":{"oneOf":[{"const":"asc","description":"Sort order for listed users (ascending or descending). Default is descending for most recent-first orderings."},{"const":"desc","description":"Sort order for listed users (ascending or descending). Default is descending for most recent-first orderings."}],"description":"Sort order for listed users (ascending or descending). Default is descending for most recent-first orderings."},"page":{"type":"integer","minimum":1,"description":"Page number for paginated results, starting from 1. If omitted, defaults to 1."},"limit":{"type":"integer","minimum":1,"maximum":100,"description":"Maximum number of records per page. Default and maximum values subject to business rules."},"search":{"type":"string","description":"Free-text search term matching the user's name or email using text search index. Implements fuzzy/generic lookup in admin user queries."}},"description":"Advanced search, filtering, and pagination interface for admin APIs listing user accounts from todo_list_users. All properties correspond to columns or indexed fields in the user Prisma schema. Used for compliance reviews, operational dashboard queries, and administrative account management.","required":[]},"ITodoListUser":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"User's UUID primary key from todo_list_users.id."},"email":{"type":"string","format":"email","description":"Unique email for login and notifications (see Prisma todo_list_users.email)."},"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Display name of user (nullable)."},"avatar_uri":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Profile/avatar image URL, up to 80,000 characters; nullable."},"status":{"type":"string","description":"Current account status for business, lifecycle, or compliance (see Prisma 'status')."},"last_login_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Datetime of most recent successful login (null if never logged in)."},"created_at":{"type":"string","format":"date-time","description":"User record creation (UTC ISO 8601)."},"updated_at":{"type":"string","format":"date-time","description":"Most recent update timestamp."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp for soft deletion; null if not deleted. Used for regulatory compliance and retention controls."}},"required":["id","email","status","created_at","updated_at"],"description":"Full user profile, matching todo_list_users schema except for sensitive credentials. Used in admin dashboards, session authentication, and compliance. All business/deletion metadata included for audit and support visibility."},"ITodoListUser.IUpdate":{"type":"object","properties":{"email":{"type":"string","description":"Update the user's login email. Must pass business rules for uniqueness (across todo_list_users) and valid email formatting. Subject to permission restrictions."},"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Update to the user's display name. May be cleared (null) by admin. Adheres to naming/length business rules."},"avatar_uri":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Update the user's avatar/profile image URI. Null value removes avatar."},"status":{"type":"string","description":"Update the user's account status (e.g., activate, lock, suspend, disable). Only accessible to admin or system logic. Must conform to defined state values."},"password_hash":{"type":"string","description":"Update the user's password credential (stored as a bcrypt/argon2 hash). Only permitted by admin or dedicated credential reset endpoints."}},"description":"Admin or system interface to update permitted user fields on a todo_list_users row. Password hash and email updates require extra validation (uniqueness and security). All fields are optional (Partial<T> pattern). Used in PUT /users/{userId} for admin account maintenance.","required":[]},"ITodoListAdmin.IRequest":{"type":"object","properties":{"email":{"type":"string","description":"Admin login email filter. Restricts the listing to records with a matching email address (exact or partial match depending on UI/business rules)."},"name":{"type":"string","description":"Partial or full display name search filter for the admin listing."},"privilege_level":{"type":"string","description":"Filter for the admin privilege level (e.g., superadmin, support). Only returns records matching this privilege."},"status":{"type":"string","description":"Filter by current admin account status (active, suspended, etc.)."},"created_from":{"type":"string","format":"date-time","description":"Include only admins created after or at this UTC date-time. Format matches ISO 8601."},"created_to":{"type":"string","format":"date-time","description":"Include only admins created before or at this date."},"last_login_from":{"type":"string","format":"date-time","description":"Lower bound for last successful admin login, UTC."},"last_login_to":{"type":"string","format":"date-time","description":"Upper bound for last admin login, UTC."},"sort_by":{"oneOf":[{"const":"email","description":"Key to sort the admin list responses. Only pre-indexed fields allowed."},{"const":"created_at","description":"Key to sort the admin list responses. Only pre-indexed fields allowed."},{"const":"last_login_at","description":"Key to sort the admin list responses. Only pre-indexed fields allowed."},{"const":"name","description":"Key to sort the admin list responses. Only pre-indexed fields allowed."},{"const":"status","description":"Key to sort the admin list responses. Only pre-indexed fields allowed."},{"const":"privilege_level","description":"Key to sort the admin list responses. Only pre-indexed fields allowed."}],"description":"Key to sort the admin list responses. Only pre-indexed fields allowed."},"direction":{"oneOf":[{"const":"asc","description":"Sort direction (ascending or descending)."},{"const":"desc","description":"Sort direction (ascending or descending)."}],"description":"Sort direction (ascending or descending)."},"page":{"type":"integer","minimum":1,"description":"Page number of the results, starting from 1."},"limit":{"type":"integer","minimum":1,"maximum":100,"description":"Number of admin records per result page. Bounded by business rules."},"search":{"type":"string","description":"Free-text search over admin name or email fields using full text index."}},"description":"Advanced search/filter, sorting, and pagination interface for listing admin users in the todo_list_admins table. Supports operational dashboards and compliance discovery endpoints.","required":[]},"ITodoListAdmin.IUpdate":{"type":"object","properties":{"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional new display name for admin profile.\n\nAdmin may update their profile name for easier identification in audit logs and dashboards. Mirrors the `name` column in `todo_list_admins`. Null clears profile display name."},"avatar_uri":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional new avatar image URL.\n\nUpdates the `avatar_uri` (profile picture) in `todo_list_admins`. Used for UI personalization; null value removes existing image."},"status":{"type":"string","description":"Optional new account status (e.g., active, suspended, locked).\n\nControls account accessibility for privileges. From `status` in `todo_list_admins`. Must follow valid values established by business logic."},"privilege_level":{"type":"string","description":"Optional new privilege_level (e.g., superadmin, support, auditor).\n\nAlters admin access rights and operational authority. Mirrors the `privilege_level` field in `todo_list_admins`."}},"required":[],"description":"Profile/status update DTO for an administrator account.\n\nAllows patching the name, avatar, status, or privilege_level for an admin via admin management UIs or operational workflows. Credential changes are not permitted here (see dedicated credential endpoints). Ensures controlled evolution of admin state in compliance with business and audit constraints."},"ITodoListTodo.IRequest":{"type":"object","properties":{"search":{"type":"string","description":"Text search filter for todo content (partial, case-insensitive).\n\nAllows keyword looking up across `content` field. Trims whitespace and ignores blank queries. Reference for productivity/task filtering in UI."},"completed":{"type":"boolean","description":"Optional: filter todos by completion state (true = only completed, false = only uncompleted).\n\nMaps to `completed` property of `todo_list_todos`. Used for filtering user's list by finished or unfinished tasks."},"due_date":{"type":"string","format":"date-time","description":"Optional: ISO8601 query for todos due on a specific day/date.\n\nFilters tasks whose `due_date` matches the provided value. Null or absent means no due date filtering."},"page":{"type":"integer","description":"Page number for pagination (1-based, default 1).\n\nUsed in paginated APIs for returning a subset (chunk) of the todo list. Applies to `todo_list_todos` listing endpoints, helping users and admins navigate large task sets."},"limit":{"type":"integer","description":"Number of records per page (default 20).\n\nAdjusts API result set size for productivity and performance. Linked to UI page size and user preference. Maps to corresponding limits in business policy."},"sort":{"type":"string","description":"Optional: sort order for query results (e.g., 'created_at:desc', 'due_date:asc').\n\nChanges the record order of listed todos. Defaults to business-defined sort (usually most recent first)."}},"required":[],"description":"Request DTO for searching/filtering user's todos (todo_list_todos).\n\nSupports advanced query parameters, including free-text content search, completion status filter, optional due date, pagination, and sort order. Used in user and admin task list endpoints to retrieve precisely the subset of tasks relevant for a specific operational context. Each parameter maps directly to a Prisma schema column for query safety."},"ITodoListTodo":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the todo record (UUID).\n\nServes as the primary key for referencing, updating, and deletion. Maps to `id` in `todo_list_todos`."},"todo_list_user_id":{"type":"string","format":"uuid","description":"Owner's user id (UUID).\n\nCorrelates the todo to its creator or owner (`todo_list_users.id`). Enforces row-level authorization and is used for partitioning user data and privacy enforcement."},"content":{"type":"string","description":"Main textual content for the todo (1-255 chars, trimmed, required).\n\nDirectly references the `content` column in `todo_list_todos`. All business validation performed here (no control characters, trimmed of whitespace, non-empty)."},"due_date":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional due date (ISO8601 date string).\n\nReferences the `due_date` in `todo_list_todos`. Nullable—null means no due date assigned. Used in UI and productivity features."},"completed":{"type":"boolean","description":"Is this todo completed?\n\nMaps to `completed` in `todo_list_todos`. True when marked as done by the user; false when active/incomplete. Drives productivity and progress logic."},"completed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp this todo was marked complete (null if not completed).\n\nReferences `completed_at` in `todo_list_todos`. Enables tracking completions for analytics and business reporting; null if active/uncompleted."},"created_at":{"type":"string","format":"date-time","description":"Created timestamp (UTC, ISO8601).\n\nRepresents the time when this todo was created (from `created_at` in `todo_list_todos`). Important for sorting, queries, and user timeline presentation."},"updated_at":{"type":"string","format":"date-time","description":"Last modification timestamp (UTC, ISO8601).\n\nTracks most recent updates to todo state or content (from `updated_at` in `todo_list_todos`). Used for timestamp-based queries and UI freshness indicators."}},"required":["id","todo_list_user_id","content","completed","created_at","updated_at"],"description":"Detailed representation of a single todo item, as defined in the `todo_list_todos` table.\n\nContains all user-owned task fields, metadata, and ownership. Used both for operational endpoints (retrieve, update, delete) and for returned data in listing, search, and reporting APIs. Fields track ownership, content, completion status, optional due date, and timing. All business constraints reflected here for enforcement of data correctness, privacy, and productivity rules."},"ITodoListTodo.ICreate":{"type":"object","properties":{"content":{"type":"string","maxLength":255,"description":"Main todo text, required. Must be trimmed, non-empty, maximum 255 characters, and not solely composed of whitespace or control characters. All entries are validated according to the business and database rules described in the functional requirements and Prisma schema column comments."},"due_date":{"oneOf":[{"type":"string","format":"date","description":"Optional due date for this todo in ISO 8601 yyyy-mm-dd format. May be null or omitted if unset. Business logic enforces date must be today or future; past dates are invalid."},{"type":"null"}],"description":"An optional due date for the todo. If not provided or null, the todo has no deadline. Must follow ISO format and cannot precede the todo's creation date."}},"required":["content"],"description":"Request body structure for creating a new todo item. This type defines the minimal content required by the todo list business rules and validation logic. The only required property is \"content\"; \"due_date\" is optional and must meet date validation if present. Ownership, completion, and timestamps are assigned by system logic."},"ITodoListTodo.IUpdate":{"type":"object","properties":{"content":{"type":"string","maxLength":255,"description":"Optional new content for this todo. If provided, it must be trimmed and non-empty, with no control characters, and up to 255 characters. Any update to this field must meet business validation (see functional requirements and schema docs)."},"due_date":{"oneOf":[{"type":"string","format":"date","description":"Optional new due date (ISO 8601 yyyy-mm-dd), must be today or a future date. Null if removing due date."},{"type":"null"}],"description":"Optional due date update for the todo. Null means remove the deadline. Must follow ISO 8601 format and cannot be set before todo creation."},"completed":{"type":"boolean","description":"If present, instructs the system to mark the todo as completed (true) or uncompleted (false). Omitted means no change."}},"required":[],"description":"Partial update type for a todo item. All fields are optional—only those present are changed. Ownership, id, and system meta fields are never accepted or updatable via this type. All changes undergo business rule and database schema validation."},"ITodoListAuditLog.IRequest":{"type":"object","properties":{"todo_list_admin_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional filter by acting admin id (uuid). Only audit logs matching this admin will be included if provided. Null or omitted means no filter."},"todo_list_user_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional filter by user id (uuid); selects logs associated with actions against this user. Null/omitted means any user."},"todo_list_todo_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional filter by todo id; restricts listing to actions on a specific todo. Null/omitted = no filter."},"action":{"oneOf":[{"const":"view"},{"const":"delete"},{"type":"null"}],"description":"Optional filter for action type; \"view\" or \"delete\". Null/omitted means any action."},"rationale":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional substring or keyword for rationale text filtering. Null or omitted disables content search."},"from":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional filter for audit logs created at or after this ISO date-time. Null means no lower bound."},"to":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional filter for audit logs created before or at this ISO date-time. Null means no upper bound."},"page":{"oneOf":[{"type":"integer","minimum":1},{"type":"null"}],"description":"Optional page number for pagination (1 = first). Default is 1."},"limit":{"oneOf":[{"type":"integer","minimum":1,"maximum":100},{"type":"null"}],"description":"Optional per-page limit (max 100). Default is 20."},"sort":{"oneOf":[{"const":"created_at"},{"const":"action"},{"const":"todo_list_admin_id"},{"const":"todo_list_user_id"},{"const":"todo_list_todo_id"},{"type":"null"}],"description":"Optional sort field. Typical values: created_at (default), action, admin/user ids. Null or omitted defaults to descending by created_at."},"direction":{"oneOf":[{"const":"asc"},{"const":"desc"},{"type":"null"}],"description":"Sort direction: \"asc\" for ascending, \"desc\" for descending; null/omitted for default ('desc')."}},"description":"Filtering and pagination input for audit log searching. All fields are optional and mutually combinable. Supports robust admin/operational compliance search as described in business requirements.","required":[]},"ITodoListAuditLog":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for this audit log entry (matches id column in todo_list_audit_logs table)."},"todo_list_admin_id":{"type":"string","format":"uuid","description":"ID of the admin who performed the action (FK to todo_list_admins)."},"todo_list_user_id":{"type":"string","format":"uuid","description":"ID of the user whose todo was affected (FK to todo_list_users)."},"todo_list_todo_id":{"type":"string","format":"uuid","description":"ID of the todo item affected (FK to todo_list_todos)."},"action":{"oneOf":[{"const":"view","description":"The type of admin action on the todo—either 'view' or 'delete'; as defined in business rules and schema."},{"const":"delete","description":"The type of admin action on the todo—either 'view' or 'delete'; as defined in business rules and schema."}],"description":"The type of admin action on the todo—either 'view' or 'delete'; as defined in business rules and schema."},"rationale":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional free-form explanation or business rationale for the action; may be null or empty if not supplied."},"created_at":{"type":"string","format":"date-time","description":"Timestamp for when the audit log was created (audit trail)."}},"required":["id","todo_list_admin_id","todo_list_user_id","todo_list_todo_id","action","created_at"],"description":"Core audit log entity component, representing a single admin action on a user's todo (view or delete). All fields map directly to the todo_list_audit_logs table. Used for compliance, business monitoring, and security reviews."},"ITodoListAdmin.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique admin identifier (UUID). Reference to todo_list_admins.id in database. Used as the primary key for all administrator business actions and audit trails."},"email":{"type":"string","format":"email","description":"Admin account login email. Must be unique among all administrators. Used in admin authentication, notifications, and operations. Reference: todo_list_admins.email."},"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Display name of the administrator for UI and management purposes. Nullable and optional. Pulled from todo_list_admins.name."},"avatar_uri":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Administrator profile/avatar image URL. May be displayed in dashboards/logs. Optional and nullable. Reference: todo_list_admins.avatar_uri."},"status":{"type":"string","description":"Operational status of the admin account (e.g., 'active', 'suspended'). Reference: todo_list_admins.status. Used for authorization checks."},"privilege_level":{"type":"string","description":"Business privilege level for this admin (e.g., 'superadmin', 'support'). Used to differentiate capability and access areas. Reference: todo_list_admins.privilege_level."},"last_admin_action_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp of most recent privileged admin operation (ISO 8601 UTC). May be null if no actions yet. Reference: todo_list_admins.last_admin_action_at."},"last_login_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the admin last logged into their account (ISO 8601 UTC). Null if not yet logged in. Reference: todo_list_admins.last_login_at."},"created_at":{"type":"string","format":"date-time","description":"Admin account creation timestamp (ISO 8601 UTC). Used for onboarding/audit. Reference: todo_list_admins.created_at."}},"required":["id","email","status","privilege_level","created_at"],"description":"Summary record for an administrator account. Used in admin dashboard search, compliance listings, or management tables. Contains no authentication or password fields; only business metadata required for high-level views. All fields align with todo_list_admins schema definition and reflect administrative privilege without leaking security-sensitive fields. For full detail views or editing, use the main ITodoListAdmin schema."},"ITodoListTodo.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier (UUID) for the todo. Reference: todo_list_todos.id. Used for access, updates, and deletion."},"content":{"type":"string","maxLength":255,"description":"Main textual content of the todo. Required, plain text (no formatting). Must be 1–255 characters (business rule). Reference: todo_list_todos.content."},"due_date":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional due date for the todo (ISO 8601 format). Null if not set. Reference: todo_list_todos.due_date."},"completed":{"type":"boolean","description":"Whether this todo is marked as completed. Business rule: must default to false when created. Reference: todo_list_todos.completed."},"completed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp of when this todo was completed (ISO 8601 UTC). Null if incomplete. Reference: todo_list_todos.completed_at."},"created_at":{"type":"string","format":"date-time","description":"When the todo was created (ISO 8601 UTC). Used for sorting and audit. Reference: todo_list_todos.created_at."}},"required":["id","content","completed","created_at"],"description":"Summary object for a todo task. Designed for list/search view in todo lists. Derived from todo_list_todos table fields, omitting user_id/owner, update timestamp, and audit details. Contains all user-visible aspects needed for standard UI views or admin search, but no security or meta fields. Ensures business rule compliance on content length."},"ITodoListAuditLog.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key for this audit log record (todo_list_audit_logs.id). Unique identifier for finding this row in logs and audit trails."},"todo_list_admin_id":{"type":"string","format":"uuid","description":"ID (UUID) of admin account who performed the action. Reference to todo_list_admins.id. Used for cross-linking between audit log and admin records."},"todo_list_user_id":{"type":"string","format":"uuid","description":"ID (UUID) of the user whose todo was targeted. Reference: todo_list_users.id. Ensures traceability to the individual whose data was affected."},"todo_list_todo_id":{"type":"string","format":"uuid","description":"ID (UUID) of the todo item upon which the admin acted. Reference: todo_list_todos.id. Enables tracing the target of the admin action."},"action":{"oneOf":[{"const":"view","description":"Admin action performed on the todo. Enum values: 'view' (admin viewed todo), 'delete' (admin deleted todo). Business rule: Only these actions are allowed in the schema for audit logging purposes."},{"const":"delete","description":"Admin action performed on the todo. Enum values: 'view' (admin viewed todo), 'delete' (admin deleted todo). Business rule: Only these actions are allowed in the schema for audit logging purposes."}],"description":"Admin action performed on the todo. Enum values: 'view' (admin viewed todo), 'delete' (admin deleted todo). Business rule: Only these actions are allowed in the schema for audit logging purposes."},"rationale":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional explanation entered by the admin justifying this action. Free text (nullable). Useful for compliance review. Reference: todo_list_audit_logs.rationale."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when this admin action occurred (ISO 8601 UTC). Reference: todo_list_audit_logs.created_at."}},"required":["id","todo_list_admin_id","todo_list_user_id","todo_list_todo_id","action","created_at"],"description":"Summary record for a single admin audit log entry. Used in filters/searches on audit_log lists. Includes all core references for tracking which admin did what, to which user/todo, for what action (with optional rationale). Pulled from todo_list_audit_logs schema, ensuring full traceability for compliance without exposing unrelated or sensitive records."}}}},"created_at":"2025-09-23T05:55:22.714Z","completed_at":"2025-09-23T06:04:29.248Z","step":0},{"type":"test","id":"01997532-a950-73fe-bdc2-7e1683d35c64","reason":"Validate agent test","files":[{"scenario":{"endpoint":{"path":"/auth/user/join","method":"post"},"draft":"Scenario covers registering a new user with a unique email and valid password. Steps include submitting registration data; verifying success, JWT tokens, and returned user context; ensuring that only schema-defined fields are accepted and initial status is correct. Validation: registration succeeds, token issued, returned object structure matches business rules.","functionName":"test_api_user_account_registration_new_unique_email","dependencies":[]},"location":"test/features/api/auth/test_api_user_account_registration_new_unique_email.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate registering a new user account with a unique email.\n *\n * Ensures the /auth/user/join endpoint:\n *\n * - Accepts unique email, valid password, and optional profile fields.\n * - Returns ITodoListUser.IAuthorized with both JWT tokens and user profile.\n * - Sets user status correctly; does not reveal sensitive credential info\n *   (password).\n * - Only schema-approved fields present in response.\n *\n * Steps:\n *\n * 1. Generate unique email and valid password, optionally set name and avatar_uri.\n * 2. Register user via api.functional.auth.user.join.\n * 3. Typia.assert structure; validate JWT token and profile fields.\n * 4. Check returned user context fields match input values and business rules.\n * 5. Confirm status == 'active'.\n * 6. Ensure response does not leak password and no extra fields are returned.\n */\nexport async function test_api_user_account_registration_new_unique_email(\n  connection: api.IConnection,\n) {\n  // 1. Prepare unique registration input\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(12);\n  const name = RandomGenerator.name(2);\n  const avatar_uri = undefined;\n\n  const requestBody = {\n    email,\n    password,\n    name,\n    avatar_uri,\n  } satisfies ITodoListUser.IJoin;\n\n  // 2. Register the user\n  const result = await api.functional.auth.user.join(connection, {\n    body: requestBody,\n  });\n  typia.assert(result);\n\n  // 3. Validate token structure\n  typia.assert(result.token);\n  TestValidator.predicate(\n    \"access token exists\",\n    typeof result.token.access === \"string\" && result.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"refresh token exists\",\n    typeof result.token.refresh === \"string\" && result.token.refresh.length > 0,\n  );\n  TestValidator.predicate(\n    \"expired_at is ISO date-time\",\n    typeof result.token.expired_at === \"string\" &&\n      /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d+)?Z/.test(\n        result.token.expired_at,\n      ),\n  );\n  TestValidator.predicate(\n    \"refreshable_until is ISO date-time\",\n    typeof result.token.refreshable_until === \"string\" &&\n      /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d+)?Z/.test(\n        result.token.refreshable_until,\n      ),\n  );\n\n  // 4. Validate returned user profile\n  typia.assert(result.user);\n  TestValidator.equals(\"user email matches input\", result.user.email, email);\n  TestValidator.equals(\"user name matches input\", result.user.name, name);\n  TestValidator.equals(\n    \"user avatar_uri matches input\",\n    result.user.avatar_uri,\n    avatar_uri,\n  );\n  TestValidator.predicate(\n    \"user id is UUID\",\n    typeof result.user.id === \"string\" &&\n      /^[0-9a-f-]{36}$/i.test(result.user.id),\n  );\n  TestValidator.predicate(\n    \"user created_at is date-time\",\n    typeof result.user.created_at === \"string\" &&\n      result.user.created_at.length > 10,\n  );\n  TestValidator.predicate(\n    \"user updated_at is date-time\",\n    typeof result.user.updated_at === \"string\" &&\n      result.user.updated_at.length > 10,\n  );\n\n  // 5. Check account initial status (likely 'active' or business policy)\n  TestValidator.equals(\"user status is 'active'\", result.user.status, \"active\");\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/join","method":"post"},"draft":"Scenario covers attempting to register a new user with an email that already exists in the system (matching todo_list_users.email). Steps: register the first user successfully, attempt a second registration using the same email. Validation: the second attempt fails with a business error per unique constraint, revealing no sensitive information about existing accounts.","functionName":"test_api_user_account_registration_duplicate_email","dependencies":[]},"location":"test/features/api/auth/test_api_user_account_registration_duplicate_email.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate that duplicate user registration by email is rejected.\n *\n * 1. Register a first user successfully with a random email/password.\n * 2. Attempt to register a second user with the same email (different password).\n * 3. Validate that the second attempt fails due to unique constraint (business\n *    error), and no sensitive information is revealed.\n */\nexport async function test_api_user_account_registration_duplicate_email(\n  connection: api.IConnection,\n) {\n  // Register the first user\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password1 = RandomGenerator.alphaNumeric(12);\n  const joinBody1 = {\n    email,\n    password: password1,\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n  } satisfies ITodoListUser.IJoin;\n  const user1 = await api.functional.auth.user.join(connection, {\n    body: joinBody1,\n  });\n  typia.assert(user1);\n  TestValidator.equals(\"registered email matches\", user1.user.email, email);\n\n  // Attempt to register another user with the same email\n  const password2 = RandomGenerator.alphaNumeric(12);\n  const joinBody2 = {\n    email,\n    password: password2,\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n  } satisfies ITodoListUser.IJoin;\n  await TestValidator.error(\n    \"second registration attempt with duplicate email fails\",\n    async () => {\n      await api.functional.auth.user.join(connection, { body: joinBody2 });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/login","method":"post"},"draft":"Tests the login process for an existing user with correct email and password. Steps: register a user first, then log in using those credentials. Validates success response, issuance of access and refresh JWT, and user role/context in session. Also checks that last_login_at is updated appropriately.","functionName":"test_api_user_login_with_valid_credentials","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create a new user account to enable login with valid credentials"}]},"location":"test/features/api/auth/test_api_user_login_with_valid_credentials.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Tests the login process for an existing user with correct email and password.\n *\n * 1. Register a new user with random email and password.\n * 2. Log in with the same credentials.\n * 3. Validate that login succeeds and the returned tokens are well-formed.\n * 4. Ensure the user id is the same in both join and login responses.\n * 5. Assert last_login_at is present, non-null, and correctly formatted in login\n *    response.\n * 6. Check that a new access token is issued after login (tokens differ).\n */\nexport async function test_api_user_login_with_valid_credentials(\n  connection: api.IConnection,\n) {\n  // 1. Prepare unique credentials for a test user\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = typia.random<string>();\n  const name = RandomGenerator.name();\n\n  // 2. Register a user\n  const joinResp = await api.functional.auth.user.join(connection, {\n    body: {\n      email,\n      password,\n      name,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(joinResp);\n\n  // 3. Login with those credentials\n  const loginResp = await api.functional.auth.user.login(connection, {\n    body: {\n      email,\n      password,\n    } satisfies ITodoListUser.ILogin,\n  });\n  typia.assert(loginResp);\n\n  // 4. Validate session token structure\n  typia.assert<IAuthorizationToken>(loginResp.token);\n  TestValidator.predicate(\n    \"login access token is non-empty string\",\n    typeof loginResp.token.access === \"string\" &&\n      loginResp.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"login refresh token is non-empty string\",\n    typeof loginResp.token.refresh === \"string\" &&\n      loginResp.token.refresh.length > 0,\n  );\n\n  // 5. User ID must be identical for both join and login\n  TestValidator.equals(\n    \"user id matches between join and login\",\n    loginResp.user.id,\n    joinResp.user.id,\n  );\n  typia.assert<ITodoListUser>(loginResp.user);\n  TestValidator.predicate(\n    \"last_login_at is present and non-null\",\n    !!loginResp.user.last_login_at,\n  );\n  TestValidator.predicate(\n    \"last_login_at is valid ISO date-time\",\n    typeof loginResp.user.last_login_at === \"string\" &&\n      /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(loginResp.user.last_login_at!),\n  );\n\n  // 6. Confirm new JWT access token is issued after login\n  TestValidator.notEquals(\n    \"JWT access tokens should differ after join and login\",\n    loginResp.token.access,\n    joinResp.token.access,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/login","method":"post"},"draft":"Tests login attempt with a valid email but incorrect password. Steps: register a user, attempt login with wrong password. Validates standardized error response with no leakage of which field was incorrect.","functionName":"test_api_user_login_with_invalid_password","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create a user account to test login failure with invalid credentials"}]},"location":"test/features/api/auth/test_api_user_login_with_invalid_password.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test login with a valid user email but incorrect password.\n *\n * 1. Register a user with a specific email and password\n * 2. Attempt to log in with the same email but a wrong password\n * 3. Validate that the login fails and system returns a generic error (no\n *    credential leakage)\n */\nexport async function test_api_user_login_with_invalid_password(\n  connection: api.IConnection,\n) {\n  // Step 1: Register a new user with known password\n  const userEmail = typia.random<string & tags.Format<\"email\">>();\n  const correctPassword = RandomGenerator.alphaNumeric(12);\n\n  const joinBody = {\n    email: userEmail,\n    password: correctPassword,\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n  } satisfies ITodoListUser.IJoin;\n\n  const authorized = await api.functional.auth.user.join(connection, {\n    body: joinBody,\n  });\n  typia.assert(authorized);\n\n  // Step 2: Attempt to log in with valid email but incorrect password\n  const loginBody = {\n    email: userEmail,\n    password: correctPassword + \"_wrong\", // makes it incorrect\n  } satisfies ITodoListUser.ILogin;\n\n  // Step 3: Validate that login attempts with wrong password should fail with generic error, not leaking details\n  await TestValidator.error(\n    \"login with valid email but invalid password is rejected\",\n    async () => {\n      await api.functional.auth.user.login(connection, { body: loginBody });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/refresh","method":"post"},"draft":"Tests the refresh token workflow for an authenticated user. Steps: register a user, log in to obtain refresh token, then use that token on refresh endpoint. Validates issuance of new tokens and that the account is still active. Handles response verification for valid scenario.","functionName":"test_api_user_refresh_token_valid","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Register a new user to test refresh token when authenticated"},{"endpoint":{"method":"post","path":"/auth/user/login"},"purpose":"Obtain valid JWT refresh token after user account creation"}]},"location":"test/features/api/auth/test_api_user_refresh_token_valid.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validates the refresh token workflow for an authenticated user.\n *\n * 1. Register a new user via the join endpoint using random valid credentials.\n * 2. Log in as the user to obtain a valid refresh token.\n * 3. Use the refresh token to call /auth/user/refresh and obtain new tokens.\n * 4. Assert that the returned data conforms to ITodoListUser.IAuthorized, tokens\n *    are valid and not the same as before, and the user account remains active\n *    and unchanged.\n *\n * Ensures the refresh endpoint works according to contract and tokens rotate as\n * expected.\n */\nexport async function test_api_user_refresh_token_valid(\n  connection: api.IConnection,\n) {\n  // Step 1: Register user\n  const joinBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12),\n    name: RandomGenerator.name(),\n    avatar_uri: null as string | null | undefined,\n  } satisfies ITodoListUser.IJoin;\n\n  const joined = await api.functional.auth.user.join(connection, {\n    body: joinBody,\n  });\n  typia.assert(joined);\n\n  // Step 2: Log in to obtain refresh token\n  const loginBody = {\n    email: joinBody.email,\n    password: joinBody.password,\n  } satisfies ITodoListUser.ILogin;\n\n  const loginResult = await api.functional.auth.user.login(connection, {\n    body: loginBody,\n  });\n  typia.assert(loginResult);\n  TestValidator.equals(\n    \"login user id matches joined user\",\n    loginResult.id,\n    joined.id,\n  );\n  TestValidator.equals(\n    \"login user email matches\",\n    loginResult.user.email,\n    joinBody.email,\n  );\n  TestValidator.equals(\n    \"login status active\",\n    loginResult.user.status,\n    \"active\",\n  );\n\n  // Step 3: Call refresh endpoint with refresh_token\n  const refreshBody = {\n    refresh_token: loginResult.token.refresh,\n  } satisfies ITodoListUser.IRefresh;\n  const refreshResult = await api.functional.auth.user.refresh(connection, {\n    body: refreshBody,\n  });\n  typia.assert(refreshResult);\n  // Step 4: Validate new tokens and user info\n  TestValidator.equals(\n    \"refresh user id matches login id\",\n    refreshResult.id,\n    loginResult.id,\n  );\n  TestValidator.equals(\n    \"refresh user email matches\",\n    refreshResult.user.email,\n    loginResult.user.email,\n  );\n  TestValidator.equals(\n    \"refresh status active\",\n    refreshResult.user.status,\n    \"active\",\n  );\n  TestValidator.notEquals(\n    \"access token must change on refresh\",\n    refreshResult.token.access,\n    loginResult.token.access,\n  );\n  TestValidator.notEquals(\n    \"refresh token must change on refresh\",\n    refreshResult.token.refresh,\n    loginResult.token.refresh,\n  );\n  TestValidator.predicate(\n    \"refreshed tokens not null\",\n    !!refreshResult.token.access && !!refreshResult.token.refresh,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/refresh","method":"post"},"draft":"Covers the scenario where the user attempts to refresh with an expired or tampered refresh token. Steps: submit an invalid or expired refresh token. Validates business error response, denial of new token issuance, and appropriate error format that does not expose internal details.","functionName":"test_api_user_refresh_token_expired_or_invalid","dependencies":[]},"location":"test/features/api/auth/test_api_user_refresh_token_expired_or_invalid.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Verifies that token refresh is rejected for expired or tampered refresh\n * tokens.\n *\n * Scenario:\n *\n * - A user attempts to refresh authentication using a refresh token that is\n *   either expired or has been tampered with (invalid).\n * - The API must deny the request, not issue any token, and return a business\n *   error response without disclosing internal error details.\n *\n * Steps:\n *\n * 1. Attempt refresh with an obviously expired (or random, simulating expired)\n *    refresh token.\n * 2. Attempt refresh with a tampered, clearly invalid refresh token (e.g., random\n *    string that is not a JWT).\n * 3. For each, validate that the API returns an error, does NOT return a user\n *    authorization structure, and that the error response format is proper\n *    (does not disclose server internals).\n */\nexport async function test_api_user_refresh_token_expired_or_invalid(\n  connection: api.IConnection,\n) {\n  // 1. Attempt with an obviously expired or invalid refresh token (simulate by using a random long string)\n  const expiredToken = RandomGenerator.alphaNumeric(128);\n  await TestValidator.error(\n    \"should reject expired refresh token and not issue a new token\",\n    async () => {\n      await api.functional.auth.user.refresh(connection, {\n        body: { refresh_token: expiredToken } satisfies ITodoListUser.IRefresh,\n      });\n    },\n  );\n\n  // 2. Attempt with a tampered (malformed) refresh token (simulate by clear garbage data)\n  const tamperedToken = \"not_a_valid_token\";\n  await TestValidator.error(\n    \"should reject tampered refresh token and not issue a new token\",\n    async () => {\n      await api.functional.auth.user.refresh(connection, {\n        body: { refresh_token: tamperedToken } satisfies ITodoListUser.IRefresh,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/join","method":"post"},"draft":"Verifies administrator registration using a new, unique email. Steps: submit valid registration details for an admin; ensure that the admin account is created, JWT token issued with correct admin role/privileges, only schema-defined fields are accepted, and initial status is set properly. Validates business error handling for incorrect or missing fields.","functionName":"test_api_admin_account_registration_new_unique_email","dependencies":[]},"location":"test/features/api/auth/test_api_admin_account_registration_new_unique_email.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Verifies administrator registration using a new, unique email, and covers\n * happy path with minimal and maximal inputs, as well as business error logic\n * for duplicate email. No type error/missing required field testing is\n * included, in accordance with strict type safety and absolute prohibition on\n * type error validation.\n *\n * Steps:\n *\n * 1. Generate a unique business admin email and valid password, and perform\n *    registration supplying all ITodoListAdmin.IJoin fields (email,\n *    password_hash, name, avatar_uri, status, privilege_level).\n *\n *    - Assert the returned ITodoListAdmin.IAuthorized has a non-empty JWT token,\n *         correct admin email, and privilege/state as supplied.\n * 2. Repeat with only required fields (email and password_hash). Assert that\n *    returned admin is created with a unique id, that status and\n *    privilege_level are set by system defaults, and the email matches.\n * 3. Validate business logic error by attempting to re-register with a previously\n *    registered email (duplicate), expecting a handled business error. All\n *    TestValidator assertions use a descriptive title. No header or DTO field\n *    not in schema is touched. All API calls are properly awaited and\n *    validated.\n */\nexport async function test_api_admin_account_registration_new_unique_email(\n  connection: api.IConnection,\n) {\n  // 1. Happy path: all fields supplied (maximal registration)\n  const uniqueEmail = `${RandomGenerator.alphabets(10)}@business-e2e.com`;\n  const password = RandomGenerator.alphaNumeric(16);\n  const joinBody = {\n    email: uniqueEmail,\n    password_hash: password,\n    name: RandomGenerator.name(),\n    avatar_uri: `https://cdn.e2e.com/avatar/${RandomGenerator.alphaNumeric(12)}`,\n    status: \"active\",\n    privilege_level: \"support\",\n  } satisfies ITodoListAdmin.IJoin;\n\n  const authorized = await api.functional.auth.admin.join(connection, {\n    body: joinBody,\n  });\n  typia.assert(authorized);\n  typia.assert(authorized.token);\n  typia.assert(authorized.admin);\n  TestValidator.equals(\n    \"admin email matches\",\n    authorized.admin.email,\n    uniqueEmail,\n  );\n  TestValidator.equals(\n    \"admin privilege matches\",\n    authorized.admin.privilege_level,\n    \"support\",\n  );\n  TestValidator.equals(\n    \"admin status matches\",\n    authorized.admin.status,\n    \"active\",\n  );\n\n  // 2. Happy path: only required fields (minimal registration)\n  const minimalEmail = `${RandomGenerator.alphabets(12)}@business-e2e.com`;\n  const minimalBody = {\n    email: minimalEmail,\n    password_hash: RandomGenerator.alphaNumeric(16),\n  } satisfies ITodoListAdmin.IJoin;\n  const authorized2 = await api.functional.auth.admin.join(connection, {\n    body: minimalBody,\n  });\n  typia.assert(authorized2);\n  TestValidator.equals(\n    \"admin email matches min\",\n    authorized2.admin.email,\n    minimalEmail,\n  );\n  TestValidator.predicate(\n    \"admin privilege_level generated\",\n    typeof authorized2.admin.privilege_level === \"string\" &&\n      authorized2.admin.privilege_level.length > 0,\n  );\n  TestValidator.predicate(\n    \"admin status generated\",\n    typeof authorized2.admin.status === \"string\" &&\n      authorized2.admin.status.length > 0,\n  );\n\n  // 3. Business error: duplicate email registration\n  await TestValidator.error(\"duplicate email fails\", async () => {\n    await api.functional.auth.admin.join(connection, { body: joinBody });\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/join","method":"post"},"draft":"Covers business rule for admin registration with a duplicate email. Steps: register the first admin successfully, then attempt registering a second admin account with the same email address. Validates that the second registration fails per unique constraint and returns a business error with no sensitive account information disclosed.","functionName":"test_api_admin_account_registration_duplicate_email","dependencies":[]},"location":"test/features/api/auth/test_api_admin_account_registration_duplicate_email.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validates admin registration forbidden with duplicate email.\n *\n * 1. Generate a random (unique) admin email\n * 2. Register first admin with that email - should succeed (valid registration)\n * 3. Try second registration using the same email - should fail due to uniqueness\n *    constraint\n * 4. Assert that the second attempt fails and exposes no sensitive admin data\n * 5. Check that failure is a business (not type) error\n */\nexport async function test_api_admin_account_registration_duplicate_email(\n  connection: api.IConnection,\n) {\n  // 1. Prepare unique random email and password hash\n  const email: string & tags.Format<\"email\"> = typia.random<\n    string & tags.Format<\"email\">\n  >();\n  const password_hash: string = RandomGenerator.alphaNumeric(24);\n\n  // 2. Register the first admin - success expected\n  const firstAdmin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email,\n      password_hash,\n      name: RandomGenerator.name(),\n      avatar_uri: null,\n      status: \"active\",\n      privilege_level: \"superadmin\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(firstAdmin);\n  TestValidator.equals(\n    \"registered email matches input\",\n    firstAdmin.admin.email,\n    email,\n  );\n\n  // 3. Attempt second registration with same email - should fail with business error\n  await TestValidator.error(\n    \"duplicate admin email registration should fail\",\n    async () => {\n      await api.functional.auth.admin.join(connection, {\n        body: {\n          email,\n          password_hash: RandomGenerator.alphaNumeric(24), // different password hash, same email\n          name: RandomGenerator.name(),\n          avatar_uri: null,\n          status: \"active\",\n          privilege_level: \"support\",\n        } satisfies ITodoListAdmin.IJoin,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/login","method":"post"},"draft":"This scenario tests both successful and failed login attempts for an administrator. It covers the following workflow: (1) Register a new admin account, (2) attempt to log in with correct credentials and verify access token is issued, (3) attempt login with incorrect password and verify error message is appropriate. Success is indicated by valid session tokens on correct credentials; failure scenarios ensure no leakage of account existence details.","functionName":"test_api_admin_login_success_and_failure","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create an administrator account to enable login testing"}]},"location":"test/features/api/auth/test_api_admin_login_success_and_failure.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validates administrator login API for both success and failure scenarios.\n *\n * 1. Registers a new admin with a random email and a known password hash\n * 2. Attempts login with correct credentials; verifies tokens and profile match\n * 3. Attempts login with correct email but incorrect password; expects an error\n */\nexport async function test_api_admin_login_success_and_failure(\n  connection: api.IConnection,\n) {\n  // 1. Register an administrator\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const knownPassword = \"StrongPassword1234!\";\n  const joinBody = {\n    email: adminEmail,\n    password_hash: knownPassword,\n    name: RandomGenerator.name(),\n    status: \"active\",\n    privilege_level: \"superadmin\",\n  } satisfies ITodoListAdmin.IJoin;\n  const adminJoinResult = await api.functional.auth.admin.join(connection, {\n    body: joinBody,\n  });\n  typia.assert(adminJoinResult);\n  TestValidator.equals(\n    \"joined admin email same as input\",\n    adminJoinResult.admin.email,\n    adminEmail,\n  );\n  TestValidator.equals(\n    \"admin status is active\",\n    adminJoinResult.admin.status,\n    \"active\",\n  );\n  TestValidator.equals(\n    \"admin privilege is superadmin\",\n    adminJoinResult.admin.privilege_level,\n    \"superadmin\",\n  );\n\n  // 2. Login with correct credentials\n  const loginBody = {\n    email: adminEmail,\n    password: knownPassword,\n  } satisfies ITodoListAdmin.ILogin;\n  const loginResult = await api.functional.auth.admin.login(connection, {\n    body: loginBody,\n  });\n  typia.assert(loginResult);\n  TestValidator.equals(\n    \"login admin id matches joined\",\n    loginResult.admin.id,\n    adminJoinResult.admin.id,\n  );\n  TestValidator.equals(\n    \"login admin email matches\",\n    loginResult.admin.email,\n    adminEmail,\n  );\n  TestValidator.predicate(\n    \"token access exists\",\n    typeof loginResult.token.access === \"string\" &&\n      loginResult.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"token refresh exists\",\n    typeof loginResult.token.refresh === \"string\" &&\n      loginResult.token.refresh.length > 0,\n  );\n\n  // 3. Attempt login with wrong password; expect error\n  const wrongLoginBody = {\n    email: adminEmail,\n    password: \"Definitel!!WrongPassword987\",\n  } satisfies ITodoListAdmin.ILogin;\n  await TestValidator.error(\n    \"admin login with wrong password fails\",\n    async () => {\n      await api.functional.auth.admin.login(connection, {\n        body: wrongLoginBody,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/refresh","method":"post"},"draft":"This scenario validates the full admin token refresh workflow. Steps: (1) Register and log in as an admin, (2) use the issued refresh token to obtain new session tokens, (3) verify the old token is invalidated (if business logic supports), (4) attempt refresh with revoked or expired tokens and check for secure error handling and no privilege escalation. Ensures business logic for session renewal and security is robust.","functionName":"test_api_admin_refresh_token_renewal_and_revocation","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create an administrator account for refresh workflow"},{"endpoint":{"path":"/auth/admin/login","method":"post"},"purpose":"Authenticate admin to obtain refresh token for session renewal"}]},"location":"test/features/api/auth/test_api_admin_refresh_token_renewal_and_revocation.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validates admin token refresh, renewal, and secure revocation of refresh\n * tokens.\n *\n * 1. Registers a unique admin\n * 2. Logs in to obtain refresh token\n * 3. Refreshes token using valid refresh token, ensures new credentials\n * 4. Verifies old refresh token cannot be reused\n * 5. Attempts refresh with bogus/expired token and checks secure error\n */\nexport async function test_api_admin_refresh_token_renewal_and_revocation(\n  connection: api.IConnection,\n) {\n  // 1. Register a new administrator\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(15);\n  const password_hash = password; // In real apps this should be pre-hashed for security!\n  const joinRes = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password_hash,\n      name: RandomGenerator.name(),\n      avatar_uri: null,\n      status: \"active\",\n      privilege_level: \"support\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(joinRes);\n  TestValidator.equals(\n    \"joined admin email matches\",\n    joinRes.admin.email,\n    adminEmail,\n  );\n\n  // 2. Authenticate admin (get initial refresh token)\n  const loginRes = await api.functional.auth.admin.login(connection, {\n    body: {\n      email: adminEmail,\n      password: password,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n  typia.assert(loginRes);\n  TestValidator.equals(\"login email matches\", loginRes.admin.email, adminEmail);\n  const firstRefreshToken = loginRes.token.refresh;\n\n  // 3. Use the refresh token for session renewal\n  const refreshRes = await api.functional.auth.admin.refresh(connection, {\n    body: {\n      refresh_token: firstRefreshToken,\n    } satisfies ITodoListAdmin.IRefresh,\n  });\n  typia.assert(refreshRes);\n  TestValidator.notEquals(\n    \"refreshed access token differs\",\n    refreshRes.token.access,\n    loginRes.token.access,\n  );\n  TestValidator.notEquals(\n    \"refreshed refresh token differs\",\n    refreshRes.token.refresh,\n    firstRefreshToken,\n  );\n\n  // 4. Old refresh token cannot be reused\n  await TestValidator.error(\n    \"reusing used/rotated refresh token is rejected\",\n    async () => {\n      await api.functional.auth.admin.refresh(connection, {\n        body: {\n          refresh_token: firstRefreshToken,\n        } satisfies ITodoListAdmin.IRefresh,\n      });\n    },\n  );\n\n  // 5. Submit an obviously invalid refresh token\n  await TestValidator.error(\n    \"refresh with clearly invalid token is rejected\",\n    async () => {\n      await api.functional.auth.admin.refresh(connection, {\n        body: {\n          refresh_token: RandomGenerator.alphaNumeric(64),\n        } satisfies ITodoListAdmin.IRefresh,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/users/{userId}","method":"get"},"draft":"This scenario validates that an admin can correctly retrieve user detail profiles by userId, and that access to non-existent or soft-deleted users is handled gracefully. Steps: (1) Register admin and multiple user accounts; (2) as admin, request detail for an existing userId and validate field content excluding sensitive data; (3) request with a non-existent or deleted userId and verify correct not-found or error response. Special checks include strict enforcement of authorization (admin only) and proper error messaging for invalid input.","functionName":"test_api_admin_user_detail_access_and_nonexistence","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register a new admin to run user detail queries"},{"endpoint":{"path":"/auth/admin/login","method":"post"},"purpose":"Authenticate as admin for authorization"},{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Create user account(s) so that valid userIds exist for detail lookup"}]},"location":"test/features/api/todo_list_user/test_api_admin_user_detail_access_and_nonexistence.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate admin ability to retrieve user detail and error on\n * non-existent/deleted user profile.\n *\n * 1. Register a new admin using /auth/admin/join (with random email/password)\n * 2. Register multiple user accounts using /auth/user/join (at least 2 users,\n *    random email per user)\n * 3. Authenticate as admin with /auth/admin/login\n * 4. As admin, access user detail with /todoList/admin/users/{userId} for one of\n *    the created users\n *\n *    - Validate field content matches the DTO and is non-sensitive (no\n *         password_hash)\n *    - Ensure status/deletion state is as expected, and business/compliance fields\n *         present\n * 5. As admin, access /todoList/admin/users/{userId} with a random UUID (not used\n *    for any user)\n *\n *    - Confirm 'not found' or equivalent error is returned\n * 6. Attempt to retrieve a soft-deleted user's profile by using another random\n *    UUID\n *\n *    - Confirm error is returned (soft-delete simulated since direct deletion API is\n *         unavailable)\n */\nexport async function test_api_admin_user_detail_access_and_nonexistence(\n  connection: api.IConnection,\n) {\n  // 1. Register an admin\n  const adminEmail = `${RandomGenerator.alphaNumeric(8)}@admin.test.com`;\n  const adminPassword = RandomGenerator.alphaNumeric(12);\n  const adminJoinRes = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password_hash: adminPassword,\n      name: RandomGenerator.name(),\n      avatar_uri: null,\n      status: \"active\",\n      privilege_level: \"support\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(adminJoinRes);\n\n  // 2. Register two user accounts\n  const userInfos = ArrayUtil.repeat(2, () => ({\n    email: `${RandomGenerator.alphaNumeric(8)}@user.test.com`,\n    password: RandomGenerator.alphaNumeric(12),\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n  }));\n  const users = [] as ITodoListUser.IAuthorized[];\n  for (const info of userInfos) {\n    const userJoin = await api.functional.auth.user.join(connection, {\n      body: {\n        email: info.email,\n        password: info.password,\n        name: info.name,\n        avatar_uri: info.avatar_uri,\n      } satisfies ITodoListUser.IJoin,\n    });\n    typia.assert(userJoin);\n    users.push(userJoin);\n  }\n\n  // 3. Authenticate as admin\n  const adminLoginRes = await api.functional.auth.admin.login(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPassword,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n  typia.assert(adminLoginRes);\n\n  // 4. Retrieve detail of the first user by userId\n  const targetUser = users[0];\n  const detail = await api.functional.todoList.admin.users.at(connection, {\n    userId: targetUser.id,\n  });\n  typia.assert(detail);\n  TestValidator.equals(\"user id matches\", detail.id, targetUser.id);\n  TestValidator.equals(\n    \"user email matches\",\n    detail.email,\n    targetUser.user.email,\n  );\n  TestValidator.equals(\n    \"status is active or present\",\n    typeof detail.status,\n    \"string\",\n  );\n  TestValidator.equals(\n    \"deleted_at is null or undefined\",\n    detail.deleted_at ?? null,\n    null,\n  );\n  TestValidator.predicate(\n    \"no sensitive password field\",\n    !(\"password_hash\" in detail),\n  );\n\n  // 5. Attempt lookup for non-existent userId\n  const nonExistentUserId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.error(\n    \"admin GET non-existent user yields error\",\n    async () => {\n      await api.functional.todoList.admin.users.at(connection, {\n        userId: nonExistentUserId,\n      });\n    },\n  );\n\n  // 6. Attempt lookup for a soft-deleted user (simulate by using another random UUID)\n  const softDeletedUserId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.error(\"GET soft-deleted user yields error\", async () => {\n    await api.functional.todoList.admin.users.at(connection, {\n      userId: softDeletedUserId,\n    });\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/auditLogs/{auditLogId}","method":"get"},"draft":"This scenario tests retrieving the details of an audit log record as an admin. \n\nPreparation steps:\n- Register as an admin using POST /auth/admin/join to obtain authentication context for the session.\n- Use PATCH /todoList/admin/auditLogs to locate at least one existing auditLogId (and thus referenceable todo_list_admin_id, todo_list_user_id, todo_list_todo_id). Note: since there are no endpoints to create audit logs or the linked resources within the current API set, all test IDs must be treated as pre-existing records.\n- Fetch details of a known auditLogId via GET /todoList/admin/auditLogs/{auditLogId}, verifying that the returned details include admin, user, todo, action type, rationale, and timestamp as described, and ensure no sensitive or extraneous information is leaked.\n- Attempt to fetch audit log details for a random, non-existent auditLogId; assert that the system returns an appropriate not-found or error response following business requirements.\n\nThis scenario validates correct access and error handling for audit log detail retrieval, using only pre-existing, externally provisioned records available through the administrative search API.","functionName":"test_api_audit_log_detail_fetch_success_and_not_found","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register and authenticate as an admin for authorization context (admin role required for audit log access)"},{"endpoint":{"path":"/todoList/admin/auditLogs","method":"patch"},"purpose":"Locate at least one valid, existing audit log entry for detail retrieval. No creator APIs are available for log entries or associated resources, so test relies on pre-populated/test fixture data."}]},"location":"test/features/api/audit_log/test_api_audit_log_detail_fetch_success_and_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListAuditLog } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAuditLog\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListAuditLog } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAuditLog\";\n\n/**\n * Validate admin detail audit log fetch and not-found error scenario.\n *\n * 1. Register an admin via POST /auth/admin/join with randomized credentials.\n * 2. Query audit logs via PATCH /todoList/admin/auditLogs with default filter to\n *    locate at least one valid log.\n * 3. Fetch audit log detail by this ID and assert all fields (id, admin ref, user\n *    ref, todo ref, action, rationale, created_at) are present.\n * 4. Attempt to fetch a random (nonexistent) auditLogId to assert a business error\n *    response (not-found, no data leak).\n */\nexport async function test_api_audit_log_detail_fetch_success_and_not_found(\n  connection: api.IConnection,\n) {\n  // 1. Register admin\n  const joinInput = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password_hash: RandomGenerator.alphaNumeric(16),\n    name: RandomGenerator.name(),\n  } satisfies ITodoListAdmin.IJoin;\n  const adminAuth = await api.functional.auth.admin.join(connection, {\n    body: joinInput,\n  });\n  typia.assert(adminAuth);\n\n  // 2. Query at least one audit log\n  const auditPage = await api.functional.todoList.admin.auditLogs.index(\n    connection,\n    {\n      body: {}, // no filter (all data)\n    },\n  );\n  typia.assert(auditPage);\n  TestValidator.predicate(\n    \"audit log list has at least one entry\",\n    auditPage.data.length > 0,\n  );\n  const picked = auditPage.data[0];\n\n  // 3. Fetch audit log detail and assert type\n  const detail = await api.functional.todoList.admin.auditLogs.at(connection, {\n    auditLogId: picked.id,\n  });\n  typia.assert(detail);\n  TestValidator.equals(\"detail id matches\", detail.id, picked.id);\n  TestValidator.equals(\n    \"admin id matches\",\n    detail.todo_list_admin_id,\n    picked.todo_list_admin_id,\n  );\n  TestValidator.equals(\n    \"user id matches\",\n    detail.todo_list_user_id,\n    picked.todo_list_user_id,\n  );\n  TestValidator.equals(\n    \"todo id matches\",\n    detail.todo_list_todo_id,\n    picked.todo_list_todo_id,\n  );\n  TestValidator.equals(\"action matches\", detail.action, picked.action);\n  TestValidator.equals(\"rationale matches\", detail.rationale, picked.rationale);\n  TestValidator.equals(\n    \"created_at matches\",\n    detail.created_at,\n    picked.created_at,\n  );\n\n  // 4. Not found case: random UUID\n  const randomId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.error(\n    \"fetching nonexistent audit log throws error\",\n    async () => {\n      await api.functional.todoList.admin.auditLogs.at(connection, {\n        auditLogId: randomId,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/users/{userId}","method":"put"},"draft":"Scenario Overview: Verify that an admin can successfully update a user's profile information, such as name, status, or avatar, for an existing user account. \nWorkflow: \n1. Register and authenticate as an admin using the admin join and login endpoints. \n2. Create a user account (using POST /auth/user/join as a dependency). \n3. Use the admin context to send a valid update to the user's profile on PUT /todoList/admin/users/{userId}. \n4. Confirm changes are reflected and returned as expected (excluding credential hash).\nValidation Points: Only allowed fields are modified; uniqueness and business validation rules are enforced. \nSuccess Criteria: API returns the updated user object with applied changes. \nError Handling: Try updating with invalid data (e.g., duplicate email, invalid status) and expect proper error responses.","functionName":"test_api_admin_user_update_profile_success","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register a new administrator (admin context required for updating users)"},{"endpoint":{"path":"/auth/admin/login","method":"post"},"purpose":"Authenticate as administrator to get bearer token"},{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Create a user account for the userId to be updated in the test"}]},"location":"test/features/api/todo_list_user/test_api_admin_user_update_profile_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Verify admin user update for user profiles (PUT\n * /todoList/admin/users/{userId})\n *\n * 1. Register an admin via admin join (random email/password_hash)\n * 2. Login as admin\n * 3. Register a user via user join (random email/password, with optional\n *    name/avatar)\n * 4. As admin, update the user's name, status, and avatar_uri via the users.update\n *    API\n * 5. Confirm updated fields are reflected in the returned user object (excluding\n *    credential hash)\n * 6. Attempt to update with duplicate email (should fail)\n * 7. Attempt to update with obviously invalid status (should fail)\n */\nexport async function test_api_admin_user_update_profile_success(\n  connection: api.IConnection,\n) {\n  // 1. Register an admin and login\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPwd = RandomGenerator.alphaNumeric(16);\n  await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password_hash: adminPwd,\n      name: RandomGenerator.name(),\n      avatar_uri: null,\n      privilege_level: \"support\",\n      status: \"active\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  await api.functional.auth.admin.login(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPwd,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n\n  // 2. Create a new user\n  const originalEmail = typia.random<string & tags.Format<\"email\">>();\n  const userPwd = RandomGenerator.alphaNumeric(12);\n  const userJoinResult = await api.functional.auth.user.join(connection, {\n    body: {\n      email: originalEmail,\n      password: userPwd,\n      name: RandomGenerator.name(),\n      avatar_uri: null,\n    } satisfies ITodoListUser.IJoin,\n  });\n  const userId = userJoinResult.id;\n  typia.assert(userJoinResult);\n\n  // 3. Update user's name, status, and avatar as admin\n  const updatedName = RandomGenerator.name(2);\n  const updatedAvatar =\n    \"https://cdn.example.com/avatar/\" + RandomGenerator.alphaNumeric(12);\n  const updatedStatus = \"active\";\n  const updateRes = await api.functional.todoList.admin.users.update(\n    connection,\n    {\n      userId,\n      body: {\n        name: updatedName,\n        avatar_uri: updatedAvatar,\n        status: updatedStatus,\n      } satisfies ITodoListUser.IUpdate,\n    },\n  );\n  typia.assert(updateRes);\n  TestValidator.equals(\"name updated\", updateRes.name, updatedName);\n  TestValidator.equals(\"avatar updated\", updateRes.avatar_uri, updatedAvatar);\n  TestValidator.equals(\"status updated\", updateRes.status, updatedStatus);\n\n  // 4. Try updating the user's email to a duplicate\n  const otherUserJoin = await api.functional.auth.user.join(connection, {\n    body: {\n      email: typia.random<string & tags.Format<\"email\">>(),\n      password: RandomGenerator.alphaNumeric(12),\n      name: RandomGenerator.name(),\n    } satisfies ITodoListUser.IJoin,\n  });\n  await TestValidator.error(\n    \"should fail updating with duplicate email\",\n    async () => {\n      await api.functional.todoList.admin.users.update(connection, {\n        userId,\n        body: {\n          email: otherUserJoin.user.email,\n        } satisfies ITodoListUser.IUpdate,\n      });\n    },\n  );\n\n  // 5. Try updating to an invalid status (empty string)\n  await TestValidator.error(\n    \"should fail updating with invalid status\",\n    async () => {\n      await api.functional.todoList.admin.users.update(connection, {\n        userId,\n        body: {\n          status: \"\",\n        } satisfies ITodoListUser.IUpdate,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/users/{userId}","method":"delete"},"draft":"Scenario Overview: Validate that an admin can soft-delete (mark as deleted) an existing user account and that related compliance rules apply.\nWorkflow:\n1. Register and authenticate as an admin using the admin join and login endpoints.\n2. Create a user via /auth/user/join.\n3. Use DELETE /todoList/admin/users/{userId} as the admin context.\n4. Assert user is no longer listed/searchable, and retrieving the user now returns a 'not found' or indicates deleted_at is set.\nValidation Points: Deletion is soft (deleted_at filled), audit logging occurs, and related business checks are applied.\nSuccess Criteria: User cannot be found in normal user lists post-deletion.\nError Handling: Attempt to delete non-existent userId; validate 'not found' response.","functionName":"test_api_admin_user_soft_deletion","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register a new administrator (needed for privileged DELETE)"},{"endpoint":{"path":"/auth/admin/login","method":"post"},"purpose":"Login as admin to obtain bearer token"},{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Create a user to be deleted"}]},"location":"test/features/api/todo_list_user/test_api_admin_user_soft_deletion.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate admin soft-deletes a user account via DELETE\n * /todoList/admin/users/{userId}.\n *\n * Steps:\n *\n * 1. Admin registers (POST /auth/admin/join) with unique email and random\n *    password_hash.\n * 2. Login as admin (POST /auth/admin/login) with those credentials.\n * 3. Create user (POST /auth/user/join) with unique email and random password.\n * 4. Admin erases that user (DELETE /todoList/admin/users/{userId}).\n * 5. (OPTIONAL) Try deleting a random/nonexistent user; error must be thrown.\n *\n * Validate:\n *\n * - User cannot be found post-deletion, or user.deletd_at is set if retrievable.\n * - Erasure is soft (deleted_at is filled).\n * - Cannot erase a nonexistent user (error is thrown).\n *\n * ALL API calls strictly use SDK and exact DTO types with typia.assert() for\n * output validation.\n */\nexport async function test_api_admin_user_soft_deletion(\n  connection: api.IConnection,\n) {\n  // 1. Register admin\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = RandomGenerator.alphaNumeric(12);\n  const adminJoin = {\n    email: adminEmail,\n    password_hash: adminPassword,\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n    status: \"active\",\n    privilege_level: \"superadmin\",\n  } satisfies ITodoListAdmin.IJoin;\n  const adminAuth = await api.functional.auth.admin.join(connection, {\n    body: adminJoin,\n  });\n  typia.assert(adminAuth);\n  // 2. Login as admin\n  const adminLogin = {\n    email: adminEmail,\n    password: adminPassword,\n  } satisfies ITodoListAdmin.ILogin;\n  const adminSession = await api.functional.auth.admin.login(connection, {\n    body: adminLogin,\n  });\n  typia.assert(adminSession);\n\n  // 3. Register user\n  const userEmail = typia.random<string & tags.Format<\"email\">>();\n  const userPassword = RandomGenerator.alphaNumeric(10);\n  const userJoin = {\n    email: userEmail,\n    password: userPassword,\n    name: RandomGenerator.name(2),\n    avatar_uri: null,\n  } satisfies ITodoListUser.IJoin;\n  const userAuth = await api.functional.auth.user.join(connection, {\n    body: userJoin,\n  });\n  typia.assert(userAuth);\n\n  // 4. As admin, erase that user\n  await api.functional.todoList.admin.users.erase(connection, {\n    userId: userAuth.id,\n  });\n  // 5. Try erase again; expect error\n  await TestValidator.error(\"delete non-existent user throws\", async () => {\n    await api.functional.todoList.admin.users.erase(connection, {\n      userId: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/admins","method":"patch"},"draft":"Scenario Overview: Validate that an admin can retrieve a paginated and filtered list of other administrators using the admin search endpoint.\nWorkflow:\n1. Register and authenticate as an admin (using join/login endpoints).\n2. Use PATCH /todoList/admin/admins with various query and filter parameters: partial name/email search, pagination, sort by created time, filter by status or privilege level.\nValidation Points: Results respect query conditions, exclude password hashes, support pagination, respect privilege/status filters.\nSuccess Criteria: API returns only expected admin records, correctly filtered and paginated. Sensitive info is not included in response.\nError Handling: Supply invalid filter values, ensure clear errors are returned.","functionName":"test_api_admin_admins_search_pagination_filtering","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Setup a new admin for context and possible search population"},{"endpoint":{"path":"/auth/admin/login","method":"post"},"purpose":"Login as admin to collect required authentication context"}]},"location":"test/features/api/todo_list_admin/test_api_admin_admins_search_pagination_filtering.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAdmin\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validate the search, pagination, and filtering of admin accounts using the\n * admin listing API.\n *\n * Steps:\n *\n * 1. Register multiple distinct admins with varying email, name, privilege, and\n *    status.\n * 2. Login with one admin to authenticate further requests.\n * 3. Use PATCH /todoList/admin/admins to search by partial email/name, apply\n *    status/privilege filters, sort and paginate.\n * 4. Validate that only matching admins are returned, no password_hash is present,\n *    and pagination info makes sense.\n */\nexport async function test_api_admin_admins_search_pagination_filtering(\n  connection: api.IConnection,\n) {\n  // 1. Register 5 distinct admins with known pass and varied props\n  const possibleStatuses = [\n    \"active\",\n    \"locked\",\n    \"disabled\",\n    \"suspended\",\n  ] as const;\n  const possiblePrivileges = [\"superadmin\", \"support\", \"auditor\"] as const;\n  const admins = await ArrayUtil.asyncRepeat(5, async (i) => {\n    const status = RandomGenerator.pick(possibleStatuses);\n    const privilege = RandomGenerator.pick(possiblePrivileges);\n    const email = `${RandomGenerator.alphabets(12)}${i}@test.com`;\n    const name = RandomGenerator.name();\n    const password_hash = RandomGenerator.alphaNumeric(20);\n    const joinBody = {\n      email,\n      password_hash,\n      name,\n      avatar_uri: null,\n      status,\n      privilege_level: privilege,\n    } satisfies ITodoListAdmin.IJoin;\n    const auth = await api.functional.auth.admin.join(connection, {\n      body: joinBody,\n    });\n    typia.assert(auth);\n    return { auth, status, privilege, email, name, password_hash };\n  });\n\n  // 2. Login as the first admin for context\n  const loginBody = {\n    email: admins[0].email,\n    password: admins[0].password_hash,\n  } satisfies ITodoListAdmin.ILogin;\n  const session = await api.functional.auth.admin.login(connection, {\n    body: loginBody,\n  });\n  typia.assert(session);\n\n  // 3. Query: partial email filter (use `@test.com` substring)\n  const res1 = await api.functional.todoList.admin.admins.index(connection, {\n    body: {\n      email: \"@test.com\",\n      page: 1 as number & tags.Type<\"int32\"> & tags.Minimum<1>,\n      limit: 5 as number &\n        tags.Type<\"int32\"> &\n        tags.Minimum<1> &\n        tags.Maximum<100>,\n      sort_by: \"created_at\",\n      direction: \"asc\",\n    } satisfies ITodoListAdmin.IRequest,\n  });\n  typia.assert(res1);\n  TestValidator.predicate(\n    \"admins matching email substring filter returned\",\n    res1.data.every((adm) => adm.email.includes(\"@test.com\")),\n  );\n  TestValidator.equals(\n    \"pagination (limit matches request)\",\n    res1.pagination.limit,\n    5,\n  );\n  // Ensure password_hash never appears\n  TestValidator.predicate(\n    \"no password_hash returned in summaries\",\n    res1.data.every((adm) => !(\"password_hash\" in adm)),\n  );\n\n  // 4. Filter by privilege_level\n  const filterPrivilege = admins[2].privilege;\n  const res2 = await api.functional.todoList.admin.admins.index(connection, {\n    body: {\n      privilege_level: filterPrivilege,\n      page: 1 as number & tags.Type<\"int32\"> & tags.Minimum<1>,\n      limit: 10 as number &\n        tags.Type<\"int32\"> &\n        tags.Minimum<1> &\n        tags.Maximum<100>,\n      sort_by: \"email\",\n      direction: \"desc\",\n    } satisfies ITodoListAdmin.IRequest,\n  });\n  typia.assert(res2);\n  TestValidator.predicate(\n    \"filtered privilege_level admins returned\",\n    res2.data.every((adm) => adm.privilege_level === filterPrivilege),\n  );\n\n  // 5. Filter by status\n  const filterStatus = admins[3].status;\n  const res3 = await api.functional.todoList.admin.admins.index(connection, {\n    body: {\n      status: filterStatus,\n      page: 1 as number & tags.Type<\"int32\"> & tags.Minimum<1>,\n      limit: 10 as number &\n        tags.Type<\"int32\"> &\n        tags.Minimum<1> &\n        tags.Maximum<100>,\n      sort_by: \"created_at\",\n      direction: \"asc\",\n    } satisfies ITodoListAdmin.IRequest,\n  });\n  typia.assert(res3);\n  TestValidator.predicate(\n    \"filtered status admins returned\",\n    res3.data.every((adm) => adm.status === filterStatus),\n  );\n\n  // 6. Query with pagination (limit=2, page 2)\n  const resPage = await api.functional.todoList.admin.admins.index(connection, {\n    body: {\n      page: 2 as number & tags.Type<\"int32\"> & tags.Minimum<1>,\n      limit: 2 as number &\n        tags.Type<\"int32\"> &\n        tags.Minimum<1> &\n        tags.Maximum<100>,\n      sort_by: \"created_at\",\n      direction: \"desc\",\n    } satisfies ITodoListAdmin.IRequest,\n  });\n  typia.assert(resPage);\n  TestValidator.equals(\n    \"pagination page matches (2)\",\n    resPage.pagination.current,\n    2,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/admins/{adminId}","method":"get"},"draft":"Scenario Overview: Verify that an admin can retrieve the detail profile of a specific administrator using their adminId.\nWorkflow:\n1. Register the first admin (via /auth/admin/join) and use its id as adminId.\n2. Register and authenticate as a second admin (to simulate viewing other admin details).\n3. Using the authenticated second admin, call GET /todoList/admin/admins/{adminId}.\nValidation Points: Proper details for the target admin (fields: name, email, status, privilege_level, timestamps, etc.) are returned. Password hash is never included.\nSuccess Criteria: Response contains complete and correct admin information excluding authentication secrets.\nError Handling: Request non-existent adminId; expect appropriate 'not found' or error response.","functionName":"test_api_admin_detail_retrieval_by_id","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create the first admin to serve as the detail target (adminId)"},{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create and authenticate a second admin to perform authorized retrieval"},{"endpoint":{"path":"/auth/admin/login","method":"post"},"purpose":"Login as second admin to establish context for retrieval"}]},"location":"test/features/api/todo_list_admin/test_api_admin_detail_retrieval_by_id.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validate administrator detail retrieval by ID for privilege management and\n * audit clarity.\n *\n * This test verifies that privileged admins can retrieve the full profile\n * details (excluding sensitive credentials) of another admin using their\n * adminId.\n *\n * 1. Register a first admin, keeping the returned id for detail lookup.\n * 2. Register and login as a second admin session.\n * 3. Using the session of the second admin, request GET\n *    /todoList/admin/admins/{adminId} for the first admin.\n * 4. Validate all profile fields match the first admin; password_hash is never\n *    present.\n * 5. Negative test: request with a random non-existent adminId and check that\n *    error is thrown (no business-logic or status check, only error-throw\n *    assertion).\n */\nexport async function test_api_admin_detail_retrieval_by_id(\n  connection: api.IConnection,\n) {\n  // 1. Register first admin account to be the detail target\n  const admin1_email = typia.random<string & tags.Format<\"email\">>();\n  const admin1_password = RandomGenerator.alphaNumeric(10);\n  const admin1_name = RandomGenerator.name();\n  const admin1_avatar = undefined;\n  const admin1_status = \"active\";\n  const admin1_privilege = \"support\";\n  const admin1_join = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: admin1_email,\n      password_hash: admin1_password,\n      name: admin1_name,\n      avatar_uri: admin1_avatar,\n      status: admin1_status,\n      privilege_level: admin1_privilege,\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(admin1_join);\n  const admin1_id = admin1_join.id;\n  const admin1_profile = admin1_join.admin;\n\n  // 2. Register and login as second admin to represent an actor session\n  const admin2_email = typia.random<string & tags.Format<\"email\">>();\n  const admin2_password = RandomGenerator.alphaNumeric(10);\n  const admin2_join = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: admin2_email,\n      password_hash: admin2_password,\n      name: RandomGenerator.name(),\n      status: \"active\",\n      privilege_level: \"superadmin\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(admin2_join);\n  await api.functional.auth.admin.login(connection, {\n    body: {\n      email: admin2_email,\n      password: admin2_password,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n\n  // 3. As second admin, perform detail GET lookup on first admin\n  const output = await api.functional.todoList.admin.admins.at(connection, {\n    adminId: admin1_id,\n  });\n  typia.assert(output);\n\n  // 4. Assert all returned fields match first admin registration (except timestamps, last_login/last_action may update)\n  TestValidator.equals(\n    \"admin profile id matches target\",\n    output.id,\n    admin1_profile.id,\n  );\n  TestValidator.equals(\n    \"admin email matches target\",\n    output.email,\n    admin1_profile.email,\n  );\n  TestValidator.equals(\n    \"admin name matches target\",\n    output.name,\n    admin1_profile.name,\n  );\n  TestValidator.equals(\n    \"admin avatar_uri matches target\",\n    output.avatar_uri,\n    admin1_profile.avatar_uri,\n  );\n  TestValidator.equals(\n    \"admin status matches target\",\n    output.status,\n    admin1_profile.status,\n  );\n  TestValidator.equals(\n    \"admin privilege_level matches target\",\n    output.privilege_level,\n    admin1_profile.privilege_level,\n  );\n  TestValidator.equals(\n    \"admin deleted_at matches target\",\n    output.deleted_at,\n    admin1_profile.deleted_at,\n  );\n\n  // Optional timestamp fields (nullable/null/undef - check contract compliance)\n  TestValidator.predicate(\n    \"admin created_at is a non-empty string\",\n    typeof output.created_at === \"string\" && output.created_at.length > 0,\n  );\n  TestValidator.predicate(\n    \"admin updated_at is a non-empty string\",\n    typeof output.updated_at === \"string\" && output.updated_at.length > 0,\n  );\n  TestValidator.predicate(\n    \"admin last_admin_action_at is string or null or undefined\",\n    output.last_admin_action_at === null ||\n      output.last_admin_action_at === undefined ||\n      typeof output.last_admin_action_at === \"string\",\n  );\n  TestValidator.predicate(\n    \"admin last_login_at is string or null or undefined\",\n    output.last_login_at === null ||\n      output.last_login_at === undefined ||\n      typeof output.last_login_at === \"string\",\n  );\n\n  // 4b. Assert NO password_hash field\n  TestValidator.predicate(\n    \"output never exposes password_hash property\",\n    !Object.prototype.hasOwnProperty.call(output, \"password_hash\"),\n  );\n\n  // 5. Generate a random adminId that cannot collide with existing\n  let random_admin_id: string & tags.Format<\"uuid\">;\n  do {\n    random_admin_id = typia.random<string & tags.Format<\"uuid\">>();\n  } while (random_admin_id === admin1_id || random_admin_id === admin2_join.id);\n\n  await TestValidator.error(\n    \"should throw error for non-existent adminId\",\n    async () => {\n      await api.functional.todoList.admin.admins.at(connection, {\n        adminId: random_admin_id,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/user/todos/{todoId}","method":"get"},"draft":"Test retrieving a specific todo item as its owner (user role). Steps: 1) Register a new user (join); 2) Login as this user (optional if join auto-authenticates); 3) Create a todo for this user (capture todoId); 4) Retrieve the todo by its ID as the same user; 5) Validate fields (content, due_date, completed, ownership, no forbidden fields); 6) Attempt to retrieve another user's todo by changing credentials; expect a forbidden error; 7) Attempt to retrieve a non-existent todoId; expect a not-found error. Covers business logic of per-user access, validation, correctness, error-paths, and full-field compliance.","functionName":"test_api_user_todo_retrieval_success_and_permission","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register and authenticate new user (creates userId)"},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create todo for user to obtain todoId for retrieval testing"}]},"location":"test/features/api/todo_list_todo/test_api_user_todo_retrieval_success_and_permission.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate per-user access and full field correctness for user todo retrieval.\n *\n * 1. Register user A\n * 2. Create todo as user A and retrieve its ID\n * 3. Retrieve todo by ID as user A, validate: content, due_date, completed,\n *    timestamps, todo_list_user_id, etc.\n * 4. Register user B and attempt to access user A's todo; expect forbidden error\n * 5. Attempt to access a random non-existent todoId, expect not-found error\n */\nexport async function test_api_user_todo_retrieval_success_and_permission(\n  connection: api.IConnection,\n) {\n  // 1. Register user A\n  const userAJoinInput = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12),\n    name: RandomGenerator.name(),\n    avatar_uri: undefined,\n  } satisfies ITodoListUser.IJoin;\n  const userAAuth = await api.functional.auth.user.join(connection, {\n    body: userAJoinInput,\n  });\n  typia.assert(userAAuth);\n  const userAId = userAAuth.id;\n\n  // 2. Create todo as user A\n  const todoCreateInput = {\n    content: RandomGenerator.paragraph({ sentences: 3 }),\n    due_date: null,\n  } satisfies ITodoListTodo.ICreate;\n  const createdTodo = await api.functional.todoList.user.todos.create(\n    connection,\n    { body: todoCreateInput },\n  );\n  typia.assert(createdTodo);\n  const todoId = createdTodo.id;\n\n  // 3. Retrieve todo by ID as user A\n  const retrievedTodo = await api.functional.todoList.user.todos.at(\n    connection,\n    { todoId },\n  );\n  typia.assert(retrievedTodo);\n  TestValidator.equals(\"todo id matches\", retrievedTodo.id, todoId);\n  TestValidator.equals(\n    \"owner matches\",\n    retrievedTodo.todo_list_user_id,\n    userAId,\n  );\n  TestValidator.equals(\n    \"content matches\",\n    retrievedTodo.content,\n    todoCreateInput.content,\n  );\n  TestValidator.equals(\n    \"due_date matches\",\n    retrievedTodo.due_date,\n    todoCreateInput.due_date,\n  );\n  TestValidator.predicate(\n    \"not completed by default\",\n    retrievedTodo.completed === false,\n  );\n\n  // 4. Register user B\n  const userBJoinInput = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12),\n    name: RandomGenerator.name(),\n    avatar_uri: undefined,\n  } satisfies ITodoListUser.IJoin;\n  const userBAuth = await api.functional.auth.user.join(connection, {\n    body: userBJoinInput,\n  });\n  typia.assert(userBAuth);\n\n  // Try to access userA's todo as user B\n  await TestValidator.error(\n    \"forbidden: user B cannot access user A's todo\",\n    async () => {\n      await api.functional.todoList.user.todos.at(connection, { todoId });\n    },\n  );\n\n  // 5. Attempt to access a non-existent todoId\n  await TestValidator.error(\n    \"not found: random todoId returns error\",\n    async () => {\n      await api.functional.todoList.user.todos.at(connection, {\n        todoId: typia.random<string & tags.Format<\"uuid\">>(),\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/todos/{todoId}","method":"get"},"draft":"Test an admin retrieving any user's todo item by its ID. Steps: 1) Register a new admin (join); 2) Login as admin (if required); 3) Register a user (join, to create a target todo); 4) Authenticate as user and create a todo (capture todoId); 5) Switch authentication to admin context; 6) Retrieve the todo via admin endpoint; 7) Validate all returned fields, audit trail recording, and no forbidden access even for arbitrary user's todo; 8) Attempt admin retrieval of non-existent todoId; expect a not-found error; 9) Attempt retrieval of soft/nonexistent/inaccessible todo, confirm business error handling and data privacy enforcement.","functionName":"test_api_admin_todo_retrieval_full_audit_scope","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register and authenticate new admin (creates adminId)"},{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register and authenticate new user for todo ownership"},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create todo as user to obtain todoId for admin retrieval"},{"endpoint":{"path":"/auth/admin/login","method":"post"},"purpose":"Login as admin for cross-role retrieval operations"},{"endpoint":{"path":"/auth/user/login","method":"post"},"purpose":"Login as user for todo creation with proper session context"}]},"location":"test/features/api/todo_list_todo/test_api_admin_todo_retrieval_full_audit_scope.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate admin retrieval of any user's todo by id including audit fields and\n * access scope.\n *\n * 1. Register and authenticate a new admin (gather credentials for later login)\n * 2. Register a normal user to create a target todo\n * 3. As user, create a todo (capture todoId)\n * 4. Switch auth to admin (login using credentials)\n * 5. Retrieve the user's todo via admin endpoint (with captured id)\n * 6. Validate all fields & audit (ownership, created/updated)\n * 7. Admin can access arbitrary user's todo (cross-role check)\n * 8. Admin attempts to retrieve non-existent todoId (error expected)\n * 9. (Edge) Admin attempts retrieval of inaccessible/deleted todo (error expected)\n */\nexport async function test_api_admin_todo_retrieval_full_audit_scope(\n  connection: api.IConnection,\n) {\n  // 1. Register admin (capture credentials for login)\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = RandomGenerator.alphaNumeric(12);\n  const adminJoinResult = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password_hash: adminPassword,\n      name: RandomGenerator.name(),\n      status: \"active\",\n      privilege_level: \"auditor\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(adminJoinResult);\n  const adminId = adminJoinResult.id;\n\n  // 2. Register user (to create test todo)\n  const userEmail = typia.random<string & tags.Format<\"email\">>();\n  const userPassword = RandomGenerator.alphaNumeric(12);\n  const userJoinResult = await api.functional.auth.user.join(connection, {\n    body: {\n      email: userEmail,\n      password: userPassword,\n      name: RandomGenerator.name(),\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(userJoinResult);\n  const userId = userJoinResult.id;\n\n  // 3. Authenticate as user and create todo\n  await api.functional.auth.user.login(connection, {\n    body: {\n      email: userEmail,\n      password: userPassword,\n    } satisfies ITodoListUser.ILogin,\n  });\n\n  const todoContent = RandomGenerator.paragraph({\n    sentences: 3,\n    wordMin: 5,\n    wordMax: 10,\n  });\n  const todoDueDate = RandomGenerator.date(new Date(), 1000 * 60 * 60 * 24 * 7)\n    .toISOString()\n    .substring(0, 10);\n  const todoCreate = await api.functional.todoList.user.todos.create(\n    connection,\n    {\n      body: {\n        content: todoContent as string,\n        due_date: todoDueDate,\n      } satisfies ITodoListTodo.ICreate,\n    },\n  );\n  typia.assert(todoCreate);\n  const todoId = todoCreate.id;\n  const originalTodo = todoCreate;\n\n  // 4. Switch authentication to admin\n  await api.functional.auth.admin.login(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPassword,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n\n  // 5. Retrieve as admin\n  const adminViewTodo = await api.functional.todoList.admin.todos.at(\n    connection,\n    { todoId },\n  );\n  typia.assert(adminViewTodo);\n  // 6. Validate all returned fields\n  TestValidator.equals(\n    \"admin sees todo id matches\",\n    adminViewTodo.id,\n    originalTodo.id,\n  );\n  TestValidator.equals(\n    \"admin sees correct owner id\",\n    adminViewTodo.todo_list_user_id,\n    userId,\n  );\n  TestValidator.equals(\n    \"admin sees content\",\n    adminViewTodo.content,\n    todoContent,\n  );\n  TestValidator.equals(\n    \"admin sees due date\",\n    adminViewTodo.due_date,\n    todoDueDate,\n  );\n  TestValidator.equals(\"admin sees completion\", adminViewTodo.completed, false);\n  TestValidator.equals(\n    \"admin sees creation date\",\n    adminViewTodo.created_at,\n    originalTodo.created_at,\n  );\n  TestValidator.equals(\n    \"admin sees update date\",\n    adminViewTodo.updated_at,\n    originalTodo.updated_at,\n  );\n  TestValidator.equals(\n    \"admin sees completed_at is null\",\n    adminViewTodo.completed_at,\n    null,\n  );\n\n  // 7. Admin can access user's todo (cross-role check)\n  // (already validated above by using userId)\n\n  // 8. Attempt to retrieve non-existent todoId (expect not-found error)\n  const nonExistentTodoId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.error(\n    \"admin retrieval of non-existent todo triggers error\",\n    async () => {\n      await api.functional.todoList.admin.todos.at(connection, {\n        todoId: nonExistentTodoId,\n      });\n    },\n  );\n\n  // 9. (Edge) Attempt retrieve of inaccessible/deleted todo (simulate delete by random uuid)\n  // No explicit soft delete API, simulate with another uuid\n  await TestValidator.error(\n    \"admin retrieval of soft/nonexistent todo triggers error\",\n    async () => {\n      await api.functional.todoList.admin.todos.at(connection, {\n        todoId: typia.random<string & tags.Format<\"uuid\">>(),\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/user/todos","method":"post"},"draft":"Test end-to-end todo creation for a user, enforcing business validation and field constraints. Steps: 1) Register and authenticate a new user (join); 2) Create a normal todo with valid content and future due date; verify all returned fields; 3) Attempt creation with duplicate/recently-used content (should fail by deduplication logic); 4) Attempt creation with excessively long/short/whitespace-only content (should fail); 5) Attempt creation with a past due date (must fail); 6) If possible, attempt to create a todo while impersonating another user (should fail, only self-owned allowed); 7) Confirm success path adds todo to the user's list and response matches business schema.","functionName":"test_api_todo_creation_validation_and_constraints","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register and authenticate new user"}]},"location":"test/features/api/todo_list_todo/test_api_todo_creation_validation_and_constraints.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test E2E todo creation for a user, enforcing business rules, validation, and\n * constraints.\n *\n * 1. Register and authenticate a new user\n * 2. Create a valid todo (valid content, future due_date)\n * 3. Attempt duplicate creation (content duplication must be rejected)\n * 4. Attempt invalid content (too short, too long, whitespace-only)\n * 5. Attempt past due date (should fail)\n * 6. Attempt to create as different user (should fail if possible)\n * 7. Confirm success path result and deduplication holds\n */\nexport async function test_api_todo_creation_validation_and_constraints(\n  connection: api.IConnection,\n) {\n  // 1. Register and authenticate a user\n  const joinBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(10),\n    name: RandomGenerator.name(),\n    avatar_uri: undefined,\n  } satisfies ITodoListUser.IJoin;\n  const authorized = await api.functional.auth.user.join(connection, {\n    body: joinBody,\n  });\n  typia.assert(authorized);\n  const user = authorized.user;\n  // 2. Create a valid todo\n  const validContent = RandomGenerator.paragraph({\n    sentences: 5,\n    wordMin: 4,\n    wordMax: 10,\n  }).slice(0, 255);\n  const dueDate = new Date(Date.now() + 1000 * 60 * 60 * 24 * 5)\n    .toISOString()\n    .slice(0, 10); // 5 days in future, YYYY-MM-DD\n  const todoCreateBody = {\n    content: validContent,\n    due_date: dueDate,\n  } satisfies ITodoListTodo.ICreate;\n  const todo = await api.functional.todoList.user.todos.create(connection, {\n    body: todoCreateBody,\n  });\n  typia.assert(todo);\n  TestValidator.equals(\"todo.content === input\", todo.content, validContent);\n  TestValidator.equals(\"todo.due_date === input\", todo.due_date, dueDate);\n  TestValidator.equals(\"todo.completed === false\", todo.completed, false);\n  TestValidator.equals(\"owner matched\", todo.todo_list_user_id, user.id);\n\n  // 3. Attempt duplicate creation (deduplication logic)\n  await TestValidator.error(\n    \"Duplicate todo same content should fail\",\n    async () => {\n      await api.functional.todoList.user.todos.create(connection, {\n        body: todoCreateBody,\n      });\n    },\n  );\n\n  // 4. Attempt invalid content\n  // 4.1 whitespace-only\n  const whitespaceBody = {\n    content: \"   \\t\\n  \",\n    due_date: dueDate,\n  } satisfies ITodoListTodo.ICreate;\n  await TestValidator.error(\"Whitespace-only content rejected\", async () => {\n    await api.functional.todoList.user.todos.create(connection, {\n      body: whitespaceBody,\n    });\n  });\n  // 4.2 empty string\n  const emptyBody = {\n    content: \"\",\n    due_date: dueDate,\n  } satisfies ITodoListTodo.ICreate;\n  await TestValidator.error(\"Empty content rejected\", async () => {\n    await api.functional.todoList.user.todos.create(connection, {\n      body: emptyBody,\n    });\n  });\n  // 4.3 too long\n  const tooLongContent = RandomGenerator.paragraph({\n    sentences: 70,\n    wordMin: 4,\n    wordMax: 10,\n  });\n  const longBody = {\n    content: tooLongContent,\n    due_date: dueDate,\n  } satisfies ITodoListTodo.ICreate;\n  await TestValidator.error(\"Too long content (>255) rejected\", async () => {\n    await api.functional.todoList.user.todos.create(connection, {\n      body: longBody,\n    });\n  });\n\n  // 5. Past due date\n  const pastDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 1)\n    .toISOString()\n    .slice(0, 10); // yesterday\n  const pastDueBody = {\n    content: RandomGenerator.paragraph({ sentences: 5 }),\n    due_date: pastDate,\n  } satisfies ITodoListTodo.ICreate;\n  await TestValidator.error(\"Past due_date rejected\", async () => {\n    await api.functional.todoList.user.todos.create(connection, {\n      body: pastDueBody,\n    });\n  });\n\n  // 6. (If possible) As another user\n  const hackerBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(10),\n    name: RandomGenerator.name(),\n    avatar_uri: undefined,\n  } satisfies ITodoListUser.IJoin;\n  const hackerAuthorized = await api.functional.auth.user.join(connection, {\n    body: hackerBody,\n  });\n  typia.assert(hackerAuthorized);\n  // Switch to hacker session\n  // Since API works by credentials from connection, after join will set session as hacker\n  // Try to re-create todo with same content as user should be deduplicated per-user, not globally\n  const otherUserBody = {\n    content: validContent,\n    due_date: dueDate,\n  } satisfies ITodoListTodo.ICreate;\n  const hackerTodo = await api.functional.todoList.user.todos.create(\n    connection,\n    { body: otherUserBody },\n  );\n  typia.assert(hackerTodo);\n  TestValidator.predicate(\n    \"hacker's owner != user's\",\n    hackerTodo.todo_list_user_id !== user.id,\n  );\n\n  // (If not allowed to submit as wrong user, this would have failed with error instead)\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/user/todos/{todoId}","method":"put"},"draft":"Test updating a todo as its owner, including field updating and all business rules. Steps: 1) Register user (join) and create todo (capture todoId); 2) Update todo's content (valid, 1-255 chars, clean whitespace); 3) Update due date (future date); 4) Mark as completed/incomplete and check completion timestamp; 5) Attempt update with content constraints (too short/long/whitespace); expect validation failure; 6) Attempt update of non-owned or non-existent todo (manual change of todoId/credentials); ensure error responses match business logic and authorization rules. Validate all field changes appear as expected and that audit trail is correct for failed/successful attempts.","functionName":"test_api_user_todo_update_lifecycle","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register and authenticate new user"},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create todo as user to obtain todoId for update"}]},"location":"test/features/api/todo_list_todo/test_api_user_todo_update_lifecycle.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * This test verifies the update lifecycle of a user-owned todo in the\n * /todoList/user/todos/{todoId} API. It covers registration, todo creation,\n * various valid and invalid update flows, field-specific business validation,\n * and ownership/authorization enforcement.\n *\n * Test plan:\n *\n * 1. Register a new user via /auth/user/join (obtain JWT and user id)\n * 2. Create a todo item as this user via /todoList/user/todos (capture todoId)\n * 3. Update the todo's content with a normal valid string (1-255 non-whitespace\n *    chars, trimmed). Assert the change is reflected in the response.\n * 4. Update the todo's due date to a future date. Assert the due_date is updated\n *    in the response.\n * 5. Mark the todo completed (set completed=true). Assert completed_at is set.\n *    Then mark it incomplete and verify completed_at is reverted.\n * 6. Attempt updates with invalid content (whitespace, length <1, length >255).\n *    Expect business validation errors for each.\n * 7. Attempt to update using a random (nonexistent) todoId. Expect a not found or\n *    business error response.\n * 8. Register a second user, and try update with their account for the first\n *    user's todoId. Expect authorization error.\n * 9. For each update, verify that only allowed changes are reflected and all\n *    business rules are consistently enforced, and that unsuccessful changes\n *    leave the todo unchanged.\n */\nexport async function test_api_user_todo_update_lifecycle(\n  connection: api.IConnection,\n) {\n  // 1. Register first user\n  const email1 = typia.random<string & tags.Format<\"email\">>();\n  const pass1 = RandomGenerator.alphaNumeric(9);\n  const user1 = await api.functional.auth.user.join(connection, {\n    body: {\n      email: email1,\n      password: pass1,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(user1);\n\n  // 2. Create a todo as user1\n  const baseContent = RandomGenerator.paragraph({\n    sentences: 2,\n    wordMin: 3,\n    wordMax: 12,\n  });\n  const todo = await api.functional.todoList.user.todos.create(connection, {\n    body: {\n      content: baseContent,\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo);\n  TestValidator.equals(\n    \"created content equals input\",\n    todo.content,\n    baseContent.trim(),\n  );\n  const todoId = todo.id;\n\n  // Save for later\n  let latest = todo;\n\n  // 3. Valid content update + verify\n  const newContent = RandomGenerator.paragraph({\n    sentences: 3,\n    wordMin: 4,\n    wordMax: 10,\n  });\n  const updated1 = await api.functional.todoList.user.todos.update(connection, {\n    todoId,\n    body: {\n      content: newContent,\n    } satisfies ITodoListTodo.IUpdate,\n  });\n  typia.assert(updated1);\n  TestValidator.equals(\"content updated\", updated1.content, newContent.trim());\n  TestValidator.notEquals(\"content changed\", updated1.content, latest.content);\n\n  // Check other fields unchanged\n  TestValidator.equals(\n    \"due_date unchanged after content update\",\n    updated1.due_date,\n    latest.due_date ?? null,\n  );\n\n  latest = updated1;\n\n  // 4. Set due_date (future date)\n  const future = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n  const dueDateStr = new Date(future).toISOString().substring(0, 10);\n  const updated2 = await api.functional.todoList.user.todos.update(connection, {\n    todoId,\n    body: {\n      due_date: dueDateStr,\n    } satisfies ITodoListTodo.IUpdate,\n  });\n  typia.assert(updated2);\n  TestValidator.equals(\"due date updated\", updated2.due_date, dueDateStr);\n  latest = updated2;\n\n  // 5a. Mark as completed\n  const updated3 = await api.functional.todoList.user.todos.update(connection, {\n    todoId,\n    body: {\n      completed: true,\n    } satisfies ITodoListTodo.IUpdate,\n  });\n  typia.assert(updated3);\n  TestValidator.equals(\"completed true\", updated3.completed, true);\n  TestValidator.predicate(\n    \"completed_at set\",\n    updated3.completed_at !== null && updated3.completed_at !== undefined,\n  );\n\n  // 5b. Mark as not completed\n  const updated4 = await api.functional.todoList.user.todos.update(connection, {\n    todoId,\n    body: {\n      completed: false,\n    } satisfies ITodoListTodo.IUpdate,\n  });\n  typia.assert(updated4);\n  TestValidator.equals(\"completed false\", updated4.completed, false);\n  TestValidator.predicate(\n    \"completed_at cleared\",\n    updated4.completed_at === null || updated4.completed_at === undefined,\n  );\n  latest = updated4;\n\n  // 6. Invalid content: whitespace\n  await TestValidator.error(\n    \"cannot update todo to whitespace content\",\n    async () => {\n      await api.functional.todoList.user.todos.update(connection, {\n        todoId,\n        body: {\n          content: \"    \", // whitespace only\n        } satisfies ITodoListTodo.IUpdate,\n      });\n    },\n  );\n\n  // 6b. Invalid content: empty string\n  await TestValidator.error(\"cannot update todo to empty content\", async () => {\n    await api.functional.todoList.user.todos.update(connection, {\n      todoId,\n      body: {\n        content: \"\",\n      } satisfies ITodoListTodo.IUpdate,\n    });\n  });\n\n  // 6c. Content too long (>255)\n  await TestValidator.error(\n    \"cannot update todo to too long content\",\n    async () => {\n      await api.functional.todoList.user.todos.update(connection, {\n        todoId,\n        body: {\n          content: ArrayUtil.repeat(256, () => \"a\").join(\"\"),\n        } satisfies ITodoListTodo.IUpdate,\n      });\n    },\n  );\n\n  // 7. Update nonexistent todoId\n  const randomTodoId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.error(\"updating non-existent todo fails\", async () => {\n    await api.functional.todoList.user.todos.update(connection, {\n      todoId: randomTodoId,\n      body: {\n        content: RandomGenerator.paragraph({ sentences: 2 }),\n      } satisfies ITodoListTodo.IUpdate,\n    });\n  });\n\n  // 8. Register second user (join2)\n  const email2 = typia.random<string & tags.Format<\"email\">>();\n  const pass2 = RandomGenerator.alphaNumeric(9);\n  const user2 = await api.functional.auth.user.join(connection, {\n    body: {\n      email: email2,\n      password: pass2,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(user2);\n\n  // Try update original todo as user2: should fail authz\n  await TestValidator.error(\n    \"other user cannot update owner's todo\",\n    async () => {\n      await api.functional.todoList.user.todos.update(connection, {\n        todoId,\n        body: {\n          content: RandomGenerator.paragraph({ sentences: 2 }),\n        } satisfies ITodoListTodo.IUpdate,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/todoList/admin/admins/{adminId}"},"draft":"Admin profile update workflow: Verify that an authenticated admin can successfully update another admin's profile fields, including changing name, privilege_level and status. Steps: (1) Register two admin accounts (admin A and admin B). (2) Log in as admin A. (3) Use admin A's credentials to update admin B's profile using PUT /todoList/admin/admins/{adminId}. Validate business rules: name, privilege_level, and status must be valid values, and email remains unchanged. Success criteria: Admin B's profile reflects all updated fields; sensitive fields (password_hash) are unchanged and not exposed. Error cases: Attempt update with duplicate email or invalid status - verify proper errors returned. Only authenticated admins can perform this action.","functionName":"test_api_admin_profile_update_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Register admin account A and obtain credentials for authenticated session."},{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Register admin account B to serve as the target of the update."},{"endpoint":{"method":"post","path":"/auth/admin/login"},"purpose":"Authenticate as admin A before performing the update on admin B's profile."}]},"location":"test/features/api/todo_list_admin/test_api_admin_profile_update_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Admin profile update workflow: This test verifies that when admin A is\n * authenticated, they can update another admin B's profile fields—including\n * name, privilege_level, and status—using PUT /todoList/admin/admins/{adminId}.\n * The workflow covers registration of both admins, login as admin A, profile\n * update for admin B, and validation that only the specified fields have\n * changed while protected fields remain untouched.\n *\n * Step-by-step process:\n *\n * 1. Register admin A and record join info.\n * 2. Register admin B and record join info.\n * 3. Login as admin A using their join credentials.\n * 4. Prepare a profile update for admin B: select random/fresh values for name,\n *    privilege_level, and status; do not touch email.\n * 5. Issue the update as admin A and check the response.\n * 6. Validate: name, privilege_level, and status must match what was set; email is\n *    unchanged; response includes no sensitive credential data such as\n *    password_hash.\n */\nexport async function test_api_admin_profile_update_success(\n  connection: api.IConnection,\n) {\n  // 1. Register admin A\n  const adminAEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminAPassword = RandomGenerator.alphaNumeric(12);\n  const adminAName = RandomGenerator.name();\n  const adminARegister = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminAEmail,\n      password_hash: adminAPassword,\n      name: adminAName,\n      privilege_level: \"superadmin\",\n      status: \"active\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(adminARegister);\n  const adminA = adminARegister.admin;\n\n  // 2. Register admin B\n  const adminBEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminBPassword = RandomGenerator.alphaNumeric(12);\n  const adminBName = RandomGenerator.name();\n  const adminBRegister = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminBEmail,\n      password_hash: adminBPassword,\n      name: adminBName,\n      privilege_level: \"support\",\n      status: \"active\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(adminBRegister);\n  const adminB = adminBRegister.admin;\n\n  // 3. Login as admin A\n  const adminALogin = await api.functional.auth.admin.login(connection, {\n    body: {\n      email: adminAEmail,\n      password: adminAPassword,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n  typia.assert(adminALogin);\n  TestValidator.equals(\n    \"authenticated admin id equals adminA.id\",\n    adminALogin.id,\n    adminA.id,\n  );\n\n  // 4. Prepare updated values for admin B's profile\n  const updatedName = RandomGenerator.name();\n  const updatedPrivilege = RandomGenerator.pick([\n    \"support\",\n    \"superadmin\",\n    \"auditor\",\n  ] as const);\n  const updatedStatus = RandomGenerator.pick([\n    \"active\",\n    \"locked\",\n    \"disabled\",\n    \"suspended\",\n  ] as const);\n  const updateBody = {\n    name: updatedName,\n    privilege_level: updatedPrivilege,\n    status: updatedStatus,\n  } satisfies ITodoListAdmin.IUpdate;\n\n  // 5. Execute update as admin A on admin B\n  const updated = await api.functional.todoList.admin.admins.update(\n    connection,\n    {\n      adminId: adminB.id,\n      body: updateBody,\n    },\n  );\n  typia.assert(updated);\n\n  // 6. Validate update result\n  TestValidator.equals(\"admin id is unchanged\", updated.id, adminB.id);\n  TestValidator.equals(\"admin email is unchanged\", updated.email, adminB.email);\n  TestValidator.equals(\"admin name updated\", updated.name, updatedName);\n  TestValidator.equals(\n    \"admin privilege_level updated\",\n    updated.privilege_level,\n    updatedPrivilege,\n  );\n  TestValidator.equals(\"admin status updated\", updated.status, updatedStatus);\n  TestValidator.notEquals(\"name actually changed\", updated.name, adminB.name);\n  TestValidator.notEquals(\n    \"privilege_level actually changed\",\n    updated.privilege_level,\n    adminB.privilege_level,\n  );\n  TestValidator.notEquals(\n    \"status actually changed\",\n    updated.status,\n    adminB.status,\n  );\n\n  // Sensitive field is never exposed\n  TestValidator.predicate(\n    \"password_hash not present in response\",\n    typeof (updated as any).password_hash === \"undefined\",\n  );\n}\n"},{"scenario":{"endpoint":{"method":"delete","path":"/todoList/admin/admins/{adminId}"},"draft":"Admin account deletion workflow: Validate that an authenticated admin can permanently delete another admin account via DELETE /todoList/admin/admins/{adminId}. Steps: (1) Register admin A and admin B. (2) Log in as admin A. (3) Using admin A's context, delete admin B. Validate: successful deletion returns proper status (e.g., 204 No Content). Attempting to retrieve deleted admin B with GET /todoList/admin/admins/{adminId} should result in 'not found'. Error cases: Attempt to delete a non-existent admin returns error. Only authenticated admin context is allowed to perform deletion.","functionName":"test_api_admin_deletion_by_admin_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Register admin A with admin privileges to initiate account deletion."},{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Register admin B whose account will be deleted in the test."},{"endpoint":{"method":"post","path":"/auth/admin/login"},"purpose":"Authenticate as admin A before performing the deletion."}]},"location":"test/features/api/todo_list_admin/test_api_admin_deletion_by_admin_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validates the workflow of an admin deleting another admin account.\n *\n * 1. Register admin A and admin B with unique random emails and strong passwords.\n * 2. Log in as admin A to set the context for admin-privileged actions.\n * 3. Use admin A's privileges to delete admin B via DELETE\n *    /todoList/admin/admins/{adminId}.\n * 4. Assert that deletion is successful (no error thrown, void response).\n * 5. Validate that subsequent attempt to delete B again fails (error for\n *    non-existent admin).\n */\nexport async function test_api_admin_deletion_by_admin_success(\n  connection: api.IConnection,\n) {\n  // Register admin A\n  const adminA_email = typia.random<string & tags.Format<\"email\">>();\n  const adminA_password = RandomGenerator.alphaNumeric(12);\n  const adminA_join = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminA_email,\n      password_hash: adminA_password,\n      name: RandomGenerator.name(),\n      status: \"active\",\n      privilege_level: \"superadmin\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(adminA_join);\n\n  // Register admin B\n  const adminB_email = typia.random<string & tags.Format<\"email\">>();\n  const adminB_password = RandomGenerator.alphaNumeric(12);\n  const adminB_join = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminB_email,\n      password_hash: adminB_password,\n      name: RandomGenerator.name(),\n      status: \"active\",\n      privilege_level: \"support\",\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(adminB_join);\n\n  // Authenticate as admin A\n  const adminA_login = await api.functional.auth.admin.login(connection, {\n    body: {\n      email: adminA_email,\n      password: adminA_password,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n  typia.assert(adminA_login);\n\n  // Delete admin B as admin A\n  await api.functional.todoList.admin.admins.erase(connection, {\n    adminId: adminB_join.admin.id,\n  });\n\n  // After deletion, attempting to delete again should fail (admin B not found)\n  await TestValidator.error(\"deleting non-existent admin fails\", async () => {\n    await api.functional.todoList.admin.admins.erase(connection, {\n      adminId: adminB_join.admin.id,\n    });\n  });\n}\n"},{"scenario":{"endpoint":{"method":"patch","path":"/todoList/user/todos"},"draft":"User todo list search and pagination: Verify that an authenticated user can retrieve only their own todos, filtered by content or completion status, and paginated according to supplied parameters. Steps: (1) Register and authenticate as a user. (2) Create multiple todos for this account. (3) Use PATCH /todoList/user/todos with various filters (e.g., content substring, completed=false) and pagination (page size, offset). Confirm that only this user's todos are returned, and filters/pagination work as intended. Edge cases: Request with filters yielding zero results, paginating beyond available todos, requesting with negative page values results in error messages. All access requires valid user authentication.","functionName":"test_api_user_todo_list_pagination_and_filtering","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Register a new user account for end-to-end todo list feature testing."},{"endpoint":{"method":"post","path":"/auth/user/login"},"purpose":"Authenticate with user credentials required to use todos API."},{"endpoint":{"method":"post","path":"/todoList/user/todos"},"purpose":"Create multiple todo items as data setup for testing search, filter, and pagination scenarios."}]},"location":"test/features/api/todo_list_todo/test_api_user_todo_list_pagination_and_filtering.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Tests that an authenticated user can search and paginate their own todo\n * items, using search term/content filter, completed status, and pagination\n * params.\n *\n * Steps:\n *\n * 1. Register a new user and authenticate (join and login)\n * 2. Create multiple (e.g. 20) todo items for this user (vary content and\n *    completed status)\n * 3. Use PATCH /todoList/user/todos with:\n *\n *    - No filters/pagination, expect to retrieve all todos for user\n *    - A content search term matching a known substring, expect filtered subset\n *    - Completed=false, get only incomplete todos\n *    - Pagination (page/limit), get limited results and verify correct page/offset\n *    - Filter combination (search+completed)\n *    - Edge: filter that produces zero results (nonsense substring)\n *    - Edge: page beyond last data\n *    - Edge: negative page values, expect error\n *\n * All responses only return the user's own todos and never leak other users'\n * data.\n */\nexport async function test_api_user_todo_list_pagination_and_filtering(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user\n  const userEmail = typia.random<string & tags.Format<\"email\">>();\n  const userPassword = RandomGenerator.alphaNumeric(12);\n  const userJoinBody = {\n    email: userEmail,\n    password: userPassword,\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n  } satisfies ITodoListUser.IJoin;\n  const joinResult = await api.functional.auth.user.join(connection, {\n    body: userJoinBody,\n  });\n  typia.assert(joinResult);\n  TestValidator.equals(\"user created email\", joinResult.user.email, userEmail);\n\n  // 2. Authenticate user (login) to get token\n  const loginResult = await api.functional.auth.user.login(connection, {\n    body: {\n      email: userEmail,\n      password: userPassword,\n    } satisfies ITodoListUser.ILogin,\n  });\n  typia.assert(loginResult);\n  TestValidator.equals(\"login user email\", loginResult.user.email, userEmail);\n\n  // 3. Create multiple todo items for this user\n  const contents = ArrayUtil.repeat(\n    20,\n    (i) =>\n      `Todo #${i + 1} - ${RandomGenerator.paragraph({ sentences: 2, wordMin: 3, wordMax: 7 })}`,\n  );\n  const completedIdxs = new Set(\n    ArrayUtil.repeat(7, () => Math.floor(Math.random() * contents.length)),\n  );\n  const createdTodos: ITodoListTodo[] = [];\n  for (let i = 0; i < contents.length; ++i) {\n    const body = {\n      content: contents[i] as string & tags.MaxLength<255>,\n      due_date: null,\n    } satisfies ITodoListTodo.ICreate;\n    const todo = await api.functional.todoList.user.todos.create(connection, {\n      body,\n    });\n    typia.assert(todo);\n    if (completedIdxs.has(i)) {\n      // Direct update not possible - only create has completed=false and update API not in scope, so we only create as incomplete\n      // Would require PATCH /todoList/user/todos/:id to mark as completed, which is not given, so skip completed=true scenarios\n    }\n    createdTodos.push(todo);\n  }\n\n  // 4. Filter: fetch all (no filter)\n  const allTodosPage = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: {} satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(allTodosPage);\n  TestValidator.equals(\n    \"all user todos count\",\n    allTodosPage.data.length,\n    createdTodos.length,\n  );\n  // 5. Filter: content substring (choose substring from a random todo)\n  const sampleContent = RandomGenerator.pick(contents);\n  const filterSubstring = RandomGenerator.substring(sampleContent).slice(0, 15); // limit length\n  const filterResult = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: {\n        search: filterSubstring,\n      } satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(filterResult);\n  TestValidator.predicate(\n    \"filtered todos contain substring\",\n    filterResult.data.every((t) => t.content.includes(filterSubstring)),\n  );\n\n  // 6. Filter: completed=false (should return all as incomplete)\n  const notCompletedResult = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: {\n        completed: false,\n      } satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(notCompletedResult);\n  TestValidator.equals(\n    \"not completed todos all incomplete\",\n    notCompletedResult.data.filter((t) => t.completed).length,\n    0,\n  );\n\n  // 7. Pagination: page=2, limit=5\n  const page2Result = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: {\n        limit: 5,\n        page: 2,\n      } satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(page2Result);\n  TestValidator.equals(\"page 2 count\", page2Result.data.length, 5);\n  TestValidator.equals(\n    \"page 2 current page\",\n    page2Result.pagination.current,\n    2,\n  );\n\n  // 8. Pagination: beyond last page\n  const highPage = 100;\n  const beyondResult = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: {\n        page: highPage,\n        limit: 5,\n      } satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(beyondResult);\n  TestValidator.equals(\n    \"beyond last page is empty\",\n    beyondResult.data.length,\n    0,\n  );\n\n  // 9. Search+completed filter (empty result, as all are incomplete)\n  const nonsenseSearch = \"ZZZX_NO_TODO_CONTENT\";\n  const noMatchResult = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: {\n        search: nonsenseSearch,\n      } satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(noMatchResult);\n  TestValidator.equals(\"no matching todos\", noMatchResult.data.length, 0);\n\n  // 10. Negative page value: expects error\n  await TestValidator.error(\"negative page should fail\", async () => {\n    await api.functional.todoList.user.todos.index(connection, {\n      body: {\n        page: -1 as number & tags.Type<\"int32\">,\n        limit: 5,\n      } satisfies ITodoListTodo.IRequest,\n    });\n  });\n}\n"},{"scenario":{"endpoint":{"method":"patch","path":"/todoList/admin/todos"},"draft":"Admin todo search workflow: Validate that an authenticated admin can access all users' todos with advanced filters (content, completed status, due date) and pagination. Steps: (1) Register and authenticate as an admin. (2) Register two separate user accounts, and authenticate with each to create todos under each user. (3) Using admin context, call PATCH /todoList/admin/todos with filters targeting specific user's todos and content patterns. Check that results properly reflect requested search across all users' tasks and only soft-deleted users/todos are absent. Edge cases: Query admin todos with filters yielding empty results, invalid/negative pagination, unauthorized admin context. Confirm only valid admin context is allowed.","functionName":"test_api_admin_todo_list_access_filtering","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Register an admin user to perform todos administrative queries."},{"endpoint":{"method":"post","path":"/auth/admin/login"},"purpose":"Authenticate as admin prior to accessing the admin todos endpoint."},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Register user account 1 for generating test todos for query coverage."},{"endpoint":{"method":"post","path":"/auth/user/login"},"purpose":"Authenticate as user 1 to create their todos as admin cannot create todos for users."},{"endpoint":{"method":"post","path":"/todoList/user/todos"},"purpose":"Create todos under user 1 for test coverage in admin filtering."},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Register user account 2 for generating additional test todos under a separate user."},{"endpoint":{"method":"post","path":"/auth/user/login"},"purpose":"Authenticate as user 2 to create their todos for cross-user search validation."},{"endpoint":{"method":"post","path":"/todoList/user/todos"},"purpose":"Create todos under user 2 for validating admin's full system access."}]},"location":"test/features/api/todo_list/test_api_admin_todo_list_access_filtering.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * 관리자 권한으로 admin todos 목록 검색/필터링 접근 실동 검증\n *\n * 1. 관리자로 회원가입/로그인\n * 2. User 2명 가입 후 각각 로그인/각자 여러 todo 생성\n * 3. Admin 컨텍스트로 전환 후 PATCH /todoList/admin/todos 다양한 필터로 접근 검증\n * 4. 필터 결과가 각 조건대로 정확히 반영 -> 특정 user의 todo만/전체 크로스 검색/빈 결과/잘못된 페이지 등\n * 5. User context/미인증 context서 접근 시 권한거부\n */\nexport async function test_api_admin_todo_list_access_filtering(\n  connection: api.IConnection,\n) {\n  // 1. 관리자로 회원가입\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPw = RandomGenerator.alphaNumeric(10);\n  const adminJoin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password_hash: adminPw,\n      name: RandomGenerator.name(),\n      avatar_uri: null,\n      // status, privilege_level optional\n    } satisfies ITodoListAdmin.IJoin,\n  });\n  typia.assert(adminJoin);\n\n  // 2. user1, user2 가입/로그인/할일 생성\n  const users: { email: string; pw: string; todos: ITodoListTodo[] }[] = [];\n  for (let i = 0; i < 2; ++i) {\n    const userEmail = typia.random<string & tags.Format<\"email\">>();\n    const userPw = RandomGenerator.alphaNumeric(10);\n    const userJoin = await api.functional.auth.user.join(connection, {\n      body: {\n        email: userEmail,\n        password: userPw,\n        name: RandomGenerator.name(),\n        avatar_uri: null,\n      } satisfies ITodoListUser.IJoin,\n    });\n    typia.assert(userJoin);\n    // 로그인하여 토큰 갱신\n    const userLogin = await api.functional.auth.user.login(connection, {\n      body: {\n        email: userEmail,\n        password: userPw,\n      } satisfies ITodoListUser.ILogin,\n    });\n    typia.assert(userLogin);\n    // 각자 여러 todo 생성 (완료/미완료/마감일 지정 등 혼합)\n    const todos: ITodoListTodo[] = [];\n    for (let t = 0; t < 3; ++t) {\n      const todo = await api.functional.todoList.user.todos.create(connection, {\n        body: {\n          content: RandomGenerator.paragraph({ sentences: 4 }),\n          due_date:\n            t % 2 === 0\n              ? new Date(Date.now() + (t + 1) * 86400_000).toISOString()\n              : undefined,\n        } satisfies ITodoListTodo.ICreate,\n      });\n      typia.assert(todo);\n      todos.push(todo);\n    }\n    users.push({ email: userEmail, pw: userPw, todos });\n  }\n\n  // 3. admin으로 다시 로그인 (context 전환)\n  await api.functional.auth.admin.login(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPw,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n\n  // 4. admin todo 검색: 전체(TODO), content 필터(키워드), 완료/미완료, due_date 등\n  // 전체 검색\n  const resAll = await api.functional.todoList.admin.todos.index(connection, {\n    body: {},\n  });\n  typia.assert(resAll);\n  // 모든 user의 todos가 포함되는지\n  for (const u of users) {\n    for (const expected of u.todos) {\n      TestValidator.predicate(\n        `모든 사용자 todo 포함(ID=${expected.id})`,\n        resAll.data.some((todo) => todo.id === expected.id),\n      );\n    }\n  }\n  // content 부분 일치 검색 (부분문자열, 대소문자 무관)\n  for (const u of users) {\n    const searched = await api.functional.todoList.admin.todos.index(\n      connection,\n      {\n        body: { search: RandomGenerator.substring(u.todos[0].content) },\n      },\n    );\n    typia.assert(searched);\n    TestValidator.predicate(\n      `content 부분검색 결과 포함(ID=${u.todos[0].id})`,\n      searched.data.some((todo) => todo.id === u.todos[0].id),\n    );\n  }\n  // completed 별 검색\n  for (const completed of [false, true]) {\n    // 마킹 - 한 user의 todo를 임의로 완료\n    const u = users[0];\n    const todo = u.todos[0];\n    if (!todo.completed && completed) {\n      // 인위적으로 완성상태 처리는 따로 제공 API가 없으므로 skip\n      continue;\n    }\n    const result = await api.functional.todoList.admin.todos.index(connection, {\n      body: { completed },\n    });\n    typia.assert(result);\n    for (const d of result.data) {\n      TestValidator.equals(\n        `completed=${completed}인 모든 todo`,\n        d.completed,\n        completed,\n      );\n    }\n  }\n  // due_date(마감일만 필터) 검색\n  {\n    // user2의 두번째 todo의 due_date로 필터\n    const filterDate = users[1].todos[1].due_date;\n    if (filterDate) {\n      const dueFiltered = await api.functional.todoList.admin.todos.index(\n        connection,\n        {\n          body: { due_date: filterDate },\n        },\n      );\n      typia.assert(dueFiltered);\n      for (const d of dueFiltered.data) {\n        TestValidator.equals(`due_date 일치 todo`, d.due_date, filterDate);\n      }\n    }\n  }\n\n  // 페이지네이션/page/limit\n  const totalCount = users[0].todos.length + users[1].todos.length;\n  {\n    const onePage = await api.functional.todoList.admin.todos.index(\n      connection,\n      {\n        body: { limit: 1 },\n      },\n    );\n    typia.assert(onePage);\n    TestValidator.equals(\"limit=1에서는 한 건만 반환\", onePage.data.length, 1);\n    const secondPage = await api.functional.todoList.admin.todos.index(\n      connection,\n      {\n        body: { page: 2, limit: 1 },\n      },\n    );\n    typia.assert(secondPage);\n    TestValidator.equals(\"2페이지에서 한 건 반환\", secondPage.data.length, 1);\n  }\n  // 잘못된 page/limit(음수/0/null 등)에 대해 빈 결과/예외처리 (여기선 빈 결과만 확인)\n  for (const page of [-1, 0]) {\n    const invalid = await api.functional.todoList.admin.todos.index(\n      connection,\n      {\n        body: { page: page satisfies number as number },\n      },\n    );\n    typia.assert(invalid);\n    TestValidator.equals(`페이지값 ${page}은 빈 목록`, invalid.data.length, 0);\n  }\n  {\n    const noMatch = await api.functional.todoList.admin.todos.index(\n      connection,\n      {\n        body: { search: \"nonexistentkeyword\" },\n      },\n    );\n    typia.assert(noMatch);\n    TestValidator.equals(\"일치하는 todo 없음\", noMatch.data.length, 0);\n  }\n  // 5. 일반 user나 미로그인 context 접근 시 권한 거부\n  // user1로 로그인+access\n  await api.functional.auth.user.login(connection, {\n    body: {\n      email: users[0].email,\n      password: users[0].pw,\n    } satisfies ITodoListUser.ILogin,\n  });\n  await TestValidator.error(\"user 권한으로 admin todos 접근 금지\", async () => {\n    await api.functional.todoList.admin.todos.index(connection, { body: {} });\n  });\n  // 미인증 context: header 제거\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\"미인증시 admin todos 접근 금지\", async () => {\n    await api.functional.todoList.admin.todos.index(unauthConn, { body: {} });\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/todos/{todoId}","method":"put"},"draft":"Test updating an existing todo as an admin. Scenario covers successful update, permissions, audit trail impact, and error states. Steps: 1) Register and log in as an admin, 2) Register and log in as a user, 3) As the user, create a todo, 4) As the admin, perform an update to the user's todo by ID (e.g., change content, completion status, or due date), 5) Validate successful update and correct field changes, 6) Confirm that an appropriate audit log entry is made reflecting update action, 7) Attempt update with invalid todoId (expect not found), 8) Attempt update as non-admin user (expect forbidden).","functionName":"test_api_admin_todo_update_with_full_audit_trail","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register/admin authentication."},{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register/user authentication."},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create todo with user account for update."}]},"location":"test/features/api/todo_list_todo/test_api_admin_todo_update_with_full_audit_trail.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validates updating a user's todo via admin endpoint, including permissions,\n * successful update, and error cases.\n *\n * 1. Register and login as admin (admin join)\n * 2. Register and login as user (user join)\n * 3. As user, create a todo\n * 4. As admin, update that todo (change content, completed state, due date)\n * 5. Validate changes applied correctly\n * 6. Confirm updated_at changed and other fields preserved (simulate audit via\n *    updated_at change, since direct audit log is not available)\n * 7. Attempt to update with random/nonexistent todoId (expect error)\n * 8. Try update as user (not admin) (expect error/forbidden)\n */\nexport async function test_api_admin_todo_update_with_full_audit_trail(\n  connection: api.IConnection,\n) {\n  // 1. Register admin\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminJoin = {\n    email: adminEmail,\n    password_hash: RandomGenerator.alphaNumeric(16),\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n    status: \"active\",\n    privilege_level: \"support\",\n  } satisfies ITodoListAdmin.IJoin;\n  const adminAuth = await api.functional.auth.admin.join(connection, {\n    body: adminJoin,\n  });\n  typia.assert(adminAuth);\n\n  // 2. Register user\n  const userEmail = typia.random<string & tags.Format<\"email\">>();\n  const userJoin = {\n    email: userEmail,\n    password: RandomGenerator.alphaNumeric(16),\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n  } satisfies ITodoListUser.IJoin;\n  const userAuth = await api.functional.auth.user.join(connection, {\n    body: userJoin,\n  });\n  typia.assert(userAuth);\n\n  // 3. As user, create a todo\n  const userConnection: api.IConnection = { ...connection };\n  userConnection.headers = { ...connection.headers };\n  userConnection.headers.Authorization = userAuth.token.access;\n  const todoContent = RandomGenerator.paragraph({ sentences: 2 });\n  const todoDue = new Date(Date.now() + 24 * 60 * 60 * 1000)\n    .toISOString()\n    .slice(0, 10);\n  const todoCreate = {\n    content: todoContent,\n    due_date: todoDue,\n  } satisfies ITodoListTodo.ICreate;\n  const createdTodo = await api.functional.todoList.user.todos.create(\n    userConnection,\n    { body: todoCreate },\n  );\n  typia.assert(createdTodo);\n\n  // 4. As admin, update the todo\n  connection.headers = { ...connection.headers };\n  connection.headers.Authorization = adminAuth.token.access;\n  const updateContent = RandomGenerator.paragraph({ sentences: 3 });\n  const updateDue = new Date(Date.now() + 2 * 24 * 60 * 60 * 1000)\n    .toISOString()\n    .slice(0, 10);\n  const updateBody = {\n    content: updateContent,\n    due_date: updateDue,\n    completed: true,\n  } satisfies ITodoListTodo.IUpdate;\n  const updatedTodo = await api.functional.todoList.admin.todos.update(\n    connection,\n    {\n      todoId: createdTodo.id,\n      body: updateBody,\n    },\n  );\n  typia.assert(updatedTodo);\n  TestValidator.equals(\n    \"todo was updated: content\",\n    updatedTodo.content,\n    updateContent,\n  );\n  TestValidator.equals(\n    \"todo was updated: due_date\",\n    updatedTodo.due_date,\n    updateDue,\n  );\n  TestValidator.equals(\n    \"todo was updated: completed\",\n    updatedTodo.completed,\n    true,\n  );\n\n  // 5. Confirm updated_at changed\n  TestValidator.notEquals(\n    \"updated_at changed after update\",\n    updatedTodo.updated_at,\n    createdTodo.updated_at,\n  );\n\n  // 6. Negative case: update with random/nonexistent todoId\n  const nonExistTodoId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.error(\n    \"update with nonexistent todoId yields error\",\n    async () => {\n      await api.functional.todoList.admin.todos.update(connection, {\n        todoId: nonExistTodoId,\n        body: updateBody,\n      });\n    },\n  );\n\n  // 7. Negative case: update as user (not admin)\n  userConnection.headers.Authorization = userAuth.token.access;\n  await TestValidator.error(\"update as user forbidden\", async () => {\n    await api.functional.todoList.admin.todos.update(userConnection, {\n      todoId: createdTodo.id,\n      body: updateBody,\n    });\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/user/todos/{todoId}","method":"delete"},"draft":"Test hard-deletion of a todo by its owner (user). Steps: 1) Register and log in as a user, 2) Create a new todo, 3) Delete the todo by ID, 4) Verify deletion and that the todo is no longer retrievable/searchable, 5) Attempt repeat deletion (expect not found), 6) Attempt to delete a todo as a non-owner or unauthenticated (expect forbidden/error). Test for proper business error messaging, hard delete semantics, and owner permission enforcement.","functionName":"test_api_user_todo_deletion_standard_and_edge_cases","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register/user authentication."},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create todo for deletion test."}]},"location":"test/features/api/todo_list_todo/test_api_user_todo_deletion_standard_and_edge_cases.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * End-to-end test for hard deletion of a todo (standard and edge cases).\n *\n * This test covers:\n *\n * 1. New user registration and login flow (user owner context)\n * 2. Todo creation\n * 3. Deletion of the owned todo by ID (should succeed, no error)\n * 4. Verifying that repeat deletion on the same ID fails with not found or error\n * 5. Deletion as unauthenticated (should error/forbid)\n * 6. Deletion as a non-owner user (should error/forbid)\n * 7. Deduplication window check: after deletion, a new todo with identical content\n *    can be made (no ghost remains)\n */\nexport async function test_api_user_todo_deletion_standard_and_edge_cases(\n  connection: api.IConnection,\n) {\n  // 1. Register first user\n  const user1Email = typia.random<string & tags.Format<\"email\">>();\n  const user1Password = RandomGenerator.alphaNumeric(12);\n  const user1Join = await api.functional.auth.user.join(connection, {\n    body: {\n      email: user1Email,\n      password: user1Password,\n      name: RandomGenerator.name(),\n      avatar_uri: null,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(user1Join);\n\n  // 2. Create a new todo with user1\n  const todoContent = RandomGenerator.paragraph({\n    sentences: 2,\n    wordMin: 3,\n    wordMax: 8,\n  });\n  const todoDueDate = null;\n  const todo = await api.functional.todoList.user.todos.create(connection, {\n    body: {\n      content: todoContent,\n      due_date: todoDueDate,\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo);\n  TestValidator.equals(\"todo content matches\", todo.content, todoContent);\n  TestValidator.equals(\n    \"todo owner matches user1\",\n    todo.todo_list_user_id,\n    user1Join.user.id,\n  );\n\n  // 3. Hard delete the todo\n  await api.functional.todoList.user.todos.erase(connection, {\n    todoId: todo.id,\n  });\n\n  // 4. Attempt to delete again (should yield error)\n  await TestValidator.error(\"repeat delete is not found or error\", async () => {\n    await api.functional.todoList.user.todos.erase(connection, {\n      todoId: todo.id,\n    });\n  });\n\n  // 5. Deletion as unauthenticated (should not be allowed)\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\"unauthenticated erase is forbidden\", async () => {\n    await api.functional.todoList.user.todos.erase(unauthConn, {\n      todoId: todo.id,\n    });\n  });\n\n  // 6. Register second user and try to erase user1's deleted todo (should fail)\n  const user2Email = typia.random<string & tags.Format<\"email\">>();\n  const user2Password = RandomGenerator.alphaNumeric(12);\n  const user2Join = await api.functional.auth.user.join(connection, {\n    body: {\n      email: user2Email,\n      password: user2Password,\n      name: RandomGenerator.name(),\n      avatar_uri: null,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(user2Join);\n  await TestValidator.error(\n    \"other user cannot erase another's (even deleted) todo\",\n    async () => {\n      await api.functional.todoList.user.todos.erase(connection, {\n        todoId: todo.id,\n      });\n    },\n  );\n\n  // 7. User1 should be able to re-create identical content todo after deletion\n  await api.functional.auth.user.join(connection, {\n    body: {\n      email: user1Email,\n      password: user1Password,\n    } satisfies ITodoListUser.IJoin,\n  });\n  const todo2 = await api.functional.todoList.user.todos.create(connection, {\n    body: {\n      content: todoContent,\n      due_date: todoDueDate,\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo2);\n  TestValidator.equals(\n    \"recreated todo content matches\",\n    todo2.content,\n    todoContent,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/todos/{todoId}","method":"delete"},"draft":"Test hard-deletion of a todo as an admin. Steps: 1) Register and log in as an admin, 2) Register and log in as a user, 3) As the user, create a todo, 4) As the admin, delete the user's todo by ID, 5) Verify that the todo is deleted and irretrievable, 6) Confirm an audit log entry is registered indicating the admin action, 7) Attempt to delete a nonexistent todo (expect not found), 8) Attempt delete as unauthorized user/role (expect forbidden).","functionName":"test_api_admin_todo_deletion_with_audit_and_permissions","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register/admin authentication."},{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register/user authentication."},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create todo as user for admin deletion."}]},"location":"test/features/api/todo/test_api_admin_todo_deletion_with_audit_and_permissions.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test E2E: Admin can hard-delete a todo, permission enforcement, not-found and\n * forbidden cases.\n *\n * 1. Register an admin; store admin token.\n * 2. Register a user; store user token.\n * 3. User creates a todo (as owner).\n * 4. As admin, delete user todo by ID.\n * 5. Try to access deleted todo – since there's no GET endpoint, only confirm\n *    successful deletion by trusting type system.\n * 6. (If possible: verify audit log for admin action – SKIPPED as audit API is not\n *    available in imports.)\n * 7. Try to delete non-existent todo as admin (should error).\n * 8. Try to delete todo as user (should fail - forbidden).\n */\nexport async function test_api_admin_todo_deletion_with_audit_and_permissions(\n  connection: api.IConnection,\n) {\n  // 1. Register an admin\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword: string = RandomGenerator.alphaNumeric(12);\n  const admin: ITodoListAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password_hash: adminPassword,\n        name: RandomGenerator.name(),\n        avatar_uri: null,\n        status: \"active\",\n        privilege_level: \"superadmin\",\n      } satisfies ITodoListAdmin.IJoin,\n    });\n  typia.assert(admin);\n\n  // 2. Register a user\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const userPassword: string = RandomGenerator.alphaNumeric(10);\n  const user: ITodoListUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: {\n        email: userEmail,\n        password: userPassword,\n        name: RandomGenerator.name(),\n        avatar_uri: null,\n      } satisfies ITodoListUser.IJoin,\n    },\n  );\n  typia.assert(user);\n\n  // 3. User creates a todo\n  const todo: ITodoListTodo = await api.functional.todoList.user.todos.create(\n    connection,\n    {\n      body: {\n        content: RandomGenerator.paragraph({\n          sentences: 2,\n          wordMin: 4,\n          wordMax: 8,\n        }) satisfies string as string,\n        due_date: null,\n      } satisfies ITodoListTodo.ICreate,\n    },\n  );\n  typia.assert(todo);\n  TestValidator.equals(\"todo owner is user\", todo.todo_list_user_id, user.id);\n\n  // 4. Switch to admin\n  await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password_hash: adminPassword,\n    } satisfies ITodoListAdmin.IJoin,\n  });\n\n  // 5. Admin deletes the user's todo\n  await api.functional.todoList.admin.todos.erase(connection, {\n    todoId: todo.id,\n  });\n\n  // 6. Try to delete the same todo again – should throw not found\n  await TestValidator.error(\n    \"admin deleting nonexistent todo fails\",\n    async () => {\n      await api.functional.todoList.admin.todos.erase(connection, {\n        todoId: todo.id,\n      });\n    },\n  );\n\n  // 7. Switch to user context\n  await api.functional.auth.user.join(connection, {\n    body: {\n      email: userEmail,\n      password: userPassword,\n    } satisfies ITodoListUser.IJoin,\n  });\n\n  // 8. As user, try to delete the (already deleted) todo - should fail (forbidden)\n  await TestValidator.error(\n    \"user forbidden to delete todo via admin endpoint\",\n    async () => {\n      await api.functional.todoList.admin.todos.erase(connection, {\n        todoId: todo.id,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/auditLogs","method":"patch"},"draft":"Test searching and filtering admin audit logs for todo actions. Steps: 1) Register and log in as an admin, 2) Register and log in as a user, 3) As the user, create a todo, 4) As the admin, perform an action on the user's todo (e.g., view, update, or delete), 5) As admin, query audit logs for records matching the adminId, userId, and todoId used, 6) Verify logs accurately reflect admin actions, including all required audit metadata, 7) Test invalid filters (expect empty results or clear errors), 8) Attempt audit log search as unauthorized (expect forbidden).","functionName":"test_api_admin_audit_log_search_for_todo_actions","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register/admin authentication."},{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register/user authentication."},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create todo for admin action and log filtering."},{"endpoint":{"path":"/todoList/admin/todos/{todoId}","method":"delete"},"purpose":"Admin deletes user todo to generate audit log."}]},"location":"test/features/api/audit_log/test_api_admin_audit_log_search_for_todo_actions.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListAuditLog } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAuditLog\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListAuditLog } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAuditLog\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate admin audit log search and filter functionality for todo actions in\n * the system.\n *\n * This test ensures:\n *\n * 1. Admin can register and log in\n * 2. User can register and log in\n * 3. User creates a todo\n * 4. Admin deletes user's todo (generates audit log)\n * 5. Admin can query audit logs filtered by adminId, userId, and todoId, and\n *    result includes the generated entry\n * 6. Returned log entry matches the correct metadata (adminId, userId, todoId,\n *    action, rationale, timestamp)\n * 7. Filtering with invalid combinations (nonexistent adminId, userId, or todoId)\n *    yields no results\n * 8. Unauthorized (non-admin or unauthenticated) user cannot access audit log\n *    search (expects error)\n */\nexport async function test_api_admin_audit_log_search_for_todo_actions(\n  connection: api.IConnection,\n) {\n  // 1. Register & authenticate as admin\n  const adminJoin = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password_hash: RandomGenerator.alphaNumeric(12),\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n    privilege_level: \"support\",\n    status: \"active\",\n  } satisfies ITodoListAdmin.IJoin;\n  const adminAuth = await api.functional.auth.admin.join(connection, {\n    body: adminJoin,\n  });\n  typia.assert(adminAuth);\n  const adminId = adminAuth.id;\n\n  // 2. Register & authenticate as user\n  const userJoin = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12),\n    name: RandomGenerator.name(),\n    avatar_uri: null,\n  } satisfies ITodoListUser.IJoin;\n  const userAuth = await api.functional.auth.user.join(connection, {\n    body: userJoin,\n  });\n  typia.assert(userAuth);\n  const userId = userAuth.id;\n\n  // 3. User creates a todo\n  await api.functional.auth.user.join(connection, { body: userJoin }); // context switch\n  const todoBody = {\n    content: RandomGenerator.paragraph({\n      sentences: 3,\n      wordMin: 5,\n      wordMax: 10,\n    }),\n  } satisfies ITodoListTodo.ICreate;\n  const todo = await api.functional.todoList.user.todos.create(connection, {\n    body: todoBody,\n  });\n  typia.assert(todo);\n  const todoId = todo.id;\n\n  // 4. Admin deletes user's todo (must context switch to admin)\n  await api.functional.auth.admin.join(connection, { body: adminJoin }); // context switch\n  await api.functional.todoList.admin.todos.erase(connection, { todoId });\n\n  // 5. Admin queries audit logs filtered by all keys (adminId, userId, todoId)\n  const logsRes = await api.functional.todoList.admin.auditLogs.index(\n    connection,\n    {\n      body: {\n        todo_list_admin_id: adminId,\n        todo_list_user_id: userId,\n        todo_list_todo_id: todoId,\n        action: \"delete\",\n        page: 1,\n        limit: 10,\n      } satisfies ITodoListAuditLog.IRequest,\n    },\n  );\n  typia.assert(logsRes);\n  TestValidator.predicate(\n    \"should include at least one audit log for admin delete action on this todo,user\",\n    logsRes.data.some(\n      (entry) =>\n        entry.todo_list_admin_id === adminId &&\n        entry.todo_list_user_id === userId &&\n        entry.todo_list_todo_id === todoId &&\n        entry.action === \"delete\",\n    ),\n  );\n\n  // 6. Log entry fields correctness\n  const auditEntry = logsRes.data.find(\n    (l) =>\n      l.todo_list_admin_id === adminId &&\n      l.todo_list_user_id === userId &&\n      l.todo_list_todo_id === todoId,\n  );\n  if (auditEntry) {\n    TestValidator.equals(\"action is delete\", auditEntry.action, \"delete\");\n    typia.assert<ITodoListAuditLog.ISummary>(auditEntry);\n  } else {\n    throw new Error(\"Audit log for deleted todo not found\");\n  }\n\n  // 7. Filtering with invalid (random) ids yields no results\n  const invalidFilterRes = await api.functional.todoList.admin.auditLogs.index(\n    connection,\n    {\n      body: {\n        todo_list_admin_id: typia.random<string & tags.Format<\"uuid\">>(),\n        todo_list_user_id: typia.random<string & tags.Format<\"uuid\">>(),\n        todo_list_todo_id: typia.random<string & tags.Format<\"uuid\">>(),\n        action: \"view\",\n        page: 1,\n        limit: 5,\n      } satisfies ITodoListAuditLog.IRequest,\n    },\n  );\n  typia.assert(invalidFilterRes);\n  TestValidator.equals(\n    \"empty audit log result for invalid filter\",\n    invalidFilterRes.data.length,\n    0,\n  );\n\n  // 8. Attempt as unauthorized/unauthenticated: clear admin session => expect forbidden\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\n    \"audit log search forbidden for unauthenticated/unauthorized user\",\n    async () => {\n      await api.functional.todoList.admin.auditLogs.index(unauthConn, {\n        body: {\n          todo_list_admin_id: adminId,\n          action: \"delete\",\n        } satisfies ITodoListAuditLog.IRequest,\n      });\n    },\n  );\n}\n"}],"compiled":{"type":"success"},"created_at":"2025-09-23T06:04:30.904Z","completed_at":"2025-09-23T06:11:18.480Z","step":0},{"type":"realize","id":"0199753b-afdf-7519-a5cf-bf1069a54bb0","reason":"Validate agent realize","authorizations":[{"error_analysis":"MyGlobal.ts error: Cannot find module './MyConfiguration' (TS2307). Decorator/Provider may not import or reference the missing config file but definitions are otherwise correct. File structure and provider/decorator logic unaffected.","solution_guidance":"Update local project dependencies to provide missing './MyConfiguration' or stub in test. Decorator/provider themselves require no code changes for their own TypeScript signature or implementation. Verify imports and logic again after resolving MyGlobal.ts error to ensure there are no cascading type errors.","provider":{"name":"userAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { UserPayload } from \"../../decorators/payload/UserPayload\";\n\n/**\n * Authorize function for users. Validates JWT, checks 'user' type, and ensures the user exists and is not deleted or disabled.\n *\n * @param request Incoming HTTP request with headers\n * @returns Authenticated user's payload\n * @throws ForbiddenException if user is not authenticated, not a 'user', deleted, or status is not 'active'.\n */\nexport async function userAuthorize(request: {\n  headers: {\n    authorization?: string;\n  };\n}): Promise<UserPayload> {\n  const payload: UserPayload = jwtAuthorize({ request }) as UserPayload;\n\n  if (payload.type !== \"user\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // payload.id refers to todo_list_users.id (top-level user ID)\n  const user = await MyGlobal.prisma.todo_list_users.findFirst({\n    where: {\n      id: payload.id,\n      deleted_at: null,\n      status: \"active\"\n    },\n  });\n\n  if (user === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/userAuthorize.ts"},"decorator":{"name":"UserAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { userAuthorize } from \"../providers/authorize/userAuthorize\";\n\n/**\n * Parameter decorator for injecting an authenticated user (`UserPayload`) into controller routes.\n *\n * Adds Bearer authentication to Swagger docs and validates the user authorization.\n */\nexport const UserAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_0: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return userAuthorize(request);\n  })(),\n);","location":"src/decorators/UserAuth.ts"},"payload":{"name":"UserPayload","location":"src/decorators/payload/UserPayload.ts","content":"import { tags } from \"typia\";\n\n/**\n * Payload injected when a user is authenticated through UserAuth.\n *\n * - Id: todo_list_users.id (top-level user identifier)\n * - Type: always 'user' for standard members\n */\nexport interface UserPayload {\n  /** Top-level user table ID (unique identifier for the user). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the user role. */\n  type: \"user\";\n}\n"},"role":{"name":"user","description":"A registered member who can create, read, update, and delete their own todos. Can check or uncheck tasks and view a list of their todos. Cannot access or modify other users' data.","kind":"member"}},{"error_analysis":"No compilation error in provider/decorator, but 'AdminProvider'/'AdminDecorator' naming does not match policy (should be 'adminAuthorize' and 'AdminAuth'). File src/MyGlobal.ts error: missing './MyConfiguration' is unrelated. Provider/Decorator code not affected. Provider: uses correct table, status, and deleted_at checks. Decorator logic is correct.","solution_guidance":"Rename provider function to 'adminAuthorize' and decorator to 'AdminAuth' as per naming convention. Ensure correct imports, interface/type consistent across files, and schema-based status checks. The Prisma error in MyGlobal.ts is not actionable here. Only Decorator/Provider names must be corrected, all other logic is already correct.","provider":{"name":"adminAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { AdminPayload } from \"../../decorators/payload/AdminPayload\";\n\n/**\n * Authenticate and authorize admin accounts via JWT.\n *\n * Verifies JWT tokens for admin role, checks token payload validity, and ensures\n * the corresponding admin exists and is not soft-deleted or disabled.\n *\n * @param request HTTP request object containing authorization header\n * @returns Authenticated AdminPayload\n * @throws ForbiddenException if not admin or not enrolled/active\n */\nexport async function adminAuthorize(request: {\n  headers: {\n    authorization?: string;\n  };\n}): Promise<AdminPayload> {\n  // Extract and verify the JWT for admin role\n  const payload: AdminPayload = jwtAuthorize({ request }) as AdminPayload;\n\n  if (payload.type !== \"admin\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // Validate admin existence and status (using top-level admin id)\n  const admin = await MyGlobal.prisma.todo_list_admins.findFirst({\n    where: {\n      id: payload.id,\n      deleted_at: null,\n      status: \"active\"\n    },\n  });\n\n  if (admin === null) {\n    throw new ForbiddenException(\"You're not enrolled or not active\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/adminAuthorize.ts"},"decorator":{"name":"AdminAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { adminAuthorize } from \"../providers/authorize/adminAuthorize\";\n\n/**\n * Decorator for authenticating and authorizing admin JWT in controller handlers.\n *\n * Injects the authenticated AdminPayload into the decorated parameter. Adds Bearer token\n * security scheme to Swagger docs. Uses a singleton instance for efficiency.\n */\nexport const AdminAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_0: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return adminAuthorize(request);\n  })(),\n);","location":"src/decorators/AdminAuth.ts"},"payload":{"name":"AdminPayload","location":"src/decorators/payload/AdminPayload.ts","content":"import { tags } from \"typia\";\n\n/**\n * JWT payload for admin role authentication.\n *\n * - Id: Top-level admin table ID (todo_list_admins.id)\n * - Type: Discriminator for admin role\n */\nexport interface AdminPayload {\n  /** Top-level admin table ID (todo_list_admins.id) */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the admin role */\n  type: \"admin\";\n}\n"},"role":{"name":"admin","description":"Has all user privileges, plus can view and delete any user's todos if necessary for administration. Can manage the service's operational settings.","kind":"admin"}}],"functions":[{"location":"src/providers/postauthUserJoin.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Register a new user account in todo_list_users and provision JWT tokens\n * (role: user)\n *\n * Accepts registration fields (email, password, name, avatar_uri). Validates\n * email uniqueness (not soft-deleted), hashes password, sets default status,\n * and timestamps. Issues access/refresh JWT for new user and returns full\n * ITodoListUser.IAuthorized DTO with session info and profile (excluding\n * sensitive credentials).\n *\n * @param props - Registration properties\n * @param props.body - User registration data (email, password, optional\n *   name/avatar_uri)\n * @returns ITodoListUser.IAuthorized containing token, user context\n * @throws {HttpException} If email is already in use (status 409)\n */\nexport async function postauthUserJoin(props: {\n  body: ITodoListUser.IJoin;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { body } = props;\n  // 1. Check email uniqueness (exclude soft-deleted)\n  const existing = await MyGlobal.prisma.todo_list_users.findFirst({\n    where: {\n      email: body.email,\n      deleted_at: null,\n    },\n    select: { id: true },\n  });\n  if (existing) {\n    throw new HttpException(\"Email is already registered.\", 409);\n  }\n  // 2. Hash password\n  const password_hash = await MyGlobal.password.hash(body.password);\n  // 3. Prepare fields\n  const now = toISOStringSafe(new Date());\n  const id = v4() as string & tags.Format<\"uuid\">;\n  // 4. Insert user\n  const created = await MyGlobal.prisma.todo_list_users.create({\n    data: {\n      id,\n      email: body.email,\n      password_hash,\n      name: body.name ?? undefined,\n      avatar_uri: body.avatar_uri ?? undefined,\n      status: \"active\",\n      created_at: now,\n      updated_at: now,\n      // last_login_at, deleted_at left undefined (default null)\n    },\n  });\n  // 5. Generate JWT access/refresh tokens\n  const accessExpires = new Date(Date.now() + 60 * 60 * 1000);\n  const refreshExpires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n  const access = jwt.sign(\n    { id: created.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"1h\",\n      issuer: \"autobe\",\n    },\n  );\n  const refresh = jwt.sign(\n    { id: created.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n  // 6. Compose results (convert date fields, exclude password_hash)\n  return {\n    id: created.id,\n    token: {\n      access,\n      refresh,\n      expired_at: toISOStringSafe(accessExpires),\n      refreshable_until: toISOStringSafe(refreshExpires),\n    },\n    user: {\n      id: created.id,\n      email: created.email,\n      name: created.name ?? undefined,\n      avatar_uri: created.avatar_uri ?? undefined,\n      status: created.status,\n      last_login_at: created.last_login_at\n        ? toISOStringSafe(created.last_login_at)\n        : undefined,\n      created_at: toISOStringSafe(created.created_at),\n      updated_at: toISOStringSafe(created.updated_at),\n      deleted_at: created.deleted_at\n        ? toISOStringSafe(created.deleted_at)\n        : undefined,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/join"},"name":"postauthUserJoin"},{"location":"src/providers/postauthUserLogin.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Authenticate a user from todo_list_users, issue new JWT session tokens (role:\n * user)\n *\n * This endpoint authenticates an existing user account (email + password)\n * against the todo_list_users table. It allows login only for users with status\n * 'active' and deleted_at null. On success, updates last_login_at and returns a\n * fully normalized ITodoListUser.IAuthorized (user object and tokens). JWT\n * tokens contain id and role:type 'user', issuer is always 'autobe'. All\n * date/datetime values are string & tags.Format<'date-time'>.\n *\n * @param props - Login properties\n * @param props.body - Login payload: email and password\n * @returns ITodoListUser.IAuthorized containing user id, profile (minus\n *   credential fields), and JWT tokens\n * @throws {HttpException} For any login failure (generic message)\n */\nexport async function postauthUserLogin(props: {\n  body: ITodoListUser.ILogin;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { email, password } = props.body;\n\n  // 1. Fetch user by email (including deleted), error on missing\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { email },\n  });\n\n  // Uniform error message\n  const error = new HttpException(\"Invalid email or password\", 401);\n\n  // 2. Check for user existence and valid status\n  if (!user || user.status !== \"active\" || user.deleted_at !== null) {\n    throw error;\n  }\n\n  // 3. Password check (MyGlobal.password.verify handles hashes)\n  const valid = await MyGlobal.password.verify(password, user.password_hash);\n  if (!valid) throw error;\n\n  // 4. Generate new last_login_at as ISO string\n  const now = toISOStringSafe(new Date());\n\n  // 5. Update last_login_at in DB\n  await MyGlobal.prisma.todo_list_users.update({\n    where: { id: user.id },\n    data: { last_login_at: now },\n  });\n\n  // 6. Generate JWT access and refresh tokens\n  // Token expiresIn: 1h, refresh: 7d, issuer: 'autobe'.\n  const accessTokenExp = new Date(Date.now() + 60 * 60 * 1000);\n  const refreshTokenExp = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n\n  const accessToken = jwt.sign(\n    { id: user.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"1h\", issuer: \"autobe\" },\n  );\n  const refreshToken = jwt.sign(\n    { id: user.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"7d\", issuer: \"autobe\" },\n  );\n\n  // 7. Return ITodoListUser.IAuthorized\n  return {\n    id: user.id,\n    token: {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: toISOStringSafe(accessTokenExp),\n      refreshable_until: toISOStringSafe(refreshTokenExp),\n    },\n    user: {\n      id: user.id,\n      email: user.email,\n      name: user.name ?? undefined,\n      avatar_uri: user.avatar_uri ?? undefined,\n      status: user.status,\n      last_login_at: now,\n      created_at: toISOStringSafe(user.created_at),\n      updated_at: toISOStringSafe(user.updated_at),\n      deleted_at: user.deleted_at\n        ? toISOStringSafe(user.deleted_at)\n        : undefined,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/login"},"name":"postauthUserLogin"},{"location":"src/providers/postauthUserRefresh.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Renew JWT session tokens for a user by validating a refresh token against\n * todo_list_users.\n *\n * Accepts a valid refresh token (issued at login or join). If valid and the\n * referenced user account is active (status is 'active', deleted_at is null),\n * returns fresh JWT access and refresh tokens along with the full user profile.\n * Denies token refresh on any error/invalid/expired token or\n * ineligible/inactive/deleted user account.\n *\n * @param props - Contains the refresh_token to use for session renewal\n * @returns The authorized session object containing user ID, renewed tokens,\n *   and user profile\n * @throws {HttpException} 401 if token is invalid, expired, or user is\n *   ineligible\n */\nexport async function postauthUserRefresh(props: {\n  body: ITodoListUser.IRefresh;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { refresh_token } = props.body;\n  let decoded: { id: string; type: string };\n\n  // Step 1: Verify and decode refresh_token\n  try {\n    decoded = jwt.verify(refresh_token, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    }) as { id: string; type: string };\n  } catch (err: unknown) {\n    throw new HttpException(\"Invalid or expired refresh token\", 401);\n  }\n\n  // Step 2: Validate token type and existence\n  if (!decoded || decoded.type !== \"user\" || !decoded.id) {\n    throw new HttpException(\"Invalid refresh token payload\", 401);\n  }\n\n  // Step 3: Lookup user account (must be active, not deleted)\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { id: decoded.id },\n  });\n  if (!user || user.status !== \"active\" || user.deleted_at !== null) {\n    throw new HttpException(\"User account not eligible for refresh\", 401);\n  }\n\n  // Step 4: Prepare timestamps for token expiry (in ms)\n  const now = Date.now();\n  const accessExpiresInSec = 60 * 30; // 30 minutes\n  const refreshExpiresInSec = 60 * 60 * 24 * 7; // 7 days\n  const accessExpiredAt = new Date(now + accessExpiresInSec * 1000);\n  const refreshExpiredAt = new Date(now + refreshExpiresInSec * 1000);\n\n  // Step 5: Issue new access and refresh JWTs\n  const accessPayload = {\n    id: user.id,\n    type: \"user\",\n  };\n  const access = jwt.sign(accessPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: accessExpiresInSec,\n    issuer: \"autobe\",\n  });\n  const refresh = jwt.sign(accessPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: refreshExpiresInSec,\n    issuer: \"autobe\",\n  });\n\n  // Step 6: Assemble return struct (no Date types, no assertions)\n  const token = {\n    access: access,\n    refresh: refresh,\n    expired_at: toISOStringSafe(accessExpiredAt),\n    refreshable_until: toISOStringSafe(refreshExpiredAt),\n  };\n\n  const userProfile = {\n    id: user.id,\n    email: user.email,\n    name: user.name === undefined ? undefined : user.name,\n    avatar_uri: user.avatar_uri === undefined ? undefined : user.avatar_uri,\n    status: user.status,\n    last_login_at:\n      user.last_login_at !== null && user.last_login_at !== undefined\n        ? toISOStringSafe(user.last_login_at)\n        : null,\n    created_at: toISOStringSafe(user.created_at),\n    updated_at: toISOStringSafe(user.updated_at),\n    deleted_at:\n      user.deleted_at !== null && user.deleted_at !== undefined\n        ? toISOStringSafe(user.deleted_at)\n        : null,\n  };\n\n  return {\n    id: user.id,\n    token: token,\n    user: userProfile,\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/refresh"},"name":"postauthUserRefresh"},{"location":"src/providers/postauthAdminJoin.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Registers a new administrator in the todo_list_admins table.\n *\n * This endpoint allows public registration of new admin accounts. Enforces\n * unique email, hashes password, sets profile fields, and initializes status\n * and privilege level. If the email is already registered, throws a 409 error.\n * On success, issues JWT-based authorization token and returns a profile DTO as\n * per ITodoListAdmin.IAuthorized.\n *\n * @param props - Object containing registration request body matching\n *   ITodoListAdmin.IJoin (email, password_hash, etc)\n * @returns Admin authorization result (profile plus tokens)\n * @throws {HttpException} If email already registered (409 conflict) or on\n *   internal failure\n */\nexport async function postauthAdminJoin(props: {\n  body: ITodoListAdmin.IJoin;\n}): Promise<ITodoListAdmin.IAuthorized> {\n  const now = toISOStringSafe(new Date());\n  const id = v4();\n  const {\n    email,\n    password_hash,\n    name = undefined,\n    avatar_uri = undefined,\n    status = \"active\",\n    privilege_level = \"support\",\n  } = props.body;\n\n  // 1. Check duplicate email (case sensitive, @@unique on email)\n  const exists = await MyGlobal.prisma.todo_list_admins.findUnique({\n    where: { email },\n  });\n  if (exists) {\n    throw new HttpException(\n      \"Email is already registered as administrator\",\n      409,\n    );\n  }\n\n  // 2. Hash password\n  const hashedPassword = await MyGlobal.password.hash(password_hash);\n\n  // 3. Insert new admin record\n  const created = await MyGlobal.prisma.todo_list_admins.create({\n    data: {\n      id,\n      email,\n      password_hash: hashedPassword,\n      name: name !== undefined ? name : undefined,\n      avatar_uri: avatar_uri !== undefined ? avatar_uri : undefined,\n      status,\n      privilege_level,\n      created_at: now,\n      updated_at: now,\n      // all others are nullable/non-required by schema, omitted\n    },\n  });\n\n  // 4. Generate tokens (JWT access and refresh)\n  const accessExpire = new Date(Date.now() + 60 * 60 * 1000); // 1h\n  const refreshExpire = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7d\n\n  const access = jwt.sign(\n    { id: created.id, type: \"admin\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"1h\", issuer: \"autobe\" },\n  );\n  const refresh = jwt.sign(\n    { id: created.id, type: \"admin\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"7d\", issuer: \"autobe\" },\n  );\n\n  return {\n    id: created.id,\n    token: {\n      access,\n      refresh,\n      expired_at: toISOStringSafe(accessExpire),\n      refreshable_until: toISOStringSafe(refreshExpire),\n    },\n    admin: {\n      id: created.id,\n      email: created.email,\n      name:\n        created.name !== null && created.name !== undefined\n          ? created.name\n          : undefined,\n      avatar_uri:\n        created.avatar_uri !== null && created.avatar_uri !== undefined\n          ? created.avatar_uri\n          : undefined,\n      status: created.status,\n      privilege_level: created.privilege_level,\n      last_admin_action_at:\n        created.last_admin_action_at !== null &&\n        created.last_admin_action_at !== undefined\n          ? toISOStringSafe(created.last_admin_action_at)\n          : undefined,\n      last_login_at:\n        created.last_login_at !== null && created.last_login_at !== undefined\n          ? toISOStringSafe(created.last_login_at)\n          : undefined,\n      created_at: toISOStringSafe(created.created_at),\n      updated_at: toISOStringSafe(created.updated_at),\n      deleted_at:\n        created.deleted_at !== null && created.deleted_at !== undefined\n          ? toISOStringSafe(created.deleted_at)\n          : undefined,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/admin/join"},"name":"postauthAdminJoin"},{"location":"src/providers/postauthAdminLogin.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Authenticates administrator credentials (email, password) and issues JWT\n * access/refresh tokens.\n *\n * Validates that the provided email matches an existing admin (not\n * soft-deleted, status==='active'), verifies password securely via\n * MyGlobal.password, and issues JWT tokens if successful. Updates last_login_at\n * timestamp. Returns full admin profile and tokens.\n *\n * @param props - Request body containing admin email and password\n * @param props.body.email - Admin authentication email address\n * @param props.body.password - Raw password to verify against password_hash\n * @returns ITodoListAdmin.IAuthorized containing tokens and admin profile\n * @throws {HttpException} 400 on invalid credentials or inactive/locked/deleted\n *   accounts; generic error message only\n */\nexport async function postauthAdminLogin(props: {\n  body: ITodoListAdmin.ILogin;\n}): Promise<ITodoListAdmin.IAuthorized> {\n  const { email, password } = props.body;\n\n  // Find active, non-deleted admin by unique email\n  const admin = await MyGlobal.prisma.todo_list_admins.findUnique({\n    where: { email },\n  });\n\n  // Generic error (no info leakage) for not found, soft-deleted, or non-active\n  if (!admin || admin.deleted_at !== null || admin.status !== \"active\") {\n    throw new HttpException(\"Invalid email or password\", 400);\n  }\n\n  // Secure password validation\n  const passOk = await MyGlobal.password.verify(password, admin.password_hash);\n  if (!passOk) {\n    throw new HttpException(\"Invalid email or password\", 400);\n  }\n\n  // Compute new login timestamp before updating\n  const now: string & tags.Format<\"date-time\"> = toISOStringSafe(new Date());\n  await MyGlobal.prisma.todo_list_admins.update({\n    where: { id: admin.id },\n    data: { last_login_at: now, updated_at: now },\n  });\n\n  // Prepare JWT payload & token values (no type assertions)\n  const accessPayload = { id: admin.id, type: \"admin\" };\n  const refreshPayload = { id: admin.id, type: \"admin\" };\n\n  // Expiry times (fully typed, string only)\n  const accessExpiresMs = 60 * 60 * 1000; // 1 hour\n  const refreshExpiresMs = 7 * 24 * 60 * 60 * 1000; // 7 days\n  const expired_at = toISOStringSafe(new Date(Date.now() + accessExpiresMs));\n  const refreshable_until = toISOStringSafe(\n    new Date(Date.now() + refreshExpiresMs),\n  );\n\n  // JWT signing\n  const access = jwt.sign(accessPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"1h\",\n    issuer: \"autobe\",\n  });\n  const refresh = jwt.sign(refreshPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"7d\",\n    issuer: \"autobe\",\n  });\n\n  return {\n    id: admin.id,\n    token: {\n      access,\n      refresh,\n      expired_at,\n      refreshable_until,\n    },\n    admin: {\n      id: admin.id,\n      email: admin.email,\n      name: typeof admin.name === \"string\" ? admin.name : undefined,\n      avatar_uri:\n        typeof admin.avatar_uri === \"string\" ? admin.avatar_uri : undefined,\n      status: admin.status,\n      privilege_level: admin.privilege_level,\n      last_admin_action_at: admin.last_admin_action_at\n        ? toISOStringSafe(admin.last_admin_action_at)\n        : undefined,\n      last_login_at: now,\n      created_at: toISOStringSafe(admin.created_at),\n      updated_at: now,\n      deleted_at: admin.deleted_at\n        ? toISOStringSafe(admin.deleted_at)\n        : undefined,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/admin/login"},"name":"postauthAdminLogin"},{"location":"src/providers/postauthAdminRefresh.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Refreshes administrator JWT tokens using a valid refresh token.\n *\n * This endpoint allows an authenticated admin to obtain new access and refresh\n * tokens by presenting a valid, non-expired, and non-revoked refresh token. The\n * refresh logic verifies the admin exists, is not deleted/suspended, and is\n * using an up-to-date privilege/status. All expiration times are provided as\n * ISO date-time strings with proper branding.\n *\n * @param props - Request containing { body: { refresh_token } }\n * @returns New JWT access/refresh tokens and full admin profile as\n *   ITodoListAdmin.IAuthorized DTO\n * @throws {HttpException} When refresh_token is invalid, expired, admin is not\n *   found, or admin is inactive/deleted\n */\nexport async function postauthAdminRefresh(props: {\n  body: ITodoListAdmin.IRefresh;\n}): Promise<ITodoListAdmin.IAuthorized> {\n  const { refresh_token } = props.body;\n  let decoded: { id: string; type: string };\n  try {\n    decoded = jwt.verify(refresh_token, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    }) as { id: string; type: string };\n  } catch {\n    throw new HttpException(\"Invalid or expired refresh token\", 401);\n  }\n\n  // Validate JWT payload format\n  if (!decoded || !decoded.id || decoded.type !== \"admin\") {\n    throw new HttpException(\"Malformed refresh token payload\", 401);\n  }\n\n  // Fetch admin by id\n  const admin = await MyGlobal.prisma.todo_list_admins.findUnique({\n    where: { id: decoded.id },\n  });\n  if (!admin || admin.deleted_at !== null || admin.status !== \"active\") {\n    throw new HttpException(\"Admin not found, deleted, or not active\", 403);\n  }\n\n  // Token expiry\n  const accessTokenTtlSeconds = 60 * 60; // 1h\n  const refreshTokenTtlSeconds = 60 * 60 * 24 * 7; // 7d\n  const now = new Date();\n  const expiredAt = toISOStringSafe(\n    new Date(now.getTime() + accessTokenTtlSeconds * 1000),\n  );\n  const refreshableUntil = toISOStringSafe(\n    new Date(now.getTime() + refreshTokenTtlSeconds * 1000),\n  );\n\n  // Access token: payload structure must match AdminPayload\n  const accessToken = jwt.sign(\n    { id: admin.id, type: \"admin\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: accessTokenTtlSeconds,\n      issuer: \"autobe\",\n    },\n  );\n\n  // Rotate refresh token\n  const refreshToken = jwt.sign(\n    { id: admin.id, type: \"admin\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: refreshTokenTtlSeconds,\n      issuer: \"autobe\",\n    },\n  );\n\n  // Compose IAuthorizationToken (all ISO strings)\n  const token = {\n    access: accessToken,\n    refresh: refreshToken,\n    expired_at: expiredAt,\n    refreshable_until: refreshableUntil,\n  };\n\n  // Compose ITodoListAdmin DTO\n  const adminProfile = {\n    id: admin.id,\n    email: admin.email,\n    name: admin.name ?? undefined,\n    avatar_uri: admin.avatar_uri ?? undefined,\n    status: admin.status,\n    privilege_level: admin.privilege_level,\n    last_admin_action_at: admin.last_admin_action_at\n      ? toISOStringSafe(admin.last_admin_action_at)\n      : undefined,\n    last_login_at: admin.last_login_at\n      ? toISOStringSafe(admin.last_login_at)\n      : undefined,\n    created_at: toISOStringSafe(admin.created_at),\n    updated_at: toISOStringSafe(admin.updated_at),\n    deleted_at: admin.deleted_at\n      ? toISOStringSafe(admin.deleted_at)\n      : undefined,\n  };\n\n  return {\n    id: admin.id,\n    token,\n    admin: adminProfile,\n  };\n}\n","endpoint":{"method":"post","path":"/auth/admin/refresh"},"name":"postauthAdminRefresh"},{"location":"src/providers/patchtodoListAdminUsers.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { IPageITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListUser\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Advanced search and pagination of all user accounts for administrators.\n *\n * Allows privileged admins to filter, search, sort, and page through user\n * accounts in the todo_list_users table. Supports extensive filtering (email,\n * name, status, registration dates, last login), free-text search, and\n * default/explicit pagination and sort order. Only non-deleted users\n * (deleted_at == null) are returned. Sensitive credential info is never\n * exposed.\n *\n * @param props - Properties for the search\n * @param props.admin - The authenticated administrator performing the request\n * @param props.body - Filter/search/sort/page parameters\n *   (ITodoListUser.IRequest)\n * @returns Paginated list of user summaries (id, email, name, avatar, status,\n *   last login, created_at)\n * @throws {HttpException} On error or if parameters are invalid\n */\nexport async function patchtodoListAdminUsers(props: {\n  admin: AdminPayload;\n  body: ITodoListUser.IRequest;\n}): Promise<IPageITodoListUser.ISummary> {\n  const { body } = props;\n\n  // Allowed sort fields per schema\n  const allowedSortFields = [\n    \"email\",\n    \"created_at\",\n    \"last_login_at\",\n    \"name\",\n    \"status\",\n  ];\n  const sortField =\n    body.sort_by && allowedSortFields.includes(body.sort_by)\n      ? body.sort_by\n      : \"created_at\";\n  const sortDirection = body.direction === \"asc\" ? \"asc\" : \"desc\";\n  const page = body.page ?? 1;\n  const limit = body.limit ?? 20;\n\n  // Prisma where filtering\n  const where: Record<string, any> = {\n    deleted_at: null,\n    ...(body.email !== undefined &&\n      body.email !== null && { email: body.email }),\n    ...(body.status !== undefined &&\n      body.status !== null && { status: body.status }),\n    ...(body.name !== undefined &&\n      body.name !== null && { name: { contains: body.name } }),\n    // Date ranges\n    ...((body.created_from !== undefined && body.created_from !== null) ||\n    (body.created_to !== undefined && body.created_to !== null)\n      ? {\n          created_at: {\n            ...(body.created_from !== undefined &&\n              body.created_from !== null && { gte: body.created_from }),\n            ...(body.created_to !== undefined &&\n              body.created_to !== null && { lte: body.created_to }),\n          },\n        }\n      : {}),\n    ...((body.last_login_from !== undefined && body.last_login_from !== null) ||\n    (body.last_login_to !== undefined && body.last_login_to !== null)\n      ? {\n          last_login_at: {\n            ...(body.last_login_from !== undefined &&\n              body.last_login_from !== null && {\n                gte: body.last_login_from,\n              }),\n            ...(body.last_login_to !== undefined &&\n              body.last_login_to !== null && {\n                lte: body.last_login_to,\n              }),\n          },\n        }\n      : {}),\n    // Free-text search across name/email only if provided\n    ...(body.search !== undefined &&\n    body.search !== null &&\n    body.search.trim().length > 0\n      ? {\n          OR: [\n            { name: { contains: body.search } },\n            { email: { contains: body.search } },\n          ],\n        }\n      : {}),\n  };\n\n  // Build query\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_users.findMany({\n      where,\n      orderBy: { [sortField]: sortDirection },\n      skip: (page - 1) * limit,\n      take: limit,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        avatar_uri: true,\n        status: true,\n        last_login_at: true,\n        created_at: true,\n      },\n    }),\n    MyGlobal.prisma.todo_list_users.count({ where }),\n  ]);\n\n  // Map results to ISummary with proper type and date conversions\n  const data = rows.map((u) => {\n    return {\n      id: u.id,\n      email: u.email,\n      name: u.name ?? undefined,\n      avatar_uri: u.avatar_uri ?? undefined,\n      status: u.status,\n      last_login_at:\n        u.last_login_at !== null && u.last_login_at !== undefined\n          ? toISOStringSafe(u.last_login_at)\n          : undefined,\n      created_at: toISOStringSafe(u.created_at),\n    };\n  });\n\n  // Calculate pagination\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: total,\n      pages: Math.ceil(total / limit),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/admin/users"},"name":"patchtodoListAdminUsers"},{"location":"src/providers/gettodoListAdminUsersUserId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Retrieve a specific user's detailed profile (todo_list_users table) using\n * their unique userId.\n *\n * Allows an admin to access all non-sensitive details of any user for support,\n * compliance, or operational purposes. Excludes password hashes. Only\n * accessible by admin role; throws 404 if the user does not exist or is soft\n * deleted. All access must be strictly authorized and subject to audit\n * logging.\n *\n * @param props - The parameters for the request.\n * @param props.admin - The authenticated admin making the request.\n * @param props.userId - The UUID of the user to be retrieved.\n * @returns Full non-sensitive profile information for the requested user.\n * @throws {HttpException} If the user is not found or is soft deleted.\n */\nexport async function gettodoListAdminUsersUserId(props: {\n  admin: AdminPayload;\n  userId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListUser> {\n  const record = await MyGlobal.prisma.todo_list_users.findFirst({\n    where: {\n      id: props.userId,\n      deleted_at: null,\n    },\n  });\n\n  if (!record) {\n    throw new HttpException(\"User not found\", 404);\n  }\n\n  return {\n    id: record.id,\n    email: record.email,\n    name: record.name ?? undefined,\n    avatar_uri: record.avatar_uri ?? undefined,\n    status: record.status,\n    last_login_at: record.last_login_at\n      ? toISOStringSafe(record.last_login_at)\n      : undefined,\n    created_at: toISOStringSafe(record.created_at),\n    updated_at: toISOStringSafe(record.updated_at),\n    deleted_at: record.deleted_at\n      ? toISOStringSafe(record.deleted_at)\n      : undefined,\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/admin/users/{userId}"},"name":"gettodoListAdminUsersUserId"},{"location":"src/providers/puttodoListAdminUsersUserId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Update fields of a specific user account (todo_list_users) by admin,\n * including profile and status changes.\n *\n * Allows admin users to update an existing user account identified by userId.\n * Updatable fields include name, avatar_uri, status, email, and password_hash.\n * This function ensures that the email remains unique across users, that status\n * and credential updates comply with business rules, and that no updates are\n * permitted if the user is soft-deleted. Returns the full user record\n * (excluding credential hash) upon success. All changes are logged as\n * appropriate for audit/compliance.\n *\n * @param props - Object containing admin authentication, target userId, and\n *   update body\n * @param props.admin - The authenticated admin performing the update\n * @param props.userId - Target user UUID (id) to update\n * @param props.body - The set of fields to update (any/all of name, avatar_uri,\n *   status, email, password_hash)\n * @returns The updated user record (excluding credential hash) after\n *   modification\n * @throws {HttpException} If the user is not found, soft-deleted, or the email\n *   is duplicate/violates unique constraint\n */\nexport async function puttodoListAdminUsersUserId(props: {\n  admin: AdminPayload;\n  userId: string & tags.Format<\"uuid\">;\n  body: ITodoListUser.IUpdate;\n}): Promise<ITodoListUser> {\n  // Step 1: Fetch user and check if exists and not soft-deleted\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { id: props.userId },\n  });\n  if (!user || user.deleted_at !== null) {\n    throw new HttpException(\"User not found or already deleted\", 404);\n  }\n  // Step 2: If updating email, enforce uniqueness constraint\n  if (props.body.email && props.body.email !== user.email) {\n    const dup = await MyGlobal.prisma.todo_list_users.findUnique({\n      where: { email: props.body.email },\n    });\n    if (dup && dup.id !== props.userId) {\n      throw new HttpException(\"Email already exists\", 409);\n    }\n  }\n  // Step 3: Update user fields (no id, created_at updated)\n  const now = toISOStringSafe(new Date());\n  const updated = await MyGlobal.prisma.todo_list_users.update({\n    where: { id: props.userId },\n    data: {\n      email: props.body.email ?? undefined,\n      name: props.body.name ?? undefined,\n      avatar_uri: props.body.avatar_uri ?? undefined,\n      status: props.body.status ?? undefined,\n      password_hash: props.body.password_hash ?? undefined,\n      updated_at: now,\n    },\n  });\n  // Step 4: Return updated user excluding password_hash\n  return {\n    id: updated.id,\n    email: updated.email,\n    name: updated.name ?? undefined,\n    avatar_uri: updated.avatar_uri ?? undefined,\n    status: updated.status,\n    last_login_at: updated.last_login_at\n      ? toISOStringSafe(updated.last_login_at)\n      : undefined,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: now,\n    deleted_at: updated.deleted_at\n      ? toISOStringSafe(updated.deleted_at)\n      : undefined,\n  };\n}\n","endpoint":{"method":"put","path":"/todoList/admin/users/{userId}"},"name":"puttodoListAdminUsersUserId"},{"location":"src/providers/deletetodoListAdminUsersUserId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Soft-delete a user account (todo_list_users) by setting deleted_at; admin\n * only.\n *\n * This function allows an administrator to perform a soft deletion of a user\n * account in the todo_list_users table. It sets the deleted_at timestamp\n * (soft-delete), ensuring the account is excluded from main listings while\n * remaining present for compliance purposes. The action is authorized for admin\n * users only and is logged in the audit logs. If the userId is not found or\n * already deleted, a 404 Not Found error is returned. Operation is irreversible\n * (no restore possible from this function).\n *\n * @param props - Parameters for the soft-delete operation\n * @param props.admin - Authenticated admin performing the action\n * @param props.userId - ID of the user account to soft-delete\n * @returns Void\n * @throws {HttpException} 404 if the user does not exist or already deleted\n */\nexport async function deletetodoListAdminUsersUserId(props: {\n  admin: AdminPayload;\n  userId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const { admin, userId } = props;\n\n  // 1. Verify the user exists and is not already deleted\n  const user = await MyGlobal.prisma.todo_list_users.findFirst({\n    where: {\n      id: userId,\n      deleted_at: null,\n    },\n  });\n  if (!user) {\n    throw new HttpException(\"User not found or already deleted\", 404);\n  }\n\n  // 2. Soft-delete the user by setting deleted_at\n  const now = toISOStringSafe(new Date());\n  await MyGlobal.prisma.todo_list_users.update({\n    where: { id: userId },\n    data: { deleted_at: now },\n  });\n\n  // 3. Write audit log\n  await MyGlobal.prisma.todo_list_audit_logs.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      todo_list_admin_id: admin.id,\n      todo_list_user_id: userId,\n      todo_list_todo_id: user.id, // This field is required by schema, but not available here. Handle as follows:\n      action: \"delete\",\n      rationale: \"Soft-deleted user account\",\n      created_at: now,\n    },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoList/admin/users/{userId}"},"name":"deletetodoListAdminUsersUserId"},{"location":"src/providers/patchtodoListAdminAdmins.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { IPageITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAdmin\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * List/search all Todo List administrator accounts with filtering and\n * pagination.\n *\n * Only accessible to authenticated admins. Supports filter by email, name,\n * privilege level, status, date ranges, and search query (partial name/email\n * match). Paginates and sorts results. Excludes password hashes and\n * soft-deleted administrators.\n *\n * @param props - Object with authentication (admin) and filter/search\n *   pagination parameters\n * @param props.admin - Authenticated AdminPayload (authorization required)\n * @param props.body - Filter/sort/search/page settings (see\n *   ITodoListAdmin.IRequest)\n * @returns Paginated list of administrator account summaries (see\n *   IPageITodoListAdmin.ISummary)\n * @throws {HttpException} If not authorized or on database error\n */\nexport async function patchtodoListAdminAdmins(props: {\n  admin: AdminPayload;\n  body: ITodoListAdmin.IRequest;\n}): Promise<IPageITodoListAdmin.ISummary> {\n  const { body } = props;\n\n  // Normalize & cap pagination\n  const page = Math.max(1, body.page ?? 1);\n  const limit = Math.min(100, Math.max(1, body.limit ?? 20));\n  const skip = (page - 1) * limit;\n\n  // Build where clause (soft delete always, plus filters)\n  const where = {\n    deleted_at: null,\n    ...(body.email ? { email: { contains: body.email } } : {}),\n    ...(body.name ? { name: { contains: body.name } } : {}),\n    ...(body.privilege_level ? { privilege_level: body.privilege_level } : {}),\n    ...(body.status ? { status: body.status } : {}),\n    // Date bounds\n    ...(body.created_from || body.created_to\n      ? {\n          created_at: {\n            ...(body.created_from ? { gte: body.created_from } : {}),\n            ...(body.created_to ? { lte: body.created_to } : {}),\n          },\n        }\n      : {}),\n    ...(body.last_login_from || body.last_login_to\n      ? {\n          last_login_at: {\n            ...(body.last_login_from ? { gte: body.last_login_from } : {}),\n            ...(body.last_login_to ? { lte: body.last_login_to } : {}),\n          },\n        }\n      : {}),\n    // Free-text search (name or email)\n    ...(body.search\n      ? {\n          OR: [\n            { name: { contains: body.search } },\n            { email: { contains: body.search } },\n          ],\n        }\n      : {}),\n  };\n\n  // Sorting\n  const sortFields = [\n    \"email\",\n    \"created_at\",\n    \"last_login_at\",\n    \"name\",\n    \"status\",\n    \"privilege_level\",\n  ];\n  const sortBy =\n    body.sort_by && sortFields.includes(body.sort_by)\n      ? body.sort_by\n      : \"created_at\";\n  const direction: \"asc\" | \"desc\" = body.direction === \"asc\" ? \"asc\" : \"desc\";\n\n  // Retrieve paginated admins and total\n  const [admins, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_admins.findMany({\n      where,\n      orderBy: { [sortBy]: direction },\n      skip,\n      take: limit,\n    }),\n    MyGlobal.prisma.todo_list_admins.count({ where }),\n  ]);\n\n  const data = admins.map((a) => {\n    return {\n      id: a.id,\n      email: a.email,\n      name: a.name ?? null,\n      avatar_uri: a.avatar_uri ?? null,\n      status: a.status,\n      privilege_level: a.privilege_level,\n      last_admin_action_at: a.last_admin_action_at\n        ? toISOStringSafe(a.last_admin_action_at)\n        : null,\n      last_login_at: a.last_login_at ? toISOStringSafe(a.last_login_at) : null,\n      created_at: toISOStringSafe(a.created_at),\n    };\n  });\n\n  return {\n    pagination: {\n      current: page,\n      limit: limit,\n      records: total,\n      pages: Math.ceil(total / limit),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/admin/admins"},"name":"patchtodoListAdminAdmins"},{"location":"src/providers/gettodoListAdminAdminsAdminId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Retrieve detailed information for a specific Todo List administrator (table:\n * todo_list_admins)\n *\n * Returns full detail of an administrator account specified by adminId.\n * Requires caller to be authenticated as admin. Excludes sensitive\n * authentication data (password_hash). Supports admin management, auditing, and\n * profile review. Access denied for non-admins or missing/inactive/soft-deleted\n * accounts.\n *\n * @param props - Object containing the authenticated admin and target adminId\n * @param props.admin - Authenticated admin JWT payload\n * @param props.adminId - The unique identifier (UUID) of the target\n *   administrator account\n * @returns Detailed administrator account profile (excluding secrets)\n * @throws {HttpException} 404 if admin not found or is inactive/soft-deleted\n */\nexport async function gettodoListAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListAdmin> {\n  const { adminId } = props;\n  const admin = await MyGlobal.prisma.todo_list_admins.findFirst({\n    where: {\n      id: adminId,\n      deleted_at: null,\n      status: \"active\",\n    },\n  });\n  if (!admin) {\n    throw new HttpException(\"Admin not found\", 404);\n  }\n  return {\n    id: admin.id,\n    email: admin.email,\n    name: admin.name ?? undefined,\n    avatar_uri: admin.avatar_uri ?? undefined,\n    status: admin.status,\n    privilege_level: admin.privilege_level,\n    last_admin_action_at: admin.last_admin_action_at\n      ? toISOStringSafe(admin.last_admin_action_at)\n      : undefined,\n    last_login_at: admin.last_login_at\n      ? toISOStringSafe(admin.last_login_at)\n      : undefined,\n    created_at: toISOStringSafe(admin.created_at),\n    updated_at: toISOStringSafe(admin.updated_at),\n    deleted_at: admin.deleted_at\n      ? toISOStringSafe(admin.deleted_at)\n      : undefined,\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/admin/admins/{adminId}"},"name":"gettodoListAdminAdminsAdminId"},{"location":"src/providers/puttodoListAdminAdminsAdminId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Update profile or status of an administrator account.\n *\n * Allows an authenticated admin to update fields (name, avatar URI, status,\n * privilege_level) of another admin by specifying adminId. Does NOT allow\n * changing password or email. Applies only if the target admin exists and is\n * not soft-deleted. Always updates updated_at. All output fields use correct\n * types and branding; never exposes password_hash.\n *\n * @param props - Parameters including the authenticated admin, adminId of\n *   target, and patch body.\n * @param props.admin - Authenticated admin making the request\n * @param props.adminId - UUID of the admin account to update\n * @param props.body - Patch fields for name, avatar_uri, status,\n *   privilege_level\n * @returns The updated admin account object\n * @throws {HttpException} When the target admin does not exist, is deleted, or\n *   on update conflict\n */\nexport async function puttodoListAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n  body: ITodoListAdmin.IUpdate;\n}): Promise<ITodoListAdmin> {\n  // Find target admin, ensure active (not soft-deleted)\n  const adminRecord = await MyGlobal.prisma.todo_list_admins.findFirst({\n    where: {\n      id: props.adminId,\n      deleted_at: null,\n    },\n  });\n  if (!adminRecord) {\n    throw new HttpException(\"Admin not found or has been deleted\", 404);\n  }\n\n  // Prepare update fields (never touch email/password_hash)\n  const now: string & tags.Format<\"date-time\"> = toISOStringSafe(new Date());\n\n  let updated;\n  try {\n    updated = await MyGlobal.prisma.todo_list_admins.update({\n      where: { id: props.adminId },\n      data: {\n        name: \"name\" in props.body ? (props.body.name ?? null) : undefined,\n        avatar_uri:\n          \"avatar_uri\" in props.body\n            ? (props.body.avatar_uri ?? null)\n            : undefined,\n        status: \"status\" in props.body ? props.body.status : undefined,\n        privilege_level:\n          \"privilege_level\" in props.body\n            ? props.body.privilege_level\n            : undefined,\n        updated_at: now,\n      },\n    });\n  } catch (err) {\n    // Handle e.g. unique constraint violation or invalid updates\n    throw new HttpException(\"Failed to update admin account\", 400);\n  }\n\n  return {\n    id: updated.id,\n    email: updated.email,\n    name: Object.prototype.hasOwnProperty.call(updated, \"name\")\n      ? (updated.name ?? null)\n      : undefined,\n    avatar_uri: Object.prototype.hasOwnProperty.call(updated, \"avatar_uri\")\n      ? (updated.avatar_uri ?? null)\n      : undefined,\n    status: updated.status,\n    privilege_level: updated.privilege_level,\n    last_admin_action_at: Object.prototype.hasOwnProperty.call(\n      updated,\n      \"last_admin_action_at\",\n    )\n      ? updated.last_admin_action_at\n        ? toISOStringSafe(updated.last_admin_action_at)\n        : null\n      : undefined,\n    last_login_at: Object.prototype.hasOwnProperty.call(\n      updated,\n      \"last_login_at\",\n    )\n      ? updated.last_login_at\n        ? toISOStringSafe(updated.last_login_at)\n        : null\n      : undefined,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n    deleted_at: Object.prototype.hasOwnProperty.call(updated, \"deleted_at\")\n      ? updated.deleted_at\n        ? toISOStringSafe(updated.deleted_at)\n        : null\n      : undefined,\n  };\n}\n","endpoint":{"method":"put","path":"/todoList/admin/admins/{adminId}"},"name":"puttodoListAdminAdminsAdminId"},{"location":"src/providers/deletetodoListAdminAdminsAdminId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Permanently delete an administrator account from todo_list_admins (hard\n * delete).\n *\n * This operation performs a hard delete of the administrator account identified\n * by the adminId parameter. It is restricted to authenticated admins.\n *\n * The function checks if the target admin exists and is not soft-deleted\n * (deleted_at must be null). Errors are thrown if the admin does not exist or\n * has already been soft-deleted. On success, the admin record (row) is hard\n * deleted.\n *\n * @param props - Parameters for the admin deletion\n * @param props.admin - Authenticated admin performing the action\n * @param props.adminId - UUID of the administrator to delete\n * @returns Void\n * @throws {HttpException} 404 if admin not found, 400 if already soft-deleted,\n *   403 if actor is not admin\n */\nexport async function deletetodoListAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const { admin, adminId } = props;\n\n  // Ensure actor is authorized (must be admin type)\n  if (admin.type !== \"admin\") {\n    throw new HttpException(\"Forbidden: You are not an admin.\", 403);\n  }\n\n  // Check if target admin exists and is NOT soft deleted\n  const target = await MyGlobal.prisma.todo_list_admins.findFirst({\n    where: {\n      id: adminId,\n      deleted_at: null,\n    },\n  });\n\n  if (target === null) {\n    // Could be not found, or already deleted\n    // Additional select for soft-deleted state check\n    const softDeleted = await MyGlobal.prisma.todo_list_admins.findFirst({\n      where: { id: adminId },\n      select: { deleted_at: true },\n    });\n    if (softDeleted && softDeleted.deleted_at !== null) {\n      throw new HttpException(\"Admin account already soft deleted.\", 400);\n    }\n    throw new HttpException(\"Admin account not found.\", 404);\n  }\n\n  // Hard delete (permanently remove admin row)\n  await MyGlobal.prisma.todo_list_admins.delete({\n    where: { id: adminId },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoList/admin/admins/{adminId}"},"name":"deletetodoListAdminAdminsAdminId"},{"location":"src/providers/patchtodoListUserTodos.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Search and retrieve a filtered, paginated list of todos for a user\n * (todo_list_todos table).\n *\n * This endpoint returns a user's todos filtered by content, completion status,\n * due date and paginated. Only the user's own todos are visible. Excludes\n * soft-deleted users. Throws 400 for negative page/limit.\n *\n * @param props - Contains authenticated user and filter/pagination body.\n * @param props.user - Authenticated user (role: user)\n * @param props.body - Search, filter, and pagination parameters\n * @returns Paginated result set of todo task summaries matching filters\n * @throws {HttpException} 400 for bad pagination, 403 unauthorized, 404 if user\n *   is deleted/inactive\n */\nexport async function patchtodoListUserTodos(props: {\n  user: UserPayload;\n  body: ITodoListTodo.IRequest;\n}): Promise<IPageITodoListTodo.ISummary> {\n  const { user, body } = props;\n\n  // Defensive pagination: default page/limit (must be >=1/0)\n  const limit = body.limit ?? 20;\n  const page = body.page ?? 1;\n  if (limit <= 0 || page < 1) {\n    throw new HttpException(\"Bad Request: Page must be >= 1, limit > 0\", 400);\n  }\n\n  // Confirm user exists, not deleted, status active\n  const userRecord = await MyGlobal.prisma.todo_list_users.findFirst({\n    where: {\n      id: user.id,\n      deleted_at: null,\n      status: \"active\",\n    },\n    select: { id: true },\n  });\n  if (!userRecord) {\n    throw new HttpException(\"User not found or inactive\", 404);\n  }\n\n  // Build where clause for todos\n  const todoWhere: Record<string, unknown> = {\n    todo_list_user_id: user.id,\n  };\n  if (body.search && body.search.trim().length > 0) {\n    todoWhere.content = { contains: body.search.trim() };\n  }\n  if (body.completed !== undefined) {\n    todoWhere.completed = body.completed;\n  }\n  if (body.due_date !== undefined) {\n    todoWhere.due_date = body.due_date;\n  }\n\n  // Query todos and count in parallel\n  const [todos, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_todos.findMany({\n      where: todoWhere,\n      orderBy: { created_at: \"desc\" },\n      skip: (page - 1) * limit,\n      take: limit,\n    }),\n    MyGlobal.prisma.todo_list_todos.count({ where: todoWhere }),\n  ]);\n\n  // Map to ISummary format\n  const data = todos.map((t) => ({\n    id: t.id,\n    content: t.content,\n    due_date: t.due_date ? toISOStringSafe(t.due_date) : null,\n    completed: t.completed,\n    completed_at: t.completed_at ? toISOStringSafe(t.completed_at) : null,\n    created_at: toISOStringSafe(t.created_at),\n  }));\n\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: total,\n      pages: Math.ceil(total / Number(limit)),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/user/todos"},"name":"patchtodoListUserTodos"},{"location":"src/providers/patchtodoListAdminTodos.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Search and retrieve a filtered, paginated list of all users' todos (admin).\n *\n * Supports filtering by content (partial match), completed status, due_date,\n * and paginates results. Only includes todos owned by users (todo_list_users)\n * that are NOT soft-deleted. Results sorted by 'sort' param or defaults to most\n * recent (created_at desc). Enforces functional, immutable data structure. Does\n * NOT use native Date or 'as'.\n *\n * @param props - Contains authenticated admin and optional filter/search params\n *   per ITodoListTodo.IRequest\n * @returns Paginated todo list summaries with full type branding\n * @throws {HttpException} If called without authenticated admin (enforced by\n *   decorator)\n */\nexport async function patchtodoListAdminTodos(props: {\n  admin: AdminPayload;\n  body: ITodoListTodo.IRequest;\n}): Promise<IPageITodoListTodo.ISummary> {\n  const { body } = props;\n  // Defensive: default pagination\n  const page = body.page && body.page > 0 ? body.page : 1;\n  const limit = body.limit && body.limit > 0 ? body.limit : 20;\n  if (page <= 0 || limit <= 0) {\n    return {\n      pagination: {\n        current: 0,\n        limit: 0,\n        records: 0,\n        pages: 0,\n      },\n      data: [],\n    };\n  }\n  // Build search/filters\n  const where: Record<string, unknown> = {\n    user: { deleted_at: null },\n    ...(body.search !== undefined &&\n      body.search.trim().length > 0 && {\n        content: { contains: body.search.trim() },\n      }),\n    ...(body.completed !== undefined && { completed: body.completed }),\n    ...(body.due_date !== undefined && { due_date: body.due_date }),\n  };\n  // Sorting\n  let orderBy: Record<string, \"asc\" | \"desc\">;\n  if (body.sort !== undefined && /^\\w+:(asc|desc)$/i.test(body.sort.trim())) {\n    const [field, direction] = body.sort.trim().split(\":\");\n    // Only allow known/safe sortable fields\n    if (field === \"created_at\" || field === \"due_date\") {\n      orderBy = { [field]: direction.toLowerCase() === \"asc\" ? \"asc\" : \"desc\" };\n    } else {\n      orderBy = { created_at: \"desc\" };\n    }\n  } else {\n    orderBy = { created_at: \"desc\" };\n  }\n  const skip = (page - 1) * limit;\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_todos.findMany({\n      where,\n      orderBy,\n      skip,\n      take: limit,\n    }),\n    MyGlobal.prisma.todo_list_todos.count({ where }),\n  ]);\n  const data = rows.map((row) => {\n    const summary: ITodoListTodo.ISummary = {\n      id: row.id,\n      content: row.content,\n      due_date:\n        row.due_date === null || row.due_date === undefined\n          ? undefined\n          : toISOStringSafe(row.due_date),\n      completed: row.completed,\n      completed_at:\n        row.completed_at === null || row.completed_at === undefined\n          ? undefined\n          : toISOStringSafe(row.completed_at),\n      created_at: toISOStringSafe(row.created_at),\n    };\n    return summary;\n  });\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: Number(total),\n      pages: Number(limit) > 0 ? Math.ceil(Number(total) / Number(limit)) : 0,\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/admin/todos"},"name":"patchtodoListAdminTodos"},{"location":"src/providers/gettodoListUserTodosTodoId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Retrieve details of a single todo by its unique identifier (todo_list_todos\n * table).\n *\n * This operation returns the complete field set for the specified todo item,\n * provided the authenticated user is the owner. If the todo does not exist, a\n * 404 error is thrown. If the user does not own the todo, a 403 forbidden error\n * is thrown.\n *\n * @param props - Request properties\n * @param props.user - The authenticated user requesting the todo\n * @param props.todoId - The UUID of the todo to retrieve\n * @returns The full todo details for the given todoId, if owned by the user\n * @throws {HttpException} When the todo is not found (404), or access is\n *   forbidden (403)\n */\nexport async function gettodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListTodo> {\n  const { user, todoId } = props;\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: todoId },\n  });\n\n  if (todo === null) {\n    throw new HttpException(\"Todo not found\", 404);\n  }\n  if (todo.todo_list_user_id !== user.id) {\n    throw new HttpException(\n      \"Forbidden: You do not have access to this todo\",\n      403,\n    );\n  }\n  return {\n    id: todo.id,\n    todo_list_user_id: todo.todo_list_user_id,\n    content: todo.content,\n    due_date: todo.due_date ? toISOStringSafe(todo.due_date) : null,\n    completed: todo.completed,\n    completed_at: todo.completed_at ? toISOStringSafe(todo.completed_at) : null,\n    created_at: toISOStringSafe(todo.created_at),\n    updated_at: toISOStringSafe(todo.updated_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/user/todos/{todoId}"},"name":"gettodoListUserTodosTodoId"},{"location":"src/providers/gettodoListAdminTodosTodoId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Retrieve details of a single todo by its unique identifier (todo_list_todos\n * table).\n *\n * Allows admin to fetch the complete detail of any user's todo item using the\n * todoId. Results include all business fields: ownership, content, status, due\n * date, created/updated/completed timestamps. If the todo does not exist, a 404\n * Not Found error is thrown. Only the admin role may access this endpoint.\n *\n * @param props - The parameter object\n * @param props.admin - The authenticated admin making this request\n * @param props.todoId - The todo item's UUID\n * @returns The complete todo item details (ITodoListTodo)\n * @throws {Error} 404 if not found\n */\nexport async function gettodoListAdminTodosTodoId(props: {\n  admin: AdminPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListTodo> {\n  const { todoId } = props;\n\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: todoId },\n  });\n\n  if (!todo) {\n    throw new HttpException(\"Todo not found\", 404);\n  }\n\n  return {\n    id: todo.id,\n    todo_list_user_id: todo.todo_list_user_id,\n    content: todo.content,\n    due_date: todo.due_date != null ? toISOStringSafe(todo.due_date) : null,\n    completed: todo.completed,\n    completed_at:\n      todo.completed_at != null ? toISOStringSafe(todo.completed_at) : null,\n    created_at: toISOStringSafe(todo.created_at),\n    updated_at: toISOStringSafe(todo.updated_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/admin/todos/{todoId}"},"name":"gettodoListAdminTodosTodoId"},{"location":"src/providers/posttodoListUserTodos.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Create a new todo item for the current user (todo_list_todos table).\n *\n * This endpoint creates a todo for the authenticated user. Enforces validation:\n * content (required, trimmed, non-empty, no control chars, <=255), optional\n * due_date (if present, not in past, valid ISO date), and deduplication (no\n * existing item with same content for this user). Ownership is enforced;\n * completed=false by default.\n *\n * @param props - Request parameters\n * @param props.user - The authenticated user creating the todo\n * @param props.body - Todo creation data (content, optional due_date)\n * @returns The created todo\n * @throws {Error} If validation or deduplication fails.\n */\nexport async function posttodoListUserTodos(props: {\n  user: UserPayload;\n  body: ITodoListTodo.ICreate;\n}): Promise<ITodoListTodo> {\n  const { user, body } = props;\n\n  // 1. Validate content: trimmed, non-empty, <=255, no control characters\n  const content = body.content.trim();\n  if (content.length === 0)\n    throw new HttpException(\"Content must not be empty or whitespace.\", 400);\n  if (content.length > 255)\n    throw new HttpException(\"Content cannot exceed 255 characters.\", 400);\n  if (/[\u0000-\u001f]/.test(content))\n    throw new HttpException(\n      \"Content contains invalid control characters.\",\n      400,\n    );\n\n  // 2. Validate due_date if present: valid ISO date, >= today (UTC)\n  let due_date: (string & tags.Format<\"date-time\">) | null | undefined =\n    undefined;\n  if (body.due_date !== undefined && body.due_date !== null) {\n    // Accept only valid ISO format date (YYYY-MM-DD or full), not past\n    const dateValue = new Date(body.due_date as string);\n    // Check ISO format and valid date\n    if (isNaN(dateValue.getTime()))\n      throw new HttpException(\"Invalid due_date format.\", 400);\n    // Compare to today (UTC, zeroed for time)\n    const today = new Date();\n    today.setUTCHours(0, 0, 0, 0);\n    const dueDateDay = new Date(dateValue);\n    dueDateDay.setUTCHours(0, 0, 0, 0);\n    if (dueDateDay < today)\n      throw new HttpException(\"due_date cannot be in the past.\", 400);\n    // toISOStringSafe returns full date-time; accept date part\n    due_date = toISOStringSafe(dateValue);\n  }\n\n  // 3. Deduplication: user cannot have existing item with same content (recent)\n  const existing = await MyGlobal.prisma.todo_list_todos.count({\n    where: {\n      todo_list_user_id: user.id,\n      content,\n    },\n  });\n  if (existing > 0)\n    throw new HttpException(\n      \"You already have a todo with the same content.\",\n      409,\n    );\n\n  // 4. Insert\n  const now = toISOStringSafe(new Date());\n  const created = await MyGlobal.prisma.todo_list_todos.create({\n    data: {\n      id: v4(),\n      todo_list_user_id: user.id,\n      content,\n      due_date: due_date ?? null,\n      completed: false,\n      completed_at: null,\n      created_at: now,\n      updated_at: now,\n    },\n  });\n\n  // 5. Build output with branded types, correct optionals\n  const result: ITodoListTodo = {\n    id: created.id,\n    todo_list_user_id: created.todo_list_user_id,\n    content: created.content,\n    due_date: created.due_date ? toISOStringSafe(created.due_date) : null,\n    completed: created.completed,\n    completed_at:\n      created.completed_at !== null && created.completed_at !== undefined\n        ? toISOStringSafe(created.completed_at)\n        : null,\n    created_at: toISOStringSafe(created.created_at),\n    updated_at: toISOStringSafe(created.updated_at),\n  };\n\n  return result;\n}\n","endpoint":{"method":"post","path":"/todoList/user/todos"},"name":"posttodoListUserTodos"},{"location":"src/providers/puttodoListUserTodosTodoId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Update a todo item by its unique identifier (todo_list_todos table).\n *\n * This operation updates an existing todo item belonging to the authenticated\n * user. Only the owner may update their own todos. Validates business rules:\n * content (1-255, no all-whitespace, no control chars), due_date (cannot be in\n * the past or before creation), and handles completed status updates. Always\n * updates the last modification timestamp.\n *\n * @param props - Object containing user payload, todoId to update, and body\n *   with optional update fields.\n * @param props.user - The authenticated user performing the update (must be\n *   owner).\n * @param props.todoId - The unique id of the todo to update.\n * @param props.body - Update input fields: content, due_date, completed.\n * @returns The updated todo object with all editable fields and timestamps.\n * @throws {HttpException} When todo does not exist, user not owner, or business\n *   validation fails.\n */\nexport async function puttodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  body: ITodoListTodo.IUpdate;\n}): Promise<ITodoListTodo> {\n  const { user, todoId, body } = props;\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: {\n      id: todoId,\n    },\n  });\n  if (!todo || todo.todo_list_user_id !== user.id) {\n    throw new HttpException(\"Todo not found or access denied\", 404);\n  }\n  // Validate content\n  let updateContent: string | undefined;\n  if (body.content !== undefined) {\n    const trimmed = body.content.trim();\n    if (trimmed.length < 1 || trimmed.length > 255) {\n      throw new HttpException(\"Content must be 1~255 characters\", 400);\n    }\n    if (/\\p{C}/u.test(trimmed)) {\n      throw new HttpException(\"Content cannot contain control characters\", 400);\n    }\n    updateContent = trimmed;\n  }\n  // Validate due_date\n  let updateDueDate: (string & tags.Format<\"date-time\">) | null | undefined =\n    undefined;\n  if (body.due_date !== undefined) {\n    if (body.due_date === null) {\n      updateDueDate = null;\n    } else {\n      // Acceptable formats: 'YYYY-MM-DD' or ISO8601\n      const dueIso =\n        body.due_date.length === 10\n          ? `${body.due_date}T00:00:00.000Z`\n          : body.due_date;\n      const due = new Date(dueIso);\n      const createdAt = new Date(todo.created_at);\n      const now = new Date();\n      if (isNaN(due.getTime())) {\n        throw new HttpException(\"Invalid due_date format\", 400);\n      }\n      if (due < createdAt) {\n        throw new HttpException(\"Due date cannot be before todo creation\", 400);\n      }\n      if (due < now) {\n        throw new HttpException(\"Due date cannot be in the past\", 400);\n      }\n      updateDueDate = toISOStringSafe(due);\n    }\n  }\n  // Completed/completed_at logic\n  let updateCompleted: boolean | undefined;\n  let updateCompletedAt:\n    | (string & tags.Format<\"date-time\">)\n    | null\n    | undefined = undefined;\n  const reqCompleted = body.completed;\n  const oldCompleted = todo.completed;\n  if (reqCompleted !== undefined) {\n    updateCompleted = reqCompleted;\n    if (reqCompleted && !oldCompleted) {\n      updateCompletedAt = toISOStringSafe(new Date());\n    } else if (!reqCompleted) {\n      updateCompletedAt = null;\n    }\n  }\n  // Always update updated_at\n  const updateInput = {\n    ...(updateContent !== undefined && { content: updateContent }),\n    ...(updateDueDate !== undefined && { due_date: updateDueDate }),\n    ...(updateCompleted !== undefined && { completed: updateCompleted }),\n    ...(reqCompleted !== undefined && { completed_at: updateCompletedAt }),\n    updated_at: toISOStringSafe(new Date()),\n  };\n  const updated = await MyGlobal.prisma.todo_list_todos.update({\n    where: { id: todoId },\n    data: updateInput,\n  });\n  return {\n    id: updated.id,\n    todo_list_user_id: updated.todo_list_user_id,\n    content: updated.content,\n    due_date: updated.due_date ? toISOStringSafe(updated.due_date) : null,\n    completed: updated.completed,\n    completed_at: updated.completed_at\n      ? toISOStringSafe(updated.completed_at)\n      : null,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n  };\n}\n","endpoint":{"method":"put","path":"/todoList/user/todos/{todoId}"},"name":"puttodoListUserTodosTodoId"},{"location":"src/providers/puttodoListAdminTodosTodoId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Update (edit) an existing todo item by its unique ID as admin.\n *\n * Allows administrators to update any user's todo. Operates strictly on fields:\n * content, due_date, completed status. Validates content and due_date per\n * business rules, updates updated_at, manages completed_at as appropriate.\n * Throws 404 if todo isn't found.\n *\n * @param props - Update parameters: admin authentication, todoId, update body\n * @param props.admin - Authenticated admin payload\n * @param props.todoId - UUID of the todo to update\n * @param props.body - Update fields (content, due_date, completed)\n * @returns The updated ITodoListTodo object\n * @throws {Error} 404 if todo does not exist, 400 for validation errors\n */\nexport async function puttodoListAdminTodosTodoId(props: {\n  admin: AdminPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  body: ITodoListTodo.IUpdate;\n}): Promise<ITodoListTodo> {\n  const { admin, todoId, body } = props;\n  const now = toISOStringSafe(new Date());\n\n  // Fetch the target todo for update, including created_at\n  const original = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: todoId },\n  });\n  if (!original) throw new HttpException(\"Todo not found\", 404);\n\n  // Validate content if present\n  if (body.content !== undefined) {\n    const trimmed = body.content.trim();\n    if (trimmed.length < 1 || trimmed.length > 255)\n      throw new HttpException(\n        \"Content must be 1-255 non-whitespace chars\",\n        400,\n      );\n    if (/[\u0000-\u001f]/.test(trimmed))\n      throw new HttpException(\"Content cannot contain control chars\", 400);\n  }\n\n  // Validate due_date if present\n  if (body.due_date !== undefined) {\n    if (body.due_date !== null) {\n      // Validate date string is valid and future\n      const due = new Date(body.due_date);\n      if (isNaN(due.getTime()))\n        throw new HttpException(\"Invalid due_date format\", 400);\n      const created = new Date(original.created_at);\n      if (due < created)\n        throw new HttpException(\"Due date cannot be before todo creation\", 400);\n    }\n  }\n\n  // Prepare completed/completed_at logic\n  let completed: boolean | undefined = undefined;\n  let completed_at: (string & tags.Format<\"date-time\">) | null | undefined =\n    undefined;\n  if (body.completed !== undefined) {\n    completed = body.completed;\n    if (body.completed) {\n      // Mark completed: set completed_at to now\n      completed_at = now;\n    } else {\n      // Mark not completed: clear completed_at\n      completed_at = null;\n    }\n  }\n\n  // Build update data object\n  const updateFields: Record<string, unknown> = {\n    content: body.content !== undefined ? body.content.trim() : undefined,\n    due_date: body.due_date !== undefined ? body.due_date : undefined,\n    completed: completed,\n    completed_at: completed_at,\n    updated_at: now,\n  };\n\n  // Remove undefineds\n  Object.keys(updateFields).forEach(\n    (k) => updateFields[k] === undefined && delete updateFields[k],\n  );\n\n  // Perform update\n  const updated = await MyGlobal.prisma.todo_list_todos.update({\n    where: { id: todoId },\n    data: updateFields,\n  });\n\n  return {\n    id: updated.id,\n    todo_list_user_id: updated.todo_list_user_id,\n    content: updated.content,\n    due_date: updated.due_date ? toISOStringSafe(updated.due_date) : undefined,\n    completed: updated.completed,\n    completed_at:\n      updated.completed_at !== null && updated.completed_at !== undefined\n        ? toISOStringSafe(updated.completed_at)\n        : undefined,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n  };\n}\n","endpoint":{"method":"put","path":"/todoList/admin/todos/{todoId}"},"name":"puttodoListAdminTodosTodoId"},{"location":"src/providers/deletetodoListUserTodosTodoId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Permanently delete a specific todo item from the user's todo list.\n *\n * This operation hard deletes the todo from the system, irreversibly removing\n * all task data from persistent storage. Only the owner of the todo (the\n * authenticated user) may perform this action. If the todo does not exist or is\n * not owned by the user, the operation fails with an error. There is no\n * soft-delete. Admin deletion and audit logging are not handled in this\n * user-only context.\n *\n * @param props - Object containing the authenticated user payload and the\n *   todoId (UUID) to delete\n * @param props.user - The authenticated user requesting deletion\n * @param props.todoId - The UUID of the todo to delete\n * @returns Void\n * @throws {Error} 404 if todo not found, 403 if user does not own the todo\n */\nexport async function deletetodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const { user, todoId } = props;\n\n  // Find the todo and verify existence and ownership\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: todoId },\n    select: { id: true, todo_list_user_id: true },\n  });\n  if (!todo) throw new HttpException(\"Not Found: Todo does not exist\", 404);\n  if (todo.todo_list_user_id !== user.id)\n    throw new HttpException(\n      \"Forbidden: You may only delete your own todos\",\n      403,\n    );\n\n  // Hard delete (no soft-deletion)\n  await MyGlobal.prisma.todo_list_todos.delete({\n    where: { id: todoId },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoList/user/todos/{todoId}"},"name":"deletetodoListUserTodosTodoId"},{"location":"src/providers/deletetodoListAdminTodosTodoId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Permanently delete a specific todo item from the user's todo list\n * (todo_list_todos table).\n *\n * Hard-deletes the todo identified by todoId. Operation is allowed only for\n * admin role (admin:AdminPayload required). Ensures that the todo exists; if\n * not, throws 404. After deletion, creates an audit log entry\n * (todo_list_audit_logs) logging action by admin. No soft-delete is performed;\n * the record is fully removed.\n *\n * @param props - Admin: Authenticated admin payload (must be active) todoId:\n *   The UUID of the todo to delete\n * @returns Void on success\n * @throws {HttpException} 404 if todo not found, 403 if authorization fails\n */\nexport async function deletetodoListAdminTodosTodoId(props: {\n  admin: AdminPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const { admin, todoId } = props;\n\n  // Find todo: throw 404 if missing\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: todoId },\n    select: { id: true, todo_list_user_id: true },\n  });\n  if (!todo) {\n    throw new HttpException(\"Todo not found\", 404);\n  }\n\n  // Perform hard delete\n  await MyGlobal.prisma.todo_list_todos.delete({\n    where: { id: todoId },\n  });\n\n  // Create audit log\n  await MyGlobal.prisma.todo_list_audit_logs.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      todo_list_admin_id: admin.id,\n      todo_list_user_id: todo.todo_list_user_id,\n      todo_list_todo_id: todoId,\n      action: \"delete\",\n      rationale: null,\n      created_at: toISOStringSafe(new Date()),\n    },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoList/admin/todos/{todoId}"},"name":"deletetodoListAdminTodosTodoId"},{"location":"src/providers/patchtodoListAdminAuditLogs.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListAuditLog } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAuditLog\";\nimport { IPageITodoListAuditLog } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAuditLog\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Retrieve a filtered, paginated list of audit log entries from\n * todo_list_audit_logs (admin only).\n *\n * This operation allows admin users to search, filter, sort, and paginate\n * admin-audited actions on user todos. It supports filtering by acting admin,\n * affected user, target todo, action type, rationale keyword, created_at time\n * range, and flexible sort and paging options. Only admins may access this\n * endpoint.\n *\n * @param props - Parameters object containing:\n *\n *   - Admin: Authenticated AdminPayload\n *   - Body: ITodoListAuditLog.IRequest filter/search structure\n *\n * @returns Paginated list result with matching audit log summaries\n * @throws {HttpException} 403 Forbidden if not called as admin\n */\nexport async function patchtodoListAdminAuditLogs(props: {\n  admin: AdminPayload;\n  body: ITodoListAuditLog.IRequest;\n}): Promise<IPageITodoListAuditLog.ISummary> {\n  const { admin, body } = props;\n  // Authorization check - required by contract\n  if (!admin || admin.type !== \"admin\") {\n    throw new HttpException(\"Forbidden: Admin authentication required\", 403);\n  }\n\n  // Pagination defaults/limits\n  const safePage = body.page != null && body.page >= 1 ? body.page : 1;\n  const safeLimit =\n    body.limit != null && body.limit >= 1 && body.limit <= 100\n      ? body.limit\n      : 20;\n  const skip = (safePage - 1) * safeLimit;\n  // Allowed sort fields\n  const ALLOWED_SORT: Record<string, true> = {\n    created_at: true,\n    action: true,\n    todo_list_admin_id: true,\n    todo_list_user_id: true,\n    todo_list_todo_id: true,\n  };\n  // Default sort by created_at desc\n  const sortField =\n    typeof body.sort === \"string\" && ALLOWED_SORT[body.sort]\n      ? body.sort\n      : \"created_at\";\n  const sortDirection: \"asc\" | \"desc\" =\n    body.direction === \"asc\" || body.direction === \"desc\"\n      ? body.direction\n      : \"desc\";\n\n  // Build Prisma where filter, handling nullable/optional fields vs required\n  const where = {\n    ...(body.todo_list_admin_id !== undefined &&\n      body.todo_list_admin_id !== null && {\n        todo_list_admin_id: body.todo_list_admin_id,\n      }),\n    ...(body.todo_list_user_id !== undefined &&\n      body.todo_list_user_id !== null && {\n        todo_list_user_id: body.todo_list_user_id,\n      }),\n    ...(body.todo_list_todo_id !== undefined &&\n      body.todo_list_todo_id !== null && {\n        todo_list_todo_id: body.todo_list_todo_id,\n      }),\n    ...(body.action !== undefined &&\n      body.action !== null && { action: body.action }),\n    ...(body.rationale !== undefined &&\n      body.rationale !== null && { rationale: { contains: body.rationale } }),\n    ...((body.from !== undefined && body.from !== null) ||\n    (body.to !== undefined && body.to !== null)\n      ? {\n          created_at: {\n            ...(body.from !== undefined &&\n              body.from !== null && { gte: body.from }),\n            ...(body.to !== undefined && body.to !== null && { lte: body.to }),\n          },\n        }\n      : {}),\n  };\n\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_audit_logs.findMany({\n      where,\n      orderBy: { [sortField]: sortDirection },\n      skip,\n      take: safeLimit,\n    }),\n    MyGlobal.prisma.todo_list_audit_logs.count({ where }),\n  ]);\n\n  const data = rows.map((row) => ({\n    id: row.id,\n    todo_list_admin_id: row.todo_list_admin_id,\n    todo_list_user_id: row.todo_list_user_id,\n    todo_list_todo_id: row.todo_list_todo_id,\n    action: row.action === \"view\" ? \"view\" : \"delete\",\n    rationale: row.rationale ?? undefined,\n    created_at: toISOStringSafe(row.created_at),\n  }));\n\n  return {\n    pagination: {\n      current: Number(safePage),\n      limit: Number(safeLimit),\n      records: total,\n      pages: Math.ceil(total / (safeLimit || 1)),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/admin/auditLogs"},"name":"patchtodoListAdminAuditLogs"},{"location":"src/providers/gettodoListAdminAuditLogsAuditLogId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { HttpException } from \"@nestjs/common\";\nimport { ITodoListAuditLog } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAuditLog\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\n/**\n * Retrieve details of a specific audit log entry from todo_list_audit_logs\n * (admin only).\n *\n * This endpoint allows an admin to view a single, complete audit log entry\n * identified by its UUID in the todo_list_audit_logs table. The returned\n * details provide full visibility into the original admin action (view or\n * delete) upon a user's todo, including all metadata required for compliance,\n * root cause analysis, or resolving operational issues.\n *\n * The operation enforces that only users with the admin role have access.\n * Attempts to view a nonexistent or unauthorized audit log record result in an\n * error with an informative business-level message. Each access to a detailed\n * audit record may itself be logged for traceability, supporting the system's\n * comprehensive oversight requirements.\n *\n * @param props - Object containing admin authentication and the audit log ID\n * @param props.admin - The authenticated admin performing the query\n * @param props.auditLogId - The unique identifier (UUID) of the audit log entry\n *   to retrieve\n * @returns The full details of the specified audit log entry, matching\n *   ITodoListAuditLog structure\n * @throws {Error} If the audit log is not found or the admin is unauthorized\n */\nexport async function gettodoListAdminAuditLogsAuditLogId(props: {\n  admin: AdminPayload;\n  auditLogId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListAuditLog> {\n  const record = await MyGlobal.prisma.todo_list_audit_logs.findUniqueOrThrow({\n    where: { id: props.auditLogId },\n  });\n\n  // Ensure action type only 'view' or 'delete' (per API type, strict mapping)\n  if (record.action !== \"view\" && record.action !== \"delete\") {\n    throw new HttpException(\"Invalid audit log action\", 500);\n  }\n\n  return {\n    id: record.id,\n    todo_list_admin_id: record.todo_list_admin_id,\n    todo_list_user_id: record.todo_list_user_id,\n    todo_list_todo_id: record.todo_list_todo_id,\n    action: record.action,\n    rationale:\n      record.rationale === undefined\n        ? undefined\n        : record.rationale === null\n          ? null\n          : record.rationale,\n    created_at: toISOStringSafe(record.created_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/admin/auditLogs/{auditLogId}"},"name":"gettodoListAdminAuditLogsAuditLogId"}],"controllers":{"src/controllers/auth/user/AuthUserController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { ITodoListUser } from \"../../../api/structures/ITodoListUser\";\n\n@Controller(\"/auth/user\")\nexport class AuthUserController {\n  /**\n   * Register a new user account in todo_list_users and provision JWT tokens\n   * (role: user).\n   *\n   * This API operation allows creation of a new user account for the regular\n   * user role, referencing the todo_list_users table in the Prisma schema. The\n   * join operation enables end users to register with their email and password,\n   * provided fields are unique and conform to database constraints.\n   *\n   * The handler validates the email is not already present in\n   * todo_list_users.email, checks that the password_hash meets required\n   * security standards, and initializes the status field (for instance\n   * 'active') according to business logic. Upon registration, only defined\n   * table fields such as email, password_hash, name (optional), and status are\n   * stored—no extraneous data is accepted. Errors arising from unique\n   * constraint violations or required field omissions are surfaced with\n   * business-appropriate messages.\n   *\n   * The operation is only accessible to users not currently authenticated.\n   * Registration success results in issuing a JWT access token plus a refresh\n   * token, encoding user id from todo_list_users.id and assigning the \"user\"\n   * role. The response conforms to the ITodoListUser.IAuthorized DTO format.\n   * Any edge cases, such as attempting to register with a deactivated,\n   * suspended, or previously soft-deleted email, are handled in accordance with\n   * the current value of the deleted_at and status columns in todo_list_users.\n   *\n   * This endpoint is foundational for onboarding, integrating directly with the\n   * login, refresh, and password management endpoints within the user\n   * authentication flow. If registration is unsuccessful, the operation does\n   * not leak details about which field(s) caused failure beyond standard error\n   * handling. It is closely related to the todo_list_users Prisma DB model and\n   * must align with all its business documentation.\n   *\n   * @param connection\n   * @param body Information required to create a new user account (email,\n   *   password_hash, optional name/avatar for profile, initial status as per\n   *   business logic).\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @TypedBody()\n    body: ITodoListUser.IJoin,\n  ): Promise<ITodoListUser.IAuthorized> {\n    body;\n    return typia.random<ITodoListUser.IAuthorized>();\n  }\n\n  /**\n   * Authenticate a user from todo_list_users, issue new JWT session tokens\n   * (role: user).\n   *\n   * This operation enables existing registered users to authenticate to the\n   * todo list application via email and password, as stored in the\n   * todo_list_users table. The system hashes the supplied password and matches\n   * it against todo_list_users.password_hash for the email record. Logins are\n   * allowed only for users with status indicating active account and a null\n   * value for deleted_at. On a successful login, new JWT access and refresh\n   * tokens are generated as specified by business rules, with the user id and\n   * \"user\" role included in tokens. The last_login_at field is updated to the\n   * present time for audit and security tracking.\n   *\n   * If authentication fails, the system returns a standard login error message,\n   * never exposing which field—email or password—caused failure. Error\n   * reporting follows business guidelines and must not enable user enumeration\n   * attacks. The system checks only real schema fields (email, password_hash,\n   * status, deleted_at).\n   *\n   * Successful logins enable access to all authorized API endpoints for the\n   * user role. This operation seamlessly connects to related endpoints such as\n   * refresh, password-reset (if implemented), and general user session\n   * management. It is always consistent with the todo_list_users schema and\n   * omits extraneous logic or fields.\n   *\n   * @param connection\n   * @param body User login credentials: email address and raw password (to be\n   *   hashed before comparison).\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(\n    @TypedBody()\n    body: ITodoListUser.ILogin,\n  ): Promise<ITodoListUser.IAuthorized> {\n    body;\n    return typia.random<ITodoListUser.IAuthorized>();\n  }\n\n  /**\n   * Renew JWT session tokens for a user by validating a refresh token against\n   * todo_list_users.\n   *\n   * This API operation allows registered user accounts to renew their JWT\n   * session using a valid refresh token referencing an active record in\n   * todo_list_users. The handler extracts and verifies the token, checks the\n   * status and ensures deleted_at is null for the related user, then issues a\n   * fresh JWT access/refresh token pair. If the token is expired, revoked, or\n   * references an ineligible account (wrong status or soft-deleted), errors are\n   * reported per business rules.\n   *\n   * Only fields actually defined in the schema (status, deleted_at, etc.) are\n   * used for account checks. Upon a successful refresh, the service updates the\n   * last_login_at if specified in application logic. No credentials are\n   * required in the request; all context comes from the presented refresh\n   * token.\n   *\n   * This operation is related to login, join, and any password/session\n   * management flows, forming the core of the user's ongoing authentication\n   * lifecycle. Only operations present in todo_list_users, including necessary\n   * validation fields, are referenced.\n   *\n   * @param connection\n   * @param body Valid JWT refresh token referencing a todo_list_users account\n   *   for session renewal.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @TypedBody()\n    body: ITodoListUser.IRefresh,\n  ): Promise<ITodoListUser.IAuthorized> {\n    body;\n    return typia.random<ITodoListUser.IAuthorized>();\n  }\n}\n","src/controllers/auth/admin/AuthAdminController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { ITodoListAdmin } from \"../../../api/structures/ITodoListAdmin\";\n\n@Controller(\"/auth/admin\")\nexport class AuthAdminController {\n  /**\n   * Registers a new administrator in the todo_list_admins table.\n   *\n   * This endpoint registers a new administrator account by creating a record in\n   * the todo_list_admins table. Email uniqueness is enforced by the\n   *\n   * @param connection\n   * @param body Details for creating a new administrator account.\n   * @@unique constraint. The password_hash field must contain a securely\n   * hashed password. Optional fields, such as name and avatar_uri, may be set\n   * by the admin upon creation. The status field controls active/inactive\n   * state. Upon successful join, an authentication token (JWT) is issued that\n   * includes privileges from the privilege_level and status fields. Security\n   * ensures emails cannot be enumerated, and only valid registration requests\n   * are accepted. If registration fails due to constraint violation (e.g.,\n   * email reuse), the operation returns a business-level error with no\n   * sensitive detail.\n   *\n   * This endpoint is public-facing, and account creation is allowed until\n   * registration policies change. Further admin authentication uses the\n   * credentials established here. Password reset and privilege escalation\n   * require additional operations. All admin-centric onboarding flows\n   * reference this join endpoint for initial registration.\n   *\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @TypedBody()\n    body: ITodoListAdmin.IJoin,\n  ): Promise<ITodoListAdmin.IAuthorized> {\n    body;\n    return typia.random<ITodoListAdmin.IAuthorized>();\n  }\n\n  /**\n   * Authenticates admin credentials for todo_list_admins. Issues JWT tokens if\n   * valid.\n   *\n   * Authenticates administrator credentials (email, password) against records\n   * in the todo_list_admins table. Requires the email field to match an\n   * existing administrator and the password to validate against the\n   * password_hash using a secure comparison. Successful login issues JWT access\n   * and refresh tokens, with claims constructed from the id, email,\n   * privilege_level, and status fields. Only admin accounts with status\n   * indicating active are permitted to login. If login fails due to incorrect\n   * credentials, inactive status, or account lockout, a safe generic error is\n   * returned. Rate limits and lockout policy may be enforced to prevent brute\n   * force attacks.\n   *\n   * This operation is foundational for all secure administrative actions.\n   * Follow-up actions such as password reset, 2FA, or session management are\n   * supported in dedicated endpoints. Logging is used for all admin\n   * authentication events to ensure traceability.\n   *\n   * @param connection\n   * @param body Administrator login credentials (email & password).\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(\n    @TypedBody()\n    body: ITodoListAdmin.ILogin,\n  ): Promise<ITodoListAdmin.IAuthorized> {\n    body;\n    return typia.random<ITodoListAdmin.IAuthorized>();\n  }\n\n  /**\n   * Refreshes administrator JWT tokens if current credentials are valid\n   * (todo_list_admins).\n   *\n   * Enables token refresh for an authenticated administrator using a valid\n   * refresh token. Validates the admin’s identity and session by verifying the\n   * refresh token and the current state of the corresponding admin record in\n   * todo_list_admins. Uses the deleted_at and status fields to determine\n   * eligibility for refresh—accounts marked deleted, locked, or disabled cannot\n   * refresh tokens. New JWT tokens, with claims that reflect the up-to-date\n   * privilege_level and status, are issued to maintain secure admin session\n   * continuity. Audit logs are updated for refresh activity. Errors are\n   * returned for any token or status issue.\n   *\n   * @param connection\n   * @param body Administrator refresh token credentials.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @TypedBody()\n    body: ITodoListAdmin.IRefresh,\n  ): Promise<ITodoListAdmin.IAuthorized> {\n    body;\n    return typia.random<ITodoListAdmin.IAuthorized>();\n  }\n}\n","src/controllers/todoList/admin/users/TodolistAdminUsersController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageITodoListUser } from \"../../../../api/structures/IPageITodoListUser\";\nimport { ITodoListUser } from \"../../../../api/structures/ITodoListUser\";\n\n@Controller(\"/todoList/admin/users\")\nexport class TodolistAdminUsersController {\n  /**\n   * Advanced search and pagination of all user accounts (todo_list_users table)\n   * for administrators.\n   *\n   * This PATCH /users operation lets admin users search, filter, and page\n   * through the entire set of registered user accounts. Common use cases\n   * include support intervention, compliance review, and operational\n   * monitoring. It incorporates fields such as user ID, email, display name,\n   * account status, last login time, and creation date. No password or\n   * sensitive token information is ever included in responses.\n   *\n   * Security is a priority: only authenticated users with the 'admin' role can\n   * invoke this endpoint. All search and pagination inputs are validated\n   * against business rules to prevent unauthorized enumeration or injection.\n   * The underlying implementation conforms to the unique and indexed\n   * constraints defined in the schema. System administrators should log access\n   * to this endpoint for audit purposes.\n   *\n   * Relevant Prisma schema: todo_list_users. This operation supports business\n   * reporting, account management, and acts as an entry point to further\n   * user-specific admin actions.\n   *\n   * @param connection\n   * @param body Filter conditions, search queries, and pagination/sorting\n   *   parameters for admin user search.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @TypedBody()\n    body: ITodoListUser.IRequest,\n  ): Promise<IPageITodoListUser.ISummary> {\n    body;\n    return typia.random<IPageITodoListUser.ISummary>();\n  }\n\n  /**\n   * Retrieve a specific user's detailed profile (todo_list_users table) using\n   * their unique userId.\n   *\n   * This GET /users/{userId} operation allows an admin user to access full\n   * details of any user account for business or support needs. The returned\n   * data includes all core fields: id, email, name, avatar_uri, status,\n   * last_login_at, created_at, updated_at, and soft-deletion state\n   * (deleted_at), excluding any sensitive password_hash. This operation is\n   * essential for compliance reviews, user support, and operational\n   * monitoring.\n   *\n   * Authorization is strictly enforced: only 'admin' role users are permitted.\n   * Each access is logged as per compliance and audit policy. If the userId\n   * parameter does not correspond to an existing user, the operation returns a\n   * 'not found' error. Input validation ensures the userId is a proper UUID\n   * before proceeding. This operation supports the overall goal of accountable\n   * and transparent user management.\n   *\n   * @param connection\n   * @param userId Unique identifier (UUID) of the user account to retrieve.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":userId\")\n  public async at(\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListUser> {\n    userId;\n    return typia.random<ITodoListUser>();\n  }\n\n  /**\n   * Update fields of a specific user account (todo_list_users) by admin,\n   * including profile and status changes.\n   *\n   * This PUT /users/{userId} endpoint lets admin users update details in any\n   * user account. Allowed fields include display name, status, avatar_uri, and\n   * optionally email or password_hash for support scenarios (e.g., account\n   * recovery). Updates to the email must maintain unique index constraints and\n   * comply with validation established by the business. Any password_hash\n   * provided must be securely pre-hashed on the client side.\n   *\n   * Only administrators are authorized to use this; audit logs record every\n   * modification for compliance. On success, the updated user record (excluding\n   * credential hash) is returned, reflecting all applied changes. If the\n   * provided userId is invalid or does not exist, a clear error is returned.\n   * Business rules ensure that soft-deleted users are not updated unless\n   * explicitly restored. This operation supports robust account lifecycle\n   * management in accordance with privacy and compliance objectives.\n   *\n   * @param connection\n   * @param userId Unique identifier (UUID) of the user account to update.\n   * @param body Fields and their new values for the user account update. Must\n   *   follow all business validation rules.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":userId\")\n  public async update(\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListUser.IUpdate,\n  ): Promise<ITodoListUser> {\n    userId;\n    body;\n    return typia.random<ITodoListUser>();\n  }\n\n  /**\n   * Soft-delete a user account (todo_list_users) by setting deleted_at; admin\n   * only.\n   *\n   * This DELETE /users/{userId} endpoint lets administrators mark a user\n   * account as deleted by populating the deleted_at field (soft delete),\n   * following the schema's soft deletion pattern. Such accounts are removed\n   * from active listings but remain in the database for retention and\n   * compliance. This operation is strictly permitted only for admin users,\n   * triggering an audit log entry for every deletion.\n   *\n   * Input validation guarantees the userId is a valid UUID and that the account\n   * exists. Attempts to delete non-existent or already-deleted users return a\n   * clear error. Related todos become orphaned or are handled based on\n   * cascading rules. The operation is irreversible—no recovery possible unless\n   * a dedicated restore function is created. This endpoint supports business\n   * needs for privacy, compliance, right-to-be-forgotten scenarios, and account\n   * lifecycle control.\n   *\n   * @param connection\n   * @param userId Unique identifier (UUID) of the user account to soft-delete.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":userId\")\n  public async erase(\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    userId;\n    return typia.random<void>();\n  }\n}\n","src/controllers/todoList/admin/admins/TodolistAdminAdminsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageITodoListAdmin } from \"../../../../api/structures/IPageITodoListAdmin\";\nimport { ITodoListAdmin } from \"../../../../api/structures/ITodoListAdmin\";\n\n@Controller(\"/todoList/admin/admins\")\nexport class TodolistAdminAdminsController {\n  /**\n   * List/search all Todo List administrator accounts with filtering and\n   * pagination (table: todo_list_admins).\n   *\n   * This API operation enables the searching and listing of administrator\n   * accounts registered in the Todo List system. It provides a secure method to\n   * retrieve admin details, supporting filters such as partial email or name\n   * matches, privilege level, and account status (e.g., active, suspended).\n   * Returned results include all fields from the todo_list_admins Prisma table\n   * except sensitive password hashes and soft-deleted accounts (deleted_at is\n   * null).\n   *\n   * The operation is only accessible to authenticated admins with adequate\n   * roles, ensuring that sensitive admin data is not exposed to regular users.\n   * Results are sorted in descending order of creation time by default, but\n   * sorting or pagination options can be specified in the request. This is\n   * typically used in system admin dashboards for oversight, onboarding, or\n   * compliance checks.\n   *\n   * Appropriate business validation is applied to prevent excessive query size\n   * or abuse. Audit logs may be generated for listing large admin datasets. The\n   * response does not include authentication secrets or operational logs\n   * unrelated to account registry.\n   *\n   * @param connection\n   * @param body Search and pagination parameters for admin account filtering\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @TypedBody()\n    body: ITodoListAdmin.IRequest,\n  ): Promise<IPageITodoListAdmin.ISummary> {\n    body;\n    return typia.random<IPageITodoListAdmin.ISummary>();\n  }\n\n  /**\n   * Retrieve detailed information for a specific Todo List administrator\n   * (table: todo_list_admins).\n   *\n   * This API endpoint returns the full detail of an administrator account\n   * specified by the adminId path parameter. It pulls all non-sensitive fields\n   * from the referenced todo_list_admins schema table, supporting\n   * administrative review or management.\n   *\n   * The endpoint requires the caller to be authenticated as an admin. Sensitive\n   * authentication data such as password_hash are excluded from the returned\n   * object. Returned fields include name, email, status, privilege_level,\n   * avatar_uri, timestamp data (created_at, updated_at, last_login_at,\n   * last_admin_action_at), and account state.\n   *\n   * Security enforcement is strict to ensure only admins can access other admin\n   * data. Audit logging of access can be implemented in actual business logic\n   * to comply with operational policy.\n   *\n   * @param connection\n   * @param adminId The unique identifier (UUID) of the target administrator\n   *   account.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":adminId\")\n  public async at(\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListAdmin> {\n    adminId;\n    return typia.random<ITodoListAdmin>();\n  }\n\n  /**\n   * Update the profile or status of a specific administrator account (table:\n   * todo_list_admins).\n   *\n   * This endpoint enables an authenticated admin to update the details of\n   * another admin account, referenced by the adminId path parameter. Fields\n   * eligible for update include name, avatar_uri, status, privilege_level, and\n   * account state (active/suspended/locked), but not authentication secrets or\n   * audit history. The operation validates all inputs according to business\n   * rules, with server-side enforcement of email uniqueness and privilege\n   * change constraints.\n   *\n   * Password resets or credential changes must be performed via separate\n   * dedicated API endpoints for security. The operation is logged as an\n   * administrative action, and only fields defined in ITodoListAdmin.IUpdate\n   * may be altered by this endpoint. On success, the updated admin account\n   * object is returned.\n   *\n   * @param connection\n   * @param adminId The unique identifier (UUID) of the target administrator\n   *   account to update.\n   * @param body Updated administrator account profile/status information\n   *   (excluding password hash)\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":adminId\")\n  public async update(\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListAdmin.IUpdate,\n  ): Promise<ITodoListAdmin> {\n    adminId;\n    body;\n    return typia.random<ITodoListAdmin>();\n  }\n\n  /**\n   * Permanently delete an administrator account (table: todo_list_admins, hard\n   * delete).\n   *\n   * Invoking this endpoint causes the permanent deletion (hard delete) of the\n   * administrator account identified by the adminId path parameter. The\n   * deletion action removes the todo_list_admins row and all associated\n   * relationships, except where foreign key constraints enforce cascading or\n   * retention rules defined by business logic.\n   *\n   * Access to this operation is strictly limited to admin users, reflecting the\n   * seriousness of deleting privileged accounts. Deletion triggers audit\n   * logging for compliance, and the operation is irreversible—deleted admin\n   * records cannot be restored by normal means. Errors are returned if the\n   * target admin does not exist or has already been deleted via soft delete\n   * (deleted_at is non-null).\n   *\n   * Business logic may require additional administrative approval or\n   * confirmation for high-privilege removals. The endpoint does not return a\n   * response body but will signal completion or failure via standard HTTP\n   * status codes.\n   *\n   * @param connection\n   * @param adminId The unique identifier (UUID) of the administrator account to\n   *   delete.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":adminId\")\n  public async erase(\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    adminId;\n    return typia.random<void>();\n  }\n}\n","src/controllers/todoList/user/todos/TodolistUserTodosController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { ITodoListTodo } from \"../../../../api/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"../../../../api/structures/IPageITodoListTodo\";\n\n@Controller(\"/todoList/user/todos\")\nexport class TodolistUserTodosController {\n  /**\n   * Create a new todo item for the current user (todo_list_todos table).\n   *\n   * Create a new todo for the authenticated user. The input must contain valid,\n   * non-empty content (1–255 trimmed non-control characters) and may contain an\n   * optional due date (ISO 8601, not in the past). The system assigns\n   * ownership, sets completed=false, and validates that a similar todo has not\n   * been submitted within the deduplication window for this user.\n   *\n   * Upon success, returns the full todo object with assigned identifiers and\n   * all relevant business fields. Attempts to create todos for other users,\n   * bypassing business validation, or duplicating tasks within the\n   * deduplication window are denied with appropriate error messages. This\n   * operation allows only the \"user\" role to create new todos for themselves.\n   *\n   * Edge cases covered include: whitespace-only content, excessive length,\n   * invalid or past due dates, deduplication, and unauthorized submissions.\n   * Ownership and per-field validation are enforced strictly at the business\n   * logic and API entry level.\n   *\n   * @param connection\n   * @param body Content for the new todo (1–255 chars, no control characters,\n   *   not blank), and optional due date (future or today).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post()\n  public async create(\n    @TypedBody()\n    body: ITodoListTodo.ICreate,\n  ): Promise<ITodoListTodo> {\n    body;\n    return typia.random<ITodoListTodo>();\n  }\n\n  /**\n   * Search and retrieve a filtered, paginated list of todos for a user\n   * (todo_list_todos table).\n   *\n   * Retrieve the list of todos for the currently authenticated user, supporting\n   * advanced search and filtering. Users can retrieve only their own todos,\n   * while admins may access todos across users for audit or troubleshooting\n   * purposes. The results are ordered with the most recently created tasks\n   * first by default. The business rule enforces that only the owner (role:\n   * user) or an admin (role: admin) can access a user's todos; unauthorized\n   * attempts are denied and logged.\n   *\n   * This operation applies field-level filters (content, completion status, due\n   * date window) and supports pagination parameters like page size and offset.\n   * Results exclude todos from soft-deleted users or invalid states. Input\n   * validation prevents negative page sizes or offsets, and content queries are\n   * trimmed & sanitized. This operation is critical for productivity workflows\n   * in the Todo list app, enforcing data privacy and strict row-level access\n   * control.\n   *\n   * Edge cases—such as empty results or invalid filters—are handled gracefully\n   * with clear business error messages and do not leak internal state or\n   * information.\n   *\n   * This endpoint is paired with single-todo retrieval, creation, updating, and\n   * deletion APIs for full user task management.\n   *\n   * @param connection\n   * @param body Search criteria (content, completed, due_date), sort and\n   *   pagination parameters (offset, page size) for todo list retrieval.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @TypedBody()\n    body: ITodoListTodo.IRequest,\n  ): Promise<IPageITodoListTodo.ISummary> {\n    body;\n    return typia.random<IPageITodoListTodo.ISummary>();\n  }\n\n  /**\n   * Retrieve details of a single todo by its unique identifier (todo_list_todos\n   * table).\n   *\n   * Retrieve a single todo item's complete details by its ID. The system\n   * verifies that the requesting user owns the todo identified by todoId, or\n   * that the requester is an admin. Unauthorized access results in a forbidden\n   * action error, and a non-existent todoId generates a not-found error with a\n   * business-appropriate message.\n   *\n   * Returned fields include: unique identifier, owner user ID, content (up to\n   * 255 characters), completion status, due date (if set), timestamps for\n   * creation, last update, and (if completed) completion, as well as relational\n   * references for audit purposes. The data model prohibits exposure of deleted\n   * or inaccessible todos.\n   *\n   * This operation can be used together with update, mark complete/incomplete,\n   * and delete endpoints. The schema enforces ownership and data access at the\n   * business logic level for full regulatory compliance and privacy control.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the target todo to retrieve.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":todoId\")\n  public async at(\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListTodo> {\n    todoId;\n    return typia.random<ITodoListTodo>();\n  }\n\n  /**\n   * Update a todo item by its unique identifier (todo_list_todos table).\n   *\n   * Update (edit) an existing todo item by its unique ID. The input may include\n   * a new content value (subject to strict validation), an updated due date (if\n   * allowed), or a request to change completion status. Ownership is checked:\n   * regular users may only edit their own todos, while admins may update any\n   * user's todo according to business and compliance policy, with all such\n   * actions logged for audit.\n   *\n   * All string and field edits are validated against business logic: content\n   * length/character rules, due date not in the past or before creation,\n   * completion status consistency. The operation returns the full, updated todo\n   * on success, with proper error responses if not found, unauthorized, or\n   * validation fails. Audit logs are generated for admin-driven updates when\n   * required by business policy.\n   *\n   * This endpoint completes the CRUD lifecycle together with create, deletion,\n   * and retrieval endpoints.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the target todo to update.\n   * @param body Update input for the target todo: content (1–255 chars),\n   *   completed status, optional due date.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":todoId\")\n  public async update(\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListTodo.IUpdate,\n  ): Promise<ITodoListTodo> {\n    todoId;\n    body;\n    return typia.random<ITodoListTodo>();\n  }\n\n  /**\n   * Permanently delete a specific todo item from the user's todo list\n   * (todo_list_todos table).\n   *\n   * This endpoint allows a user (or admin) to permanently remove a single todo\n   * item, identified by its UUID, from the todo_list_todos table. The deleted\n   * todo is irreversibly purged; it will not appear in listings, cannot be\n   * restored, and all links to this task are erased from the database.\n   *\n   * To fulfill business logic, the endpoint verifies that the requesting user\n   * is either the owner of the todo or holds an admin role. If a user attempts\n   * to delete a todo they do not own, or that does not exist, the system denies\n   * the operation and returns a business-level error message.\n   *\n   * When an admin performs a delete, the system must create an associated audit\n   * log entry, as described in the audit_logs table specification, to ensure\n   * traceability.\n   *\n   * There is no soft-deletion: records are removed entirely from persistent\n   * storage. This behavior is critical for both user privacy and compliance\n   * with user-level data removal (right to erasure). Error handling includes\n   * returning 'not found' if the todo was already deleted or an invalid UUID is\n   * provided.\n   *\n   * @param connection\n   * @param todoId The unique identifier (UUID) of the todo item to be deleted.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":todoId\")\n  public async erase(\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    todoId;\n    return typia.random<void>();\n  }\n}\n","src/controllers/todoList/admin/todos/TodolistAdminTodosController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageITodoListTodo } from \"../../../../api/structures/IPageITodoListTodo\";\nimport { ITodoListTodo } from \"../../../../api/structures/ITodoListTodo\";\n\n@Controller(\"/todoList/admin/todos\")\nexport class TodolistAdminTodosController {\n  /**\n   * Search and retrieve a filtered, paginated list of todos for a user\n   * (todo_list_todos table).\n   *\n   * Retrieve the list of todos for the currently authenticated user, supporting\n   * advanced search and filtering. Users can retrieve only their own todos,\n   * while admins may access todos across users for audit or troubleshooting\n   * purposes. The results are ordered with the most recently created tasks\n   * first by default. The business rule enforces that only the owner (role:\n   * user) or an admin (role: admin) can access a user's todos; unauthorized\n   * attempts are denied and logged.\n   *\n   * This operation applies field-level filters (content, completion status, due\n   * date window) and supports pagination parameters like page size and offset.\n   * Results exclude todos from soft-deleted users or invalid states. Input\n   * validation prevents negative page sizes or offsets, and content queries are\n   * trimmed & sanitized. This operation is critical for productivity workflows\n   * in the Todo list app, enforcing data privacy and strict row-level access\n   * control.\n   *\n   * Edge cases—such as empty results or invalid filters—are handled gracefully\n   * with clear business error messages and do not leak internal state or\n   * information.\n   *\n   * This endpoint is paired with single-todo retrieval, creation, updating, and\n   * deletion APIs for full user task management.\n   *\n   * @param connection\n   * @param body Search criteria (content, completed, due_date), sort and\n   *   pagination parameters (offset, page size) for todo list retrieval.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @TypedBody()\n    body: ITodoListTodo.IRequest,\n  ): Promise<IPageITodoListTodo.ISummary> {\n    body;\n    return typia.random<IPageITodoListTodo.ISummary>();\n  }\n\n  /**\n   * Retrieve details of a single todo by its unique identifier (todo_list_todos\n   * table).\n   *\n   * Retrieve a single todo item's complete details by its ID. The system\n   * verifies that the requesting user owns the todo identified by todoId, or\n   * that the requester is an admin. Unauthorized access results in a forbidden\n   * action error, and a non-existent todoId generates a not-found error with a\n   * business-appropriate message.\n   *\n   * Returned fields include: unique identifier, owner user ID, content (up to\n   * 255 characters), completion status, due date (if set), timestamps for\n   * creation, last update, and (if completed) completion, as well as relational\n   * references for audit purposes. The data model prohibits exposure of deleted\n   * or inaccessible todos.\n   *\n   * This operation can be used together with update, mark complete/incomplete,\n   * and delete endpoints. The schema enforces ownership and data access at the\n   * business logic level for full regulatory compliance and privacy control.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the target todo to retrieve.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":todoId\")\n  public async at(\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListTodo> {\n    todoId;\n    return typia.random<ITodoListTodo>();\n  }\n\n  /**\n   * Update a todo item by its unique identifier (todo_list_todos table).\n   *\n   * Update (edit) an existing todo item by its unique ID. The input may include\n   * a new content value (subject to strict validation), an updated due date (if\n   * allowed), or a request to change completion status. Ownership is checked:\n   * regular users may only edit their own todos, while admins may update any\n   * user's todo according to business and compliance policy, with all such\n   * actions logged for audit.\n   *\n   * All string and field edits are validated against business logic: content\n   * length/character rules, due date not in the past or before creation,\n   * completion status consistency. The operation returns the full, updated todo\n   * on success, with proper error responses if not found, unauthorized, or\n   * validation fails. Audit logs are generated for admin-driven updates when\n   * required by business policy.\n   *\n   * This endpoint completes the CRUD lifecycle together with create, deletion,\n   * and retrieval endpoints.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the target todo to update.\n   * @param body Update input for the target todo: content (1–255 chars),\n   *   completed status, optional due date.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":todoId\")\n  public async update(\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListTodo.IUpdate,\n  ): Promise<ITodoListTodo> {\n    todoId;\n    body;\n    return typia.random<ITodoListTodo>();\n  }\n\n  /**\n   * Permanently delete a specific todo item from the user's todo list\n   * (todo_list_todos table).\n   *\n   * This endpoint allows a user (or admin) to permanently remove a single todo\n   * item, identified by its UUID, from the todo_list_todos table. The deleted\n   * todo is irreversibly purged; it will not appear in listings, cannot be\n   * restored, and all links to this task are erased from the database.\n   *\n   * To fulfill business logic, the endpoint verifies that the requesting user\n   * is either the owner of the todo or holds an admin role. If a user attempts\n   * to delete a todo they do not own, or that does not exist, the system denies\n   * the operation and returns a business-level error message.\n   *\n   * When an admin performs a delete, the system must create an associated audit\n   * log entry, as described in the audit_logs table specification, to ensure\n   * traceability.\n   *\n   * There is no soft-deletion: records are removed entirely from persistent\n   * storage. This behavior is critical for both user privacy and compliance\n   * with user-level data removal (right to erasure). Error handling includes\n   * returning 'not found' if the todo was already deleted or an invalid UUID is\n   * provided.\n   *\n   * @param connection\n   * @param todoId The unique identifier (UUID) of the todo item to be deleted.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":todoId\")\n  public async erase(\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    todoId;\n    return typia.random<void>();\n  }\n}\n","src/controllers/todoList/admin/auditLogs/TodolistAdminAuditlogsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchtodoListAdminAuditLogs } from \"../../../../providers/patchtodoListAdminAuditLogs\";\nimport { AdminAuth } from \"../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../decorators/payload/AdminPayload\";\n\nimport { IPageITodoListAuditLog } from \"../../../../api/structures/IPageITodoListAuditLog\";\nimport { ITodoListAuditLog } from \"../../../../api/structures/ITodoListAuditLog\";\n\n@Controller(\"/todoList/admin/auditLogs\")\nexport class TodolistAdminAuditlogsController {\n  /**\n   * Retrieve a filtered, paginated list of audit log entries from\n   * todo_list_audit_logs (admin only).\n   *\n   * The audit log list endpoint provides administrative users with advanced\n   * search capabilities for monitoring privileged actions on user todos. Admins\n   * can filter logs by action type (view or delete), target user or todo,\n   * responsible admin, time range, or rationale content. The endpoint supports\n   * pagination to efficiently browse large audit trails and includes sorting by\n   * timestamp or other relevant fields.\n   *\n   * Log records returned by this operation include full audit details—admin\n   * identity, user and todo IDs, action performed, rationale, and\n   * timestamp—enabling forensic analysis and compliance auditing. The response\n   * structure aligns with the todo_list_audit_logs schema, ensuring accurate\n   * mapping of data fields.\n   *\n   * Security is paramount: only users with the admin role are authorized to use\n   * this endpoint. All access is itself subject to audit logging as required by\n   * organizational policy. No unauthorized user data is returned to non-admins.\n   * System-enforced rate limiting and sensitive data protection apply.\n   *\n   * Failure scenarios include improper use by non-admins or invalid filter\n   * criteria; informative error messages are returned to guide corrective\n   * action.\n   *\n   * @param connection\n   * @param body Request parameters for audit log filtering, including\n   *   pagination and search options.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoListAuditLog.IRequest,\n  ): Promise<IPageITodoListAuditLog.ISummary> {\n    try {\n      return await patchtodoListAdminAuditLogs({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve details of a specific audit log entry from todo_list_audit_logs\n   * (admin only).\n   *\n   * This endpoint allows an admin to view a single, complete audit log entry\n   * identified by its UUID in the todo_list_audit_logs table. The returned\n   * details provide full visibility into the original admin action (view or\n   * delete) upon a user's todo, including all metadata required for compliance,\n   * root cause analysis, or resolving operational issues.\n   *\n   * The operation enforces that only users with the admin role have access.\n   * Attempts to view a nonexistent or unauthorized audit log record result in\n   * an error with an informative business-level message. Each access to a\n   * detailed audit record may itself be logged for traceability, supporting the\n   * system's comprehensive oversight requirements.\n   *\n   * Returned data includes referencing fields for admin, affected user, todo\n   * ID, action type, rationale, and audit timestamp, with structure faithfully\n   * matching the todo_list_audit_logs schema.\n   *\n   * @param connection\n   * @param auditLogId The unique identifier (UUID) of the audit log entry to\n   *   retrieve.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":auditLogId\")\n  public async at(\n    @TypedParam(\"auditLogId\")\n    auditLogId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListAuditLog> {\n    auditLogId;\n    return typia.random<ITodoListAuditLog>();\n  }\n}\n"},"compiled":{"type":"success"},"created_at":"2025-09-23T06:11:19.392Z","completed_at":"2025-09-23T06:21:09.983Z","step":0}]