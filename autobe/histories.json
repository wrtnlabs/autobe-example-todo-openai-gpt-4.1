[{"id":"01999b48-ec22-7258-be29-fed1ef9a3dba","type":"userMessage","contents":[{"type":"text","text":"I want to create a Todo list application.\r\n\r\nWhen I build an application, I only want the minimum functionality required for Todo list.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit."}],"created_at":"2025-09-30T15:41:11.586Z"},{"type":"analyze","id":"01999b50-0ea3-70fd-8fbd-c21363f5e107","instruction":"Create a Todo list application with only the minimum functionality required for a basic Todo list. Prioritize simplicity and core features. User has delegated the requirements planning and analysis to AI due to their lack of programming experience. Focus on essential features for a standard Todo list, avoiding additional or complex options. No extra features should be included unless absolutely necessary for basic usage.","prefix":"todoList","roles":[{"name":"user","description":"A registered user who can log in, log out, and manage their own personal todo list, but cannot access or modify other users’ data. Can create, update, mark as complete/incomplete, and delete their own tasks.","kind":"member"},{"name":"admin","description":"An administrator who can view and manage all users and todos in the system, has permission to perform maintenance and emergency recovery tasks.","kind":"admin"}],"files":[{"reason":"To provide a high-level overview and reference point for all other documents, listing their contents and links.","filename":"00-toc.md","documentType":"table-of-contents","outline":["Service Vision & Overview","Problem Definition","Core Value Proposition","Business Model","User Roles & Permissions","User Scenarios","Functional Requirements","Business Rules & Validation","Error & Exception Handling","Security & Privacy","Performance Expectations","Glossary & Future Considerations"],"audience":"general","content":"# Functional Requirements Specification for Minimal Todo List Application\n\n## Core Functional Requirements\n\n### 1. User Registration and Authentication\n- WHEN a user provides valid registration details (email, password), THE system SHALL create a new user account.\n- WHEN a user provides valid login credentials, THE system SHALL authenticate the user and create a user session.\n- IF login credentials are invalid, THEN THE system SHALL deny access and provide an error message.\n- WHEN a logged-in user requests to log out, THE system SHALL end the user session.\n- THE system SHALL ensure that only authenticated users can access any Todo functions (view, create, update, delete their own Todos).\n\n### 2. Todo Task Creation\n- WHEN an authenticated user submits a new Todo with valid content, THE system SHALL create a new Todo item associated with that user.\n- IF a Todo description is empty or only whitespace, THEN THE system SHALL reject the creation request and provide an error message.\n- THE system SHALL limit the maximum Todo description length to 255 characters. IF description exceeds 255 characters, THEN THE system SHALL reject the creation request with an error message.\n\n### 3. Viewing Todos\n- WHEN an authenticated user requests their Todo list, THE system SHALL provide all their own Todo items, sorted in reverse-chronological order of creation (newest first).\n- WHERE the authenticated user is an administrator, THE system SHALL provide the ability to view all users' Todo lists.\n- THE system SHALL not display any user's Todo to any other non-admin user.\n\n### 4. Editing/Updating Todos\n- WHEN an authenticated user requests to edit a Todo they own, THE system SHALL allow updates to the description and completion status.\n- IF a user attempts to edit a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n- IF the user provides an empty or whitespace-only description during update, THEN THE system SHALL reject the update and provide an error message.\n\n### 5. Marking Todos as Complete or Incomplete\n- WHEN the user changes a Todo's completion status, THE system SHALL update the status accordingly for that Todo.\n- THE system SHALL track a boolean completion status (complete/incomplete) for each Todo item.\n\n### 6. Deleting Todos\n- WHEN a user requests to delete their own Todo, THE system SHALL remove that Todo from their list.\n- IF a user attempts to delete a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n\n### 7. Administrative Functions\n- WHERE the acting user has the admin role, THE system SHALL permit administration of any user’s Todos, including view, edit, and delete actions.\n- WHEN an admin deletes or edits a Todo, THE system SHALL record that the action was performed by an administrator.\n\n### 8. Data Integrity\n- THE system SHALL enforce that each Todo is always associated with exactly one user (owner).\n- THE system SHALL ensure that deleting a user will permanently remove all their Todos.\n\n### 9. Out of Scope (to guarantee minimalism)\n- THE system SHALL NOT provide label, category, priority, or deadline fields for Todos.\n- THE system SHALL NOT support recurring Todos, reminders, file attachments, or sharing between users.\n- THE system SHALL NOT allow partial updates except for description and status.\n\n## Acceptance Criteria\n\n1. WHEN a user registers and logs in, they SHALL be able to create, view, edit, complete/incomplete, and delete only their own Todos.\n2. IF a user attempts to access, edit, or delete any Todo they do not own (and are not admin), THEN THE system SHALL prevent the action with an error.\n3. WHERE the user is an admin, THEY SHALL be able to view, edit, and delete any user's Todos system-wide.\n4. WHEN any action fails due to permission, ownership, or input validation, THE system SHALL provide a clear, actionable error message.\n5. WHEN displaying a user's Todos, THE system SHALL always show the most recently created or updated Todos at the top.\n6. WHEN a user deletes their account, all their Todos SHALL be deleted permanently.\n7. THE system SHALL always return own Todos only for standard users and all Todos for admins in list endpoints.\n8. THE system SHALL support at least 1,000 active users and 10,000 total Todos with no decrease in expected response time.\n\n## Non-Functional Requirements\n\n- THE system SHALL provide a response to all Todo CRUD actions within 2 seconds under normal load (up to 10 requests per second).\n- IF the system cannot complete a requested operation due to server error, THEN THE system SHALL notify the user with a generic error message and log the technical details for admin review.\n- THE system SHALL store all user and Todo data securely, accessible only to authenticated users and authorized admins.\n- THE system SHALL log all administrative actions (edit, delete) performed by administrators for audit purposes.\n- THE system SHALL be protected against unauthorized access to Todo and user data by enforcing role and ownership checks at all endpoints.\n\n## Visual Representation: Minimal Todo State Diagram\n\n```mermaid\ngraph LR\n  subgraph \"User Flow\"\n    A[\"Register\"] --> B[\"Login\"]\n    B --> C[\"Create Todo\"]\n    C --> D[\"View Todos\"]\n    D --> E[\"Update/Mark Complete\"]\n    E --> F[\"Delete Todo\"]\n  end\n  subgraph \"Admin Actions\"\n    G[\"Admin View All Todos\"]\n    G --> H[\"Admin Edit/Reassign\"]\n    G --> I[\"Admin Delete Any Todo\"]\n  end\n  F --> J[\"Logout\"]\n  J --> B\n```\n\n# End of document"},{"reason":"To articulate the vision, purpose, and overall scope of the minimal Todo list application before diving into functional details.","filename":"01-service-overview.md","documentType":"service-overview","outline":["Executive Summary","Purpose & Goals","Product Scope","Target Audience","Competitive Positioning"],"audience":"business stakeholders","content":"# Functional Requirements Specification for Minimal Todo List Application\n\n## Core Functional Requirements\n\n### 1. User Registration and Authentication\n- WHEN a user provides valid registration details (email, password), THE system SHALL create a new user account.\n- WHEN a user provides valid login credentials, THE system SHALL authenticate the user and create a user session.\n- IF login credentials are invalid, THEN THE system SHALL deny access and provide an error message.\n- WHEN a logged-in user requests to log out, THE system SHALL end the user session.\n- THE system SHALL ensure that only authenticated users can access any Todo functions (view, create, update, delete their own Todos).\n\n### 2. Todo Task Creation\n- WHEN an authenticated user submits a new Todo with valid content, THE system SHALL create a new Todo item associated with that user.\n- IF a Todo description is empty or only whitespace, THEN THE system SHALL reject the creation request and provide an error message.\n- THE system SHALL limit the maximum Todo description length to 255 characters. IF description exceeds 255 characters, THEN THE system SHALL reject the creation request with an error message.\n\n### 3. Viewing Todos\n- WHEN an authenticated user requests their Todo list, THE system SHALL provide all their own Todo items, sorted in reverse-chronological order of creation (newest first).\n- WHERE the authenticated user is an administrator, THE system SHALL provide the ability to view all users' Todo lists.\n- THE system SHALL not display any user's Todo to any other non-admin user.\n\n### 4. Editing/Updating Todos\n- WHEN an authenticated user requests to edit a Todo they own, THE system SHALL allow updates to the description and completion status.\n- IF a user attempts to edit a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n- IF the user provides an empty or whitespace-only description during update, THEN THE system SHALL reject the update and provide an error message.\n\n### 5. Marking Todos as Complete or Incomplete\n- WHEN the user changes a Todo's completion status, THE system SHALL update the status accordingly for that Todo.\n- THE system SHALL track a boolean completion status (complete/incomplete) for each Todo item.\n\n### 6. Deleting Todos\n- WHEN a user requests to delete their own Todo, THE system SHALL remove that Todo from their list.\n- IF a user attempts to delete a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n\n### 7. Administrative Functions\n- WHERE the acting user has the admin role, THE system SHALL permit administration of any user’s Todos, including view, edit, and delete actions.\n- WHEN an admin deletes or edits a Todo, THE system SHALL record that the action was performed by an administrator.\n\n### 8. Data Integrity\n- THE system SHALL enforce that each Todo is always associated with exactly one user (owner).\n- THE system SHALL ensure that deleting a user will permanently remove all their Todos.\n\n### 9. Out of Scope (to guarantee minimalism)\n- THE system SHALL NOT provide label, category, priority, or deadline fields for Todos.\n- THE system SHALL NOT support recurring Todos, reminders, file attachments, or sharing between users.\n- THE system SHALL NOT allow partial updates except for description and status.\n\n## Acceptance Criteria\n\n1. WHEN a user registers and logs in, they SHALL be able to create, view, edit, complete/incomplete, and delete only their own Todos.\n2. IF a user attempts to access, edit, or delete any Todo they do not own (and are not admin), THEN THE system SHALL prevent the action with an error.\n3. WHERE the user is an admin, THEY SHALL be able to view, edit, and delete any user's Todos system-wide.\n4. WHEN any action fails due to permission, ownership, or input validation, THE system SHALL provide a clear, actionable error message.\n5. WHEN displaying a user's Todos, THE system SHALL always show the most recently created or updated Todos at the top.\n6. WHEN a user deletes their account, all their Todos SHALL be deleted permanently.\n7. THE system SHALL always return own Todos only for standard users and all Todos for admins in list endpoints.\n8. THE system SHALL support at least 1,000 active users and 10,000 total Todos with no decrease in expected response time.\n\n## Non-Functional Requirements\n\n- THE system SHALL provide a response to all Todo CRUD actions within 2 seconds under normal load (up to 10 requests per second).\n- IF the system cannot complete a requested operation due to server error, THEN THE system SHALL notify the user with a generic error message and log the technical details for admin review.\n- THE system SHALL store all user and Todo data securely, accessible only to authenticated users and authorized admins.\n- THE system SHALL log all administrative actions (edit, delete) performed by administrators for audit purposes.\n- THE system SHALL be protected against unauthorized access to Todo and user data by enforcing role and ownership checks at all endpoints.\n\n## Visual Representation: Minimal Todo State Diagram\n\n```mermaid\ngraph LR\n  subgraph \"User Flow\"\n    A[\"Register\"] --> B[\"Login\"]\n    B --> C[\"Create Todo\"]\n    C --> D[\"View Todos\"]\n    D --> E[\"Update/Mark Complete\"]\n    E --> F[\"Delete Todo\"]\n  end\n  subgraph \"Admin Actions\"\n    G[\"Admin View All Todos\"]\n    G --> H[\"Admin Edit/Reassign\"]\n    G --> I[\"Admin Delete Any Todo\"]\n  end\n  F --> J[\"Logout\"]\n  J --> B\n```\n\n# End of document"},{"reason":"To capture the underlying user frustrations and the problem this Todo app aims to solve, ensuring all functionalities relate back to real user needs.","filename":"02-problem-definition.md","documentType":"requirement","outline":["Pain Points & Frustrations","Market Gap","Current Workarounds","Justification for Building"],"audience":"product managers","content":"# Problem Definition and Market Need for Minimal Todo List Application\n\n## 1. Pain Points & Frustrations\n\nDespite the abundance of task management tools available in today’s digital ecosystem, many users experience recurring frustrations with existing Todo applications. Through market analysis and user journey reviews, the following pain points have become clear:\n\n- **Overcomplication and Feature Bloat:** Most Todo list apps have added numerous non-essential features—such as tags, priorities, subtasks, reminders, project collaboration, integrations, and gamification—that overwhelm users who simply want to keep track of basic tasks.\n- **Distracting User Interfaces:** Complex layouts and abundant options can create analysis-paralysis, impeding task entry and review. Users frequently report that too many options take attention away from the core process of adding, viewing, and completing tasks.\n- **Difficult Onboarding or Setup:** Many apps require multi-step registration, feature tutorials, or personalization, preventing instant use for someone who simply wants to write down tasks quickly.\n- **Account Lock-In and Portability Gaps:** Some tools make it hard to export or migrate lists, discouraging users seeking flexible, portable solutions.\n- **Privacy Concerns:** Feature-heavy apps may request more personal data or permissions than are strictly necessary for simple task lists, leading to user distrust.\n- **Lack of Reliability:** Overengineered solutions have more points of failure, causing occasional data loss, sync failures, or slow load times.\n\n## 2. Market Gap\n\nThe current task management market is saturated with productivity solutions, but almost all mature applications suffer from the problem of feature creep. This leaves a gap for a service with the following properties:\n\n- **Minimalist First Design:** Focus solely on the core function—storing and managing a user’s basic personal todo list.\n- **Quick to Learn and Use:** Eliminate the learning curve and allow users to add, view, check off, and delete tasks with minimal steps.\n- **No Distractions or Non-Essential Features:** Strict avoidance of anything not required for the foundational use case.\n- **Data Ownership:** Users retain control of their list with transparent data practices, mitigating concerns of vendor lock-in or over-collection of personal data.\n\nDespite many available tools, there are very few services strictly meeting these minimalist criteria. Most products prioritize competitive differentiators at the cost of simplicity, leaving underserved users looking for a truly basic Todo list experience.\n\n## 3. Current Workarounds\n\nIn response to marketplace frustration, users often:\n- Revert to analog solutions, using pen-and-paper or sticky notes—fast, tangible, but without portability or searchability.\n- Rely on plain text files or basic note-taking apps—simple but missing structured task completion workflows.\n- Use spreadsheets—flexible yet non-intuitive for managing personal tasks day-to-day.\n- Sign up for complex apps but utilize only a tiny fraction of their capabilities, leading to cognitive overload and eventually app abandonment.\n\nAll of these workarounds stem from a common pattern: the lack of viable, sustainable, digital options for frictionless, minimalist todo management.\n\n## 4. Justification for Building\n\nGiven the persistent dissatisfaction above, there is a compelling justification for building a new Todo list solution—provided it strictly embraces the philosophy of minimalism:\n\n- **Direct Response to Real User Frustrations:** The core product requirement—create, read, update, mark complete/incomplete, and delete tasks—addresses the fundamental needs driving user discontent with current solutions. All other features are intentionally excluded to preserve simplicity.\n- **Clear Product Positioning:** By serving users who are alienated by bloated alternatives, a minimal Todo list app establishes a strong value proposition centered on clarity, speed, and zero distractions.\n- **Business Alignment:** Even as a free, non-monetized product, winning the trust of users through transparent, minimal, privacy-respecting features creates opportunities for organic growth or future expansion (e.g., optional donations, premium minimal sync, or open-source community contributions).\n\n### EARS-Driven Problem Requirements\n- WHEN users open the Todo application, THE system SHALL immediately provide access to a personal todo list without requiring any non-essential configuration.\n- WHEN a user adds a task, THE system SHALL allow instant input with no required fields except the task description.\n- WHEN users want to manage tasks, THE system SHALL provide only essential operations: add, update, check/uncheck complete status, and delete.\n- IF non-minimal features are requested or considered, THEN THE system SHALL reject them unless justified as strictly necessary for the core todo experience.\n- THE application SHALL never require or collect more user data than necessary for essential operation.\n- WHILE providing minimal function, THE application SHALL ensure reliability and data safety for all basic tasks.\n\n## Conclusion\n\nThe market and user research confirm a clear, consistent, and unfulfilled need for a strictly minimalist, digital Todo list tool. All envisioned features and requirements for this product must align directly with the pain points, gaps, and real-life user habits described above. This problem statement anchors subsequent documentation, ensuring focused development and user-centered success."},{"reason":"To define the essential value this service provides to its users and what makes its focus on minimalism unique.","filename":"03-core-value-proposition.md","documentType":"business-model","outline":["Key Benefits","Unique Differentiators","Value for Users","Alignment with Minimalism"],"audience":"business stakeholders","content":"# Core Value Proposition for the Minimal Todo List Service\n\n## Key Benefits\n\nThe Todo list service is designed with an uncompromising commitment to minimalism, focusing exclusively on the most fundamental needs for task management. The benefits provided to users and stakeholders are:\n\n- Absolute simplicity enables users of all technical backgrounds to immediately use the service without onboarding or training.\n- Zero distraction from the essential function: managing personal tasks—users engage only with features that directly support creating, viewing, updating, completing, and deleting their own todos.\n- A frictionless user experience, minimizing cognitive overhead and configuration. This increases adoption, encourages frequent task capture, and leads to better task execution in daily lives.\n- No extraneous features are present, meaning every interface, workflow, and requirement exists in service of the main goal: effective personal task tracking with no unnecessary complexity.\n- Reliable and consistent access to a user’s own todo list, empowering individuals to take control of their productivity in a fast, clear, and focused way.\n\n## Unique Differentiators\n\nThis Todo list service differentiates itself from the broad landscape of productivity and task management tools through its radical adherence to minimalism:\n\n- **Single-purpose focus**: The system does only one thing—enables users to manage their personal list of tasks. There are no secondary modules, integrations, or feature bloat.\n- **No barriers to entry**: Registration and login are as simple as possible, strictly to support secure personal task management. There are no social, collaborative, or extended account management functions.\n- **Consistency and speed**: The system is designed so that users can expect actions (creation, update, completion marking, deletion) on their todos to be immediate and consistent, aligning with EARS performance standards.\n- **Predictable experience**: Absence of notifications, reminders, prioritization, or categorization ensures that the service remains timeless and predictable rather than feature-chasing trends.\n- **Administrative clarity**: Administrative users are empowered only to perform maintenance and support on behalf of the whole system and have no business-facing feature influence, ensuring no feature creep occurs.\n\n## Value for Users\n\nFor users, the value delivered by this minimal Todo list service is manifested in the following areas:\n\n- Control: Users can add, view, complete, and delete their own tasks quickly, aiding short-term and long-term organization without noise or confusion.\n- Trust: There are no hidden functions—what the user sees is exactly what will be part of their reliable productivity workflow.\n- Privacy and boundaries: Users’ tasks are personal; each individual’s todo list and actions are accessible only to them, governed by a secure, minimal authentication model.\n- Mental clarity: By reducing the system to basic task management alone, users are protected from option fatigue and can maintain focus on important tasks.\n- Self-improvement: The service supports effective life and work management by making the essential process of capturing and completing tasks as simple and frictionless as possible.\n\n## Alignment with Minimalism\n\nMinimalism is not only a design principle, but the primary business promise of the service. The operational strategy is to:\n\n- Avoid feature bloat by committing to only those requirements that are indispensable for personal todo tracking. This refusal to add more is a business rule and a strategic differentiator.\n- Use EARS requirement formats to guarantee the lowest possible ambiguity and clearest possible user experience. Every functional specification exists to serve this simplicity.\n- Sustainably reduce technical and cognitive maintenance cost for both users and maintenance staff, ensuring a robust and adaptable application over time.\n\nThe minimalism-focused approach minimizes risk for business stakeholders, reduces effort required for maintenance, and ensures that users can always trust the core value proposition: a Todo list that is and always remains truly minimal, focused, and functional."},{"reason":"To clarify the business model, success metrics, monetization strategy, and growth plan even for a minimal free service.","filename":"04-business-model.md","documentType":"business-model","outline":["Why This Service Exists","Revenue Strategy","Growth Plan","Success Metrics"],"audience":"business stakeholders","content":"# Minimal Todo List Application — Business Model\n\n## Why This Service Exists\n\nThe minimal Todo list application exists to address the widespread need for a simple, distraction-free personal task management tool. Many users are overwhelmed by feature-heavy productivity apps and desire a lightweight solution for tracking tasks and daily goals. This service targets individuals who value usability, speed, and clarity over complexity. By focusing on the absolute essentials, it enables users to organize daily tasks, improve personal accountability, and reduce cognitive overload.\n\n### Addressing Market Gap\n- Many todo applications add complex features (collaboration, tagging, sharing, automation) that are unnecessary for users seeking simplicity.\n- WHEN users experience feature fatigue from complex productivity apps, THE minimal todo application SHALL provide an intuitive, effortless alternative for creating and managing personal todos.\n- THE service SHALL appeal to those who prioritize rapid task entry and management without onboarding friction or non-essential options.\n\n## Revenue Strategy\n\nWhile the minimal Todo list application is designed primarily as a free service to maximize accessibility and eliminate barriers to entry, several business model considerations apply:\n\n- **Core principle:** The service WILL NOT require payment for standard features; its value proposition is rooted in being free, fast, and essential.\n- **Optional donations/support:** WHERE users wish to support ongoing maintenance, THE service SHALL provide a voluntary donation or tip-jar mechanism (future consideration, not launch requirement).\n- **No ads:** THE service SHALL launch and operate without advertising to preserve simplicity and user trust.\n- **Data privacy:** THE service SHALL never monetize user data through sale or third-party marketing partnerships.\n\nIf future growth warrants sustainable revenue, premium (opt-in) features such as enhanced customization, analytics, or secure multi-device sync MAY be considered while retaining a robust free core experience.\n\n## Growth Plan\n\nTHE growth approach focuses on virality, word-of-mouth, and organic reach rather than expensive marketing campaigns or partnerships. Growth strategies include:\n- WHEN a new user successfully adopts the Todo list and finds value, THE service SHALL encourage organic sharing by enabling users to recommend the app to friends in a non-intrusive, optional manner (e.g., simple “share” link or lightweight badge post-onboarding, no social spam).\n- THE app SHALL be discoverable via search engines and product directories relevant to productivity and minimalism.\n- Product Hunt/Reddit/Productivity blogs outreach at initial launch.\n- Continuous iteration for speed, reliability, and clarity based on user feedback.\n- Community engagement: THE service SHALL maintain clear channels (email, feedback forms) for users to suggest improvements or report issues, facilitating user-driven growth and advocacy.\n\n## Success Metrics\n\nTHE service SHALL measure and report success using the following business-facing key performance indicators (KPIs):\n\n| Metric                       | Description                                                       |\n|------------------------------|-------------------------------------------------------------------|\n| Daily Active Users (DAU)     | # of unique users engaging each day                                |\n| Weekly Active Users (WAU)    | # of unique users engaging each week                               |\n| Task Completion Rate         | Proportion of created tasks that are marked completed              |\n| Retention Rate (7/30 days)   | % of users returning after 7 and 30 days post-registration         |\n| Churn Rate                   | % of users who become inactive over specified periods              |\n| Avg. Tasks Per User          | Average # of tasks created or completed per user                   |\n| Onboarding Completion Rate   | % of new users who create a todo within their first session        |\n| User Feedback Volume         | Number/quality of feedback or suggestions submitted                |\n\nThese metrics provide clear, actionable feedback on product-market fit, engagement, and improvement opportunities, guiding sustainable development of the minimal todo list application."},{"reason":"To comprehensively define all user roles, permissions, authentication and authorization flows required for secure operation.","filename":"05-user-roles-permissions.md","documentType":"requirement","outline":["Authentication Requirements","Role Hierarchy & Permissions","Token & Session Management","Permission Matrix"],"audience":"backend developers","content":"# User Roles, Permissions, Authentication & Authorization Requirements\n\n## Authentication Requirements\n\n### Core Authentication Functions\n- THE system SHALL allow new users to register their account with an email and password.\n- THE system SHALL require user registration and verified email prior to granting persistent access to core features.\n- WHEN a user submits login credentials, THE system SHALL authenticate the user by validating credentials against registered data.\n- WHEN a user successfully authenticates, THE system SHALL issue a new JWT access token and refresh token for session management.\n- THE system SHALL allow users to log out, invalidating their active session and tokens.\n- WHEN a user requests a password reset, THE system SHALL provide a secure password reset mechanism via email.\n- WHEN a user changes their password, THE system SHALL require re-authentication with the current valid password, and invalidate all prior sessions.\n- WHEN a user requests email verification, THE system SHALL send a verification code or link to the registered email.\n- IF login attempts fail due to incorrect credentials, THEN THE system SHALL reject access and display a clear error message, without revealing which field was incorrect.\n- IF a user's access token is expired, THEN THE system SHALL require use of a valid refresh token for session renewal, else prompt for re-login.\n- THE system SHALL securely manage all user sessions, supporting single-login per device and allowing session revocation.\n- WHEN an admin performs maintenance or emergency account recovery, THE system SHALL log all such activities and require two-factor confirmation if supported by business procedures.\n\n## Role Hierarchy & Permissions\n\n### Role Definitions\n| Role  | Description |\n|-------|-------------|\n| user  | A registered user who can manage only their own Todo list and related tasks. Cannot access or modify any other user's data. |\n| admin | An administrator who can manage all users and todos across the system, and perform emergency recovery/maintenance actions. |\n\n### Role-based Business Requirements\n- WHERE a person is not authenticated, THE system SHALL prevent all access to any Todo-related operations except registration, login, and password reset.\n- WHERE a user is authenticated as 'user', THE system SHALL allow full CRUD operations (create, read, update, delete) only on that user's own Todo items.\n- WHERE a user is authenticated as 'user', THE system SHALL prevent any access to other users' data, todos, or profiles.\n- WHERE a user is authenticated as 'admin', THE system SHALL allow view, update, or deletion of any user's todos and user management operations.\n- WHERE a user is authenticated as 'admin', THE system SHALL allow viewing of system logs, activity trails, and execution of system-level recovery or maintenance features.\n- WHEN an action is attempted that is outside the current user's role, THEN THE system SHALL reject the action and display a clear, non-specific error message (e.g., \"You do not have permission to perform this action.\").\n\n### Edge Cases and Restrictions\n- IF a 'user' attempts to escalate privilege or access admin functions, THEN THE system SHALL log the attempt and block the operation.\n- IF an 'admin' attempts to delete their own admin account, THEN THE system SHALL reject the operation to preserve at least one system administrator.\n\n## Token & Session Management\n\n### Token Strategy\n- THE system SHALL use JWT (JSON Web Tokens) for user authentication and session management.\n- JWT access tokens SHALL have a short expiration period (15–30 minutes recommended), after which users must provide a refresh token or re-authenticate.\n- JWT refresh tokens SHALL have a longer expiration period (7–30 days recommended), and may be invalidated upon logout or password change.\n- THE system SHALL store tokens securely, either in localStorage (for user convenience) or via secure httpOnly cookies (for enhanced security, as business needs dictate).\n- Each JWT issued SHALL contain at minimum: userId, user role, a permissions array matching that role, token expiration timestamp, unique token signature.\n- THE system SHALL securely manage secret keys for signing JWTs, implementing rotation policies as dictated by organizational security practices.\n- WHEN a user's session expires or tokens are revoked/invalid, THE system SHALL require re-authentication.\n\n### Session Management Business Logic\n- THE system SHALL support explicit logout to immediately invalidate session and tokens.\n- THE system SHALL allow users to review and revoke any device’s session, requiring token invalidation and re-login from that device.\n- WHEN a password is changed, THE system SHALL expire all currently active access and refresh tokens for that user.\n\n## Permission Matrix\n\n| Business Action          | user | admin |\n|-------------------------|------|-------|\n| Register account        | ✅   | ✅    |\n| Login                   | ✅   | ✅    |\n| Logout                  | ✅   | ✅    |\n| Password reset          | ✅   | ✅    |\n| Create own Todo         | ✅   | ✅    |\n| Read own Todo           | ✅   | ✅    |\n| Update own Todo         | ✅   | ✅    |\n| Delete own Todo         | ✅   | ✅    |\n| Read others’ Todos      | ❌   | ✅    |\n| Update others’ Todos    | ❌   | ✅    |\n| Delete others’ Todos    | ❌   | ✅    |\n| View user list          | ❌   | ✅    |\n| Update user roles       | ❌   | ✅    |\n| Delete user account     | ❌   | ✅    |\n| Emergency recovery      | ❌   | ✅    |\n| System maintenance      | ❌   | ✅    |\n\n### EARS-based Requirements for Permissions\n- WHEN a user with 'user' role requests Todo creation, reading, updating, or deletion, THE system SHALL ensure these actions affect only their own data.\n- IF a user with 'user' role requests access to other users’ information or tasks, THEN THE system SHALL deny the request and log the incident.\n- WHEN a user with 'admin' role requests access to any user’s Todos, THE system SHALL grant that access.\n- WHEN a user with 'admin' role performs user management, THE system SHALL require audit logging of all such actions.\n\n## Mermaid Diagram – Authentication & Authorization Flows\n\n```mermaid\ngraph LR\n    subgraph \"Authentication Flow\"\n        A[\"Register (Email, Password)\"] --> B[\"Email Verification\"]\n        B --> C[\"Login (Credentials)\"]\n        C --> D[\"Success: Issue JWT Access/Refresh Tokens\"]\n        C --> E[\"Fail: Error Feedback\"]\n    end\n    subgraph \"Session & Permission\"\n        D --> F{\"Role = user or admin?\"}\n        F -->|\"user\"| G[\"Access Own Todos\"]\n        F -->|\"admin\"| H[\"Manage All Users & Todos\"]\n        G --> I[\"CRUD: Own Todos\"]\n        H --> J[\"Admin Functions\"]\n    end\n    G --> K[\"Logout\"]\n    H --> K\n    E --> L[\"Retry / Reset Password\"]\n```\n\n## Error Scenarios (Selection)\n- IF any authentication token is missing, expired, or invalid, THEN THE system SHALL block all access except login/registration/password reset.\n- IF a user repeatedly fails logins (e.g., 5 failed attempts in 10 minutes), THEN THE system SHALL lock the account temporarily and require further identity proof to unlock.\n- IF session or device is not recognized after password reset, THEN THE system SHALL require re-authentication.\n\n## Business Requirements Only\n\n> *Developer Note: This document defines business requirements only. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*\n"},{"reason":"To provide concrete, natural-language examples of how users interact with the Todo list, including all core flows and edge cases.","filename":"06-user-scenarios.md","documentType":"user-story","outline":["Primary User Journeys","Typical Success Paths","Edge Cases & Alternatives"],"audience":"product managers","content":"# User Scenarios for Minimal Todo List Application\n\n## Introduction\nThis document presents comprehensive user scenarios for the minimal Todo list application, focusing exclusively on essential interactions and flows as defined by the minimal business requirements. Its purpose is to equip product and backend teams with life-like scenarios, ensuring clarity around expected user behavior, core journeys, and major edge cases for both standard users and administrators.\n\n## Primary User Journeys\n\n### 1. Registering and Logging In\n**Scenario 1:** New User Registration and Login\n- A visitor accesses the Todo service landing page.\n- They choose to register an account, providing a valid email address and password.\n- Upon successful registration, the user is prompted to log in.\n- The user enters credentials and is signed in, establishing a secure session.\n\n**EARS:**\n- WHEN a non-registered visitor submits the registration form with a unique, valid email and password, THE system SHALL create a new user account.\n- IF the email is already used, THEN THE system SHALL reject the registration and display an error message.\n- WHEN a user submits correct login credentials, THE system SHALL grant access to their account.\n- IF login credentials are invalid, THEN THE system SHALL deny access and present an error notification.\n\n### 2. Creating a Todo Task\n**Scenario 2:** User Adds a Task\n- The logged-in user views their empty task list.\n- They add a new task by entering a short description (e.g., \"Buy groceries\").\n- The new task appears immediately in their list.\n\n**EARS:**\n- WHEN a user submits a new todo description, THE system SHALL add the task to the user’s list and show immediate confirmation.\n- IF the task description is missing or exceeds character limits, THEN THE system SHALL reject the creation attempt and present a validation error.\n\n### 3. Viewing the Todo List\n**Scenario 3:** User Reviews Todo List and Status\n- Upon logging in, the user sees their current list of todos.\n- Tasks are clearly displayed, indicating whether each is complete or incomplete.\n- The user checks remaining tasks and completed work.\n\n**EARS:**\n- WHEN a user views their dashboard, THE system SHALL display all existing tasks, sorted by creation date.\n- IF the user has no tasks, THEN THE system SHALL present a friendly message and a call to create their first task.\n\n### 4. Editing a Todo Task\n**Scenario 4:** User Updates Task Description\n- The user decides to update an existing task’s description (typo correction, clarification).\n- After editing and saving, the updated text appears in the list.\n\n**EARS:**\n- WHEN a user requests to edit a task, THE system SHALL allow description updates, enforcing the same validation rules as for creation.\n- IF the user tries to edit a task not owned by them, THEN THE system SHALL deny access.\n\n### 5. Marking Tasks as Complete or Incomplete\n**Scenario 5:** Task Status Change\n- The user marks a task as complete (e.g., \"Finish reading book\").\n- The completed task is visually distinguished in the list.\n- The user can revert the status to incomplete as needed.\n\n**EARS:**\n- WHEN a user updates a task’s status, THE system SHALL toggle it between complete and incomplete.\n- IF the user attempts to modify another user’s task, THEN THE system SHALL deny the action.\n\n### 6. Deleting Tasks\n**Scenario 6:** User Removes a Task\n- The user finishes all work and wants to clean up their list.\n- They delete a completed or unwanted task; it is removed instantly.\n\n**EARS:**\n- WHEN a user requests deletion of a task, THE system SHALL permanently remove it from their list.\n- IF the user attempts to delete a nonexistent or unauthorized task, THEN THE system SHALL show an error.\n\n### 7. Logging Out\n**Scenario 7:** Ending the Session\n- The user chooses to log out using a visible option.\n- The system terminates the session and returns to the login screen.\n- Any subsequent attempt to access personal data redirects to login.\n\n**EARS:**\n- WHEN a user logs out, THE system SHALL terminate the current session immediately.\n- IF a user tries to access restricted functions while logged out, THEN THE system SHALL require re-authentication.\n\n### 8. Admin User: Managing All Todos and Users\n**Scenario 8:** Admin Oversight\n- An admin logs in through the same interface as users.\n- They can view all users and todos in the system.\n- The admin may delete, view, or update any user’s task as needed for maintenance or emergency recovery.\n- Admin can perform user account and data cleanup actions (e.g., in case of system abuse or account compromise).\n\n**EARS:**\n- WHERE the user is an admin, THE system SHALL permit management of all user accounts and todos.\n- IF an admin deletes a user, THEN THE system SHALL permanently remove all associated data.\n\n## Typical Success Paths\n\n### Registration & Login\n1. Visitor registers with valid credentials → receives confirmation → logs in → sees empty todo list.\n\n### Task Creation\n1. User adds new task → sees it instantly in list.\n2. User creates several tasks → tasks are individually listed and sorted by time.\n\n### Task Management\n1. User edits existing task → update reflects immediately.\n2. User marks task as complete → status change is shown in UI visibly.\n3. User deletes task → task disappears from the list without error.\n\n### Admin Flow\n1. Admin logs in → views all users/tasks → removes offensive content → affected data purged immediately.\n\n## Edge Cases & Alternatives\n\n### Invalid or Missing Input Data\n- User attempts to register with an email already in use: Registration refused, clear feedback provided.\n- User tries to add a task with an empty description or one exceeding max allowed length: Validation error shown.\n- User tries to update or delete a nonexistent or unauthorized task: Access denied, error message provided.\n\n### Unauthorized Access Scenarios\n- Non-authenticated visitor tries to access the todo list: Redirected to login/registration.\n- User attempts to manipulate tasks belonging to another user: Blocked, with clear user-facing error.\n- Session expires and user tries to submit action: System prompts for re-authentication.\n\n### System Recovery and Error Resilience\n- User’s action fails due to temporary backend issue: System displays a generic error, encourages retry.\n- Partial data available (e.g., during temporary sync problems): UI explains status, tasks are re-fetched as soon as possible.\n\n## Summary of User Scenario Coverage\nThis document has illustrated all main user and admin journeys, as well as boundary and adverse cases, for the minimal Todo list application. Every path represents a business requirement that is traceable in the [Functional Requirements Document](./08-functional-requirements.md) and [User Roles & Permissions Reference](./05-user-roles-permissions.md). Edge cases address the most critical input and security failures, defining expected system behavior to ensure a robust, simple, and usable experience for all roles."},{"reason":"To map out in detail the typical step-by-step flows users will undertake to use the core application features, supporting backend development and QA.","filename":"07-user-flows.md","documentType":"user-flow","outline":["Task Creation Flow","Task Completion Flow","Task Update/Delete Flow","Authentication Flow"],"audience":"backend developers","content":"# Functional Requirements Specification for Minimal Todo List Application\n\n## Core Functional Requirements\n\n### 1. User Registration and Authentication\n- WHEN a user provides valid registration details (email, password), THE system SHALL create a new user account.\n- WHEN a user provides valid login credentials, THE system SHALL authenticate the user and create a user session.\n- IF login credentials are invalid, THEN THE system SHALL deny access and provide an error message.\n- WHEN a logged-in user requests to log out, THE system SHALL end the user session.\n- THE system SHALL ensure that only authenticated users can access any Todo functions (view, create, update, delete their own Todos).\n\n### 2. Todo Task Creation\n- WHEN an authenticated user submits a new Todo with valid content, THE system SHALL create a new Todo item associated with that user.\n- IF a Todo description is empty or only whitespace, THEN THE system SHALL reject the creation request and provide an error message.\n- THE system SHALL limit the maximum Todo description length to 255 characters. IF description exceeds 255 characters, THEN THE system SHALL reject the creation request with an error message.\n\n### 3. Viewing Todos\n- WHEN an authenticated user requests their Todo list, THE system SHALL provide all their own Todo items, sorted in reverse-chronological order of creation (newest first).\n- WHERE the authenticated user is an administrator, THE system SHALL provide the ability to view all users' Todo lists.\n- THE system SHALL not display any user's Todo to any other non-admin user.\n\n### 4. Editing/Updating Todos\n- WHEN an authenticated user requests to edit a Todo they own, THE system SHALL allow updates to the description and completion status.\n- IF a user attempts to edit a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n- IF the user provides an empty or whitespace-only description during update, THEN THE system SHALL reject the update and provide an error message.\n\n### 5. Marking Todos as Complete or Incomplete\n- WHEN the user changes a Todo's completion status, THE system SHALL update the status accordingly for that Todo.\n- THE system SHALL track a boolean completion status (complete/incomplete) for each Todo item.\n\n### 6. Deleting Todos\n- WHEN a user requests to delete their own Todo, THE system SHALL remove that Todo from their list.\n- IF a user attempts to delete a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n\n### 7. Administrative Functions\n- WHERE the acting user has the admin role, THE system SHALL permit administration of any user’s Todos, including view, edit, and delete actions.\n- WHEN an admin deletes or edits a Todo, THE system SHALL record that the action was performed by an administrator.\n\n### 8. Data Integrity\n- THE system SHALL enforce that each Todo is always associated with exactly one user (owner).\n- THE system SHALL ensure that deleting a user will permanently remove all their Todos.\n\n### 9. Out of Scope (to guarantee minimalism)\n- THE system SHALL NOT provide label, category, priority, or deadline fields for Todos.\n- THE system SHALL NOT support recurring Todos, reminders, file attachments, or sharing between users.\n- THE system SHALL NOT allow partial updates except for description and status.\n\n## Acceptance Criteria\n\n1. WHEN a user registers and logs in, they SHALL be able to create, view, edit, complete/incomplete, and delete only their own Todos.\n2. IF a user attempts to access, edit, or delete any Todo they do not own (and are not admin), THEN THE system SHALL prevent the action with an error.\n3. WHERE the user is an admin, THEY SHALL be able to view, edit, and delete any user's Todos system-wide.\n4. WHEN any action fails due to permission, ownership, or input validation, THE system SHALL provide a clear, actionable error message.\n5. WHEN displaying a user's Todos, THE system SHALL always show the most recently created or updated Todos at the top.\n6. WHEN a user deletes their account, all their Todos SHALL be deleted permanently.\n7. THE system SHALL always return own Todos only for standard users and all Todos for admins in list endpoints.\n8. THE system SHALL support at least 1,000 active users and 10,000 total Todos with no decrease in expected response time.\n\n## Non-Functional Requirements\n\n- THE system SHALL provide a response to all Todo CRUD actions within 2 seconds under normal load (up to 10 requests per second).\n- IF the system cannot complete a requested operation due to server error, THEN THE system SHALL notify the user with a generic error message and log the technical details for admin review.\n- THE system SHALL store all user and Todo data securely, accessible only to authenticated users and authorized admins.\n- THE system SHALL log all administrative actions (edit, delete) performed by administrators for audit purposes.\n- THE system SHALL be protected against unauthorized access to Todo and user data by enforcing role and ownership checks at all endpoints.\n\n## Visual Representation: Minimal Todo State Diagram\n\n```mermaid\ngraph LR\n  subgraph \"User Flow\"\n    A[\"Register\"] --> B[\"Login\"]\n    B --> C[\"Create Todo\"]\n    C --> D[\"View Todos\"]\n    D --> E[\"Update/Mark Complete\"]\n    E --> F[\"Delete Todo\"]\n  end\n  subgraph \"Admin Actions\"\n    G[\"Admin View All Todos\"]\n    G --> H[\"Admin Edit/Reassign\"]\n    G --> I[\"Admin Delete Any Todo\"]\n  end\n  F --> J[\"Logout\"]\n  J --> B\n```\n\n# End of document"},{"reason":"To state, in unambiguous natural-language terms (using EARS framework), each business requirement and acceptance criterion for the minimal Todo application.","filename":"08-functional-requirements.md","documentType":"requirement","outline":["Core Functional Requirements","Acceptance Criteria","Non-Functional Requirements"],"audience":"backend developers","content":"# Functional Requirements Specification for Minimal Todo List Application\n\n## Core Functional Requirements\n\n### 1. User Registration and Authentication\n- WHEN a user provides valid registration details (email, password), THE system SHALL create a new user account.\n- WHEN a user provides valid login credentials, THE system SHALL authenticate the user and create a user session.\n- IF login credentials are invalid, THEN THE system SHALL deny access and provide an error message.\n- WHEN a logged-in user requests to log out, THE system SHALL end the user session.\n- THE system SHALL ensure that only authenticated users can access any Todo functions (view, create, update, delete their own Todos).\n\n### 2. Todo Task Creation\n- WHEN an authenticated user submits a new Todo with valid content, THE system SHALL create a new Todo item associated with that user.\n- IF a Todo description is empty or only whitespace, THEN THE system SHALL reject the creation request and provide an error message.\n- THE system SHALL limit the maximum Todo description length to 255 characters. IF description exceeds 255 characters, THEN THE system SHALL reject the creation request with an error message.\n\n### 3. Viewing Todos\n- WHEN an authenticated user requests their Todo list, THE system SHALL provide all their own Todo items, sorted in reverse-chronological order of creation (newest first).\n- WHERE the authenticated user is an administrator, THE system SHALL provide the ability to view all users' Todo lists.\n- THE system SHALL not display any user's Todo to any other non-admin user.\n\n### 4. Editing/Updating Todos\n- WHEN an authenticated user requests to edit a Todo they own, THE system SHALL allow updates to the description and completion status.\n- IF a user attempts to edit a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n- IF the user provides an empty or whitespace-only description during update, THEN THE system SHALL reject the update and provide an error message.\n\n### 5. Marking Todos as Complete or Incomplete\n- WHEN the user changes a Todo's completion status, THE system SHALL update the status accordingly for that Todo.\n- THE system SHALL track a boolean completion status (complete/incomplete) for each Todo item.\n\n### 6. Deleting Todos\n- WHEN a user requests to delete their own Todo, THE system SHALL remove that Todo from their list.\n- IF a user attempts to delete a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n\n### 7. Administrative Functions\n- WHERE the acting user has the admin role, THE system SHALL permit administration of any user’s Todos, including view, edit, and delete actions.\n- WHEN an admin deletes or edits a Todo, THE system SHALL record that the action was performed by an administrator.\n\n### 8. Data Integrity\n- THE system SHALL enforce that each Todo is always associated with exactly one user (owner).\n- THE system SHALL ensure that deleting a user will permanently remove all their Todos.\n\n### 9. Out of Scope (to guarantee minimalism)\n- THE system SHALL NOT provide label, category, priority, or deadline fields for Todos.\n- THE system SHALL NOT support recurring Todos, reminders, file attachments, or sharing between users.\n- THE system SHALL NOT allow partial updates except for description and status.\n\n## Acceptance Criteria\n\n1. WHEN a user registers and logs in, they SHALL be able to create, view, edit, complete/incomplete, and delete only their own Todos.\n2. IF a user attempts to access, edit, or delete any Todo they do not own (and are not admin), THEN THE system SHALL prevent the action with an error.\n3. WHERE the user is an admin, THEY SHALL be able to view, edit, and delete any user's Todos system-wide.\n4. WHEN any action fails due to permission, ownership, or input validation, THE system SHALL provide a clear, actionable error message.\n5. WHEN displaying a user's Todos, THE system SHALL always show the most recently created or updated Todos at the top.\n6. WHEN a user deletes their account, all their Todos SHALL be deleted permanently.\n7. THE system SHALL always return own Todos only for standard users and all Todos for admins in list endpoints.\n8. THE system SHALL support at least 1,000 active users and 10,000 total Todos with no decrease in expected response time.\n\n## Non-Functional Requirements\n\n- THE system SHALL provide a response to all Todo CRUD actions within 2 seconds under normal load (up to 10 requests per second).\n- IF the system cannot complete a requested operation due to server error, THEN THE system SHALL notify the user with a generic error message and log the technical details for admin review.\n- THE system SHALL store all user and Todo data securely, accessible only to authenticated users and authorized admins.\n- THE system SHALL log all administrative actions (edit, delete) performed by administrators for audit purposes.\n- THE system SHALL be protected against unauthorized access to Todo and user data by enforcing role and ownership checks at all endpoints.\n\n## Visual Representation: Minimal Todo State Diagram\n\n```mermaid\ngraph LR\n  subgraph \"User Flow\"\n    A[\"Register\"] --> B[\"Login\"]\n    B --> C[\"Create Todo\"]\n    C --> D[\"View Todos\"]\n    D --> E[\"Update/Mark Complete\"]\n    E --> F[\"Delete Todo\"]\n  end\n  subgraph \"Admin Actions\"\n    G[\"Admin View All Todos\"]\n    G --> H[\"Admin Edit/Reassign\"]\n    G --> I[\"Admin Delete Any Todo\"]\n  end\n  F --> J[\"Logout\"]\n  J --> B\n```\n\n# End of document"},{"reason":"To define system-wide business rules, field validation criteria, and any operational constraints that affect backend implementation.","filename":"09-business-rules-validation.md","documentType":"requirement","outline":["Todo Task Rules","Validation Rules","Operational Constraints"],"audience":"backend developers","content":"# Business Rules & Validation Requirements for Minimal Todo List Application\n\n## Introduction\n\nThis document establishes the set of business rules, field validation logic, and operational constraints that define how the minimal Todo list application operates from a business perspective. These requirements are designed to support lean, reliable core functionality, eliminate ambiguity, and enforce minimalism in feature scope and system complexity. All requirements follow the EARS framework for clarity and testability and are strictly limited to only those necessary for basic, single-user Todo functionality, with simple administrator support for user and task management.\n\nFor a comprehensive list of required features, refer to the [Functional Requirements Document](./08-functional-requirements.md). For error and exception management, see the [Error & Exception Handling Document](./10-error-exception-handling.md).\n\n## Todo Task Rules\n\n### Core Task Lifecycle\n- THE system SHALL allow registered users to create, view, update, mark as complete/incomplete, and delete their own Todo tasks.\n- WHERE the user is an administrator, THE system SHALL allow full visibility and management (creation, viewing, updating, completion, deletion) of all users' tasks.\n- THE system SHALL never allow a user to view or modify another user's tasks unless that user is an administrator.\n\n### Task Ownership and Permissions\n- WHEN a registered user creates a task, THE system SHALL assign task ownership to that user.\n- IF a user attempts to act on a task they do not own and is not an administrator, THEN THE system SHALL deny the action and provide an appropriate error response.\n- WHEN an administrator acts on any task, THE system SHALL allow all management actions, overriding task ownership restriction.\n\n### Task State and Status\n- THE system SHALL maintain a binary status for each task: active or completed.\n- WHEN a user marks a task as complete, THE system SHALL record the completion timestamp.\n- WHEN a user un-marks a task as complete, THE system SHALL clear or null the completion timestamp, returning it to active status.\n\n### Task Deletion\n- WHEN a user deletes a task, THE system SHALL permanently remove the task and all its associated data.\n- WHERE the user is an administrator, THE system SHALL allow deletion of any task, including those belonging to other users.\n\n## Validation Rules\n\n### Field-Level Validation for Todos\n\n#### Title\n- THE system SHALL require every Todo task to have a non-empty title upon creation.\n- THE system SHALL trim leading and trailing whitespace from the title before validation and storage.\n- THE system SHALL restrict titles to a maximum of 100 characters after trimming whitespace.\n- IF the title is empty or exceeds 100 characters (after trimming), THEN THE system SHALL reject the request and provide a validation error.\n- THE title field SHALL NOT allow line breaks or special formatting (e.g., Markdown).\n\n#### (Optional) Description\n- THE system SHALL NOT require a description field (as per minimalism principle). If implemented, description SHALL be limited to 500 characters and trimmed of whitespace.\n\n#### Status\n- THE system SHALL store task status as a boolean or enumerated value: \"active\" or \"completed.\"\n- THE system SHALL prohibit invalid status transitions (e.g., marking an already completed task as complete does nothing).\n\n#### Timestamps\n- THE system SHALL automatically manage all creation, update, and completion timestamps. Users SHALL NOT be able to set or edit timestamps manually.\n- All timestamps SHALL be stored in ISO 8601 format, with time zone set to UTC.\n\n#### Task Identifier\n- THE system SHALL assign a unique identifier to each task at the time of creation, ensuring non-duplication per user.\n- THE system SHALL NOT allow manual setting or editing of task identifiers by users.\n\n### Ownership & Permission Validation\n- THE system SHALL verify that any task action (view, edit, delete, mark complete/incomplete) is initiated by the owner or an administrator.\n- IF an ownership or permission violation is attempted, THEN THE system SHALL reject the action with a clear, actionable error message.\n\n## Operational Constraints\n\n### Per-User Task Limits\n- THE system SHALL allow each user to have up to 100 active Todo tasks at any given time.\n- IF an attempt is made to create a new task when the user already has 100 active tasks, THEN THE system SHALL reject the request with a limit-exceeded message.\n- Completed tasks DO NOT count against the 100 active task limit.\n\n### System-Wide Constraints\n- THE system SHALL not provide recurring tasks, priorities, deadlines, reminders, labels/tags, or attachments (minimalism principle).\n- THE system SHALL not expose any additional metadata fields outside of those specified in this document.\n- THE system SHALL operate with stateless, single-user task management per account, with no dependencies or shared task lists unless accessed by an administrator.\n\n### Admin Constraints\n- THE system SHALL allow administrators to view, edit, and delete any user's tasks.\n- Administrators SHALL NOT be subject to the per-user task limit for management actions.\n- Administrators SHALL NOT create tasks \"as\" other users (they may create tasks for themselves or delete/modify existing tasks for any user).\n\n### Concurrency\n- WHILE a user is editing a task, THE system SHALL serialize update actions to avoid data loss or race conditions (i.e., avoid two simultaneous modifications on the same task).\n\n## Edge Cases & Exception Handling\n\n- IF a user or admin attempts to edit or delete a task that does not exist, THEN THE system SHALL return a not-found error message.\n- IF a user attempts to delete a completed task, THEN THE system SHALL execute the deletion (no additional confirmation required beyond standard operation).\n- IF a deletion action removes a user's last remaining task, THEN THE system SHALL permit an empty state (no minimum task requirement).\n- IF invalid input data is submitted (e.g., missing required title, title too long), THEN THE system SHALL reject the request and return all relevant validation error messages.\n- THE system SHALL ensure that all actions are atomic: a failure in validation or storage SHALL NOT result in partial saves or incomplete state changes.\n\n## Mermaid Diagram: High-Level Task Lifecycle\n\n```mermaid\ngraph LR\n    A[\"Task Creation\"] --> B[\"Task (Active)\"]\n    B --> C[\"Mark as Complete\"]\n    C --> D[\"Task (Completed)\"]\n    D --> E[\"Unmark as Complete\"]\n    E --> B\n    B --> F[\"Update Task\"]\n    D --> G[\"Delete Task\"]\n    B --> G\n```\n\n## Compliance and Alignment with Minimalism Principle\n\n- THE system SHALL exclude all non-essential features outside the core list/task flow described above.\n- WHERE an enhancement or extra validation could create confusion or friction in the minimal workflow, THE system SHALL favor simplicity and clarity.\n- THE system SHALL prioritize clear error messaging and predictable outcomes, avoiding hidden states or behaviors.\n\nAll business rules, validations, and constraints specified in this document MUST be adhered to in all backend implementation logic. No additional business features, fields, or validation rules are permitted unless specifically listed in the [Functional Requirements Document](./08-functional-requirements.md) or dictated by legal/compliance requirements."},{"reason":"To set forth, from the user’s perspective, how errors and exceptions will be experienced and handled by the system, including major edge cases.","filename":"10-error-exception-handling.md","documentType":"requirement","outline":["Common User Errors","System Failures","Recovery Strategies","User Messaging"],"audience":"backend developers","content":"# Functional Requirements Specification for Minimal Todo List Application\n\n## Core Functional Requirements\n\n### 1. User Registration and Authentication\n- WHEN a user provides valid registration details (email, password), THE system SHALL create a new user account.\n- WHEN a user provides valid login credentials, THE system SHALL authenticate the user and create a user session.\n- IF login credentials are invalid, THEN THE system SHALL deny access and provide an error message.\n- WHEN a logged-in user requests to log out, THE system SHALL end the user session.\n- THE system SHALL ensure that only authenticated users can access any Todo functions (view, create, update, delete their own Todos).\n\n### 2. Todo Task Creation\n- WHEN an authenticated user submits a new Todo with valid content, THE system SHALL create a new Todo item associated with that user.\n- IF a Todo description is empty or only whitespace, THEN THE system SHALL reject the creation request and provide an error message.\n- THE system SHALL limit the maximum Todo description length to 255 characters. IF description exceeds 255 characters, THEN THE system SHALL reject the creation request with an error message.\n\n### 3. Viewing Todos\n- WHEN an authenticated user requests their Todo list, THE system SHALL provide all their own Todo items, sorted in reverse-chronological order of creation (newest first).\n- WHERE the authenticated user is an administrator, THE system SHALL provide the ability to view all users' Todo lists.\n- THE system SHALL not display any user's Todo to any other non-admin user.\n\n### 4. Editing/Updating Todos\n- WHEN an authenticated user requests to edit a Todo they own, THE system SHALL allow updates to the description and completion status.\n- IF a user attempts to edit a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n- IF the user provides an empty or whitespace-only description during update, THEN THE system SHALL reject the update and provide an error message.\n\n### 5. Marking Todos as Complete or Incomplete\n- WHEN the user changes a Todo's completion status, THE system SHALL update the status accordingly for that Todo.\n- THE system SHALL track a boolean completion status (complete/incomplete) for each Todo item.\n\n### 6. Deleting Todos\n- WHEN a user requests to delete their own Todo, THE system SHALL remove that Todo from their list.\n- IF a user attempts to delete a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n\n### 7. Administrative Functions\n- WHERE the acting user has the admin role, THE system SHALL permit administration of any user’s Todos, including view, edit, and delete actions.\n- WHEN an admin deletes or edits a Todo, THE system SHALL record that the action was performed by an administrator.\n\n### 8. Data Integrity\n- THE system SHALL enforce that each Todo is always associated with exactly one user (owner).\n- THE system SHALL ensure that deleting a user will permanently remove all their Todos.\n\n### 9. Out of Scope (to guarantee minimalism)\n- THE system SHALL NOT provide label, category, priority, or deadline fields for Todos.\n- THE system SHALL NOT support recurring Todos, reminders, file attachments, or sharing between users.\n- THE system SHALL NOT allow partial updates except for description and status.\n\n## Acceptance Criteria\n\n1. WHEN a user registers and logs in, they SHALL be able to create, view, edit, complete/incomplete, and delete only their own Todos.\n2. IF a user attempts to access, edit, or delete any Todo they do not own (and are not admin), THEN THE system SHALL prevent the action with an error.\n3. WHERE the user is an admin, THEY SHALL be able to view, edit, and delete any user's Todos system-wide.\n4. WHEN any action fails due to permission, ownership, or input validation, THE system SHALL provide a clear, actionable error message.\n5. WHEN displaying a user's Todos, THE system SHALL always show the most recently created or updated Todos at the top.\n6. WHEN a user deletes their account, all their Todos SHALL be deleted permanently.\n7. THE system SHALL always return own Todos only for standard users and all Todos for admins in list endpoints.\n8. THE system SHALL support at least 1,000 active users and 10,000 total Todos with no decrease in expected response time.\n\n## Non-Functional Requirements\n\n- THE system SHALL provide a response to all Todo CRUD actions within 2 seconds under normal load (up to 10 requests per second).\n- IF the system cannot complete a requested operation due to server error, THEN THE system SHALL notify the user with a generic error message and log the technical details for admin review.\n- THE system SHALL store all user and Todo data securely, accessible only to authenticated users and authorized admins.\n- THE system SHALL log all administrative actions (edit, delete) performed by administrators for audit purposes.\n- THE system SHALL be protected against unauthorized access to Todo and user data by enforcing role and ownership checks at all endpoints.\n\n## Visual Representation: Minimal Todo State Diagram\n\n```mermaid\ngraph LR\n  subgraph \"User Flow\"\n    A[\"Register\"] --> B[\"Login\"]\n    B --> C[\"Create Todo\"]\n    C --> D[\"View Todos\"]\n    D --> E[\"Update/Mark Complete\"]\n    E --> F[\"Delete Todo\"]\n  end\n  subgraph \"Admin Actions\"\n    G[\"Admin View All Todos\"]\n    G --> H[\"Admin Edit/Reassign\"]\n    G --> I[\"Admin Delete Any Todo\"]\n  end\n  F --> J[\"Logout\"]\n  J --> B\n```\n\n# End of document"},{"reason":"To articulate, from a business perspective, the privacy, security, and performance expectations end users will have for the minimal Todo list service.","filename":"11-security-privacy-performance.md","documentType":"requirement","outline":["Security & Privacy Requirements","Performance Expectations","Compliance Notes"],"audience":"backend developers","content":"# Functional Requirements Specification for Minimal Todo List Application\n\n## Core Functional Requirements\n\n### 1. User Registration and Authentication\n- WHEN a user provides valid registration details (email, password), THE system SHALL create a new user account.\n- WHEN a user provides valid login credentials, THE system SHALL authenticate the user and create a user session.\n- IF login credentials are invalid, THEN THE system SHALL deny access and provide an error message.\n- WHEN a logged-in user requests to log out, THE system SHALL end the user session.\n- THE system SHALL ensure that only authenticated users can access any Todo functions (view, create, update, delete their own Todos).\n\n### 2. Todo Task Creation\n- WHEN an authenticated user submits a new Todo with valid content, THE system SHALL create a new Todo item associated with that user.\n- IF a Todo description is empty or only whitespace, THEN THE system SHALL reject the creation request and provide an error message.\n- THE system SHALL limit the maximum Todo description length to 255 characters. IF description exceeds 255 characters, THEN THE system SHALL reject the creation request with an error message.\n\n### 3. Viewing Todos\n- WHEN an authenticated user requests their Todo list, THE system SHALL provide all their own Todo items, sorted in reverse-chronological order of creation (newest first).\n- WHERE the authenticated user is an administrator, THE system SHALL provide the ability to view all users' Todo lists.\n- THE system SHALL not display any user's Todo to any other non-admin user.\n\n### 4. Editing/Updating Todos\n- WHEN an authenticated user requests to edit a Todo they own, THE system SHALL allow updates to the description and completion status.\n- IF a user attempts to edit a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n- IF the user provides an empty or whitespace-only description during update, THEN THE system SHALL reject the update and provide an error message.\n\n### 5. Marking Todos as Complete or Incomplete\n- WHEN the user changes a Todo's completion status, THE system SHALL update the status accordingly for that Todo.\n- THE system SHALL track a boolean completion status (complete/incomplete) for each Todo item.\n\n### 6. Deleting Todos\n- WHEN a user requests to delete their own Todo, THE system SHALL remove that Todo from their list.\n- IF a user attempts to delete a Todo they do not own and is not an administrator, THEN THE system SHALL reject the request with an error message.\n\n### 7. Administrative Functions\n- WHERE the acting user has the admin role, THE system SHALL permit administration of any user’s Todos, including view, edit, and delete actions.\n- WHEN an admin deletes or edits a Todo, THE system SHALL record that the action was performed by an administrator.\n\n### 8. Data Integrity\n- THE system SHALL enforce that each Todo is always associated with exactly one user (owner).\n- THE system SHALL ensure that deleting a user will permanently remove all their Todos.\n\n### 9. Out of Scope (to guarantee minimalism)\n- THE system SHALL NOT provide label, category, priority, or deadline fields for Todos.\n- THE system SHALL NOT support recurring Todos, reminders, file attachments, or sharing between users.\n- THE system SHALL NOT allow partial updates except for description and status.\n\n## Acceptance Criteria\n\n1. WHEN a user registers and logs in, they SHALL be able to create, view, edit, complete/incomplete, and delete only their own Todos.\n2. IF a user attempts to access, edit, or delete any Todo they do not own (and are not admin), THEN THE system SHALL prevent the action with an error.\n3. WHERE the user is an admin, THEY SHALL be able to view, edit, and delete any user's Todos system-wide.\n4. WHEN any action fails due to permission, ownership, or input validation, THE system SHALL provide a clear, actionable error message.\n5. WHEN displaying a user's Todos, THE system SHALL always show the most recently created or updated Todos at the top.\n6. WHEN a user deletes their account, all their Todos SHALL be deleted permanently.\n7. THE system SHALL always return own Todos only for standard users and all Todos for admins in list endpoints.\n8. THE system SHALL support at least 1,000 active users and 10,000 total Todos with no decrease in expected response time.\n\n## Non-Functional Requirements\n\n- THE system SHALL provide a response to all Todo CRUD actions within 2 seconds under normal load (up to 10 requests per second).\n- IF the system cannot complete a requested operation due to server error, THEN THE system SHALL notify the user with a generic error message and log the technical details for admin review.\n- THE system SHALL store all user and Todo data securely, accessible only to authenticated users and authorized admins.\n- THE system SHALL log all administrative actions (edit, delete) performed by administrators for audit purposes.\n- THE system SHALL be protected against unauthorized access to Todo and user data by enforcing role and ownership checks at all endpoints.\n\n## Visual Representation: Minimal Todo State Diagram\n\n```mermaid\ngraph LR\n  subgraph \"User Flow\"\n    A[\"Register\"] --> B[\"Login\"]\n    B --> C[\"Create Todo\"]\n    C --> D[\"View Todos\"]\n    D --> E[\"Update/Mark Complete\"]\n    E --> F[\"Delete Todo\"]\n  end\n  subgraph \"Admin Actions\"\n    G[\"Admin View All Todos\"]\n    G --> H[\"Admin Edit/Reassign\"]\n    G --> I[\"Admin Delete Any Todo\"]\n  end\n  F --> J[\"Logout\"]\n  J --> B\n```\n\n# End of document"}],"created_at":"2025-09-30T15:41:16.679Z","completed_at":"2025-09-30T15:48:59.170Z","step":0},{"id":"01999b50-0f18-752d-88c4-54191971268b","type":"userMessage","contents":[{"type":"text","text":"Design the database schema."}],"created_at":"2025-09-30T15:48:59.288Z"},{"type":"prisma","id":"01999b53-6b71-7569-82da-a4129b767a74","instruction":"Design a minimal Todo list database schema focused only on essential functionality. Include only the basic data model required for a Todo item—such as title, completion status, creation date, and optionally a description. No extra features, relations, or fields unless strictly necessary for the simplest Todo list usage.","schemas":{"schema-01-actors.prisma":"/// Registered end-user accounts for the minimal Todo app. Each record\n/// represents a single user allowed to log in, manage only their own todos,\n/// and perform all personal account actions. Emails are unique per table,\n/// and password security is enforced via password_hash field. No admin\n/// permissions given. Creation and update timestamps are included for audit\n/// and compliance. Does not reference todo_list_todos here (reverse\n/// reference handled in todo table).\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// User's unique email address for login and identification. Must be unique\n  /// within this table.\n  email String\n  \n  /// User password (hashed, never stored in plain text). Required for secure\n  /// authentication.\n  password_hash String\n  \n  /// Timestamp when the user account was created (ISO 8601, UTC).\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the user account was last updated (ISO 8601, UTC).\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  todo_list_todos todo_list_todos[]\n  \n  @@unique([email])\n  @@index([created_at])\n}\n\n/// Administrator accounts for system-wide management of users and todos.\n/// Records here represent authorized admins with full privileges to view,\n/// edit, or delete any todo or user account. Admins log in using a unique\n/// email and their password (hashed). No user role overlap—admins are not\n/// standard users. Minimal fields for authentication and audit. No direct\n/// relation to user or todo tables. Deleted when account is removed (no soft\n/// delete).\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_admins {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Admin's unique email address for login. Must be unique within this table\n  /// only.\n  email String\n  \n  /// Admin password hash, required for secure login.\n  password_hash String\n  \n  /// Admin account creation timestamp.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp of last modification to this admin account.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  @@unique([email])\n  @@index([created_at])\n}","schema-02-todos.prisma":"/// Todo list items representing individual user tasks in the minimal Todo\n/// application. Each todo is strictly owned by a single user via the {@link\n/// todo_list_users.id} foreign key. The table stores only essential fields:\n/// task title, completion status, timestamps for creation/update/completion,\n/// and optional soft delete flag (for future extensibility). No labels,\n/// priorities, deadlines, or attachments are included, adhering to strict\n/// minimalism. Admin users may manage all todos via permissions, not via\n/// extra fields.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_todos {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged user's {@link todo_list_users.id}. Enforces ownership and\n  /// enables cascading deletes when user is removed.\n  todo_list_user_id String @db.Uuid\n  \n  /// Todo item label/title. Must be non-empty and max 100 characters, trimmed.\n  /// (Validated in service logic, enforced at application layer.)\n  title String\n  \n  /// Whether the todo item is marked as completed (true) or still active\n  /// (false).\n  is_completed Boolean\n  \n  /// Timestamp when the todo item was created. Used for sort and audit.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp for most recent modification (description, status change, etc.).\n  updated_at DateTime @db.Timestamptz\n  \n  /// If completed, timestamp at which the task was marked as done; set to null\n  /// if not completed.\n  completed_at DateTime? @db.Timestamptz\n  \n  /// Soft delete timestamp; if present, item is considered logically deleted\n  /// but not removed from database. Enables future extensibility for\n  /// audit/recovery.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user todo_list_users @relation(fields: [todo_list_user_id], references: [id], onDelete: Cascade)\n  \n  @@index([todo_list_user_id, is_completed])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-actors.prisma","namespace":"Actors","models":[{"name":"todo_list_users","description":"Registered end-user accounts for the minimal Todo app. Each record represents a single user allowed to log in, manage only their own todos, and perform all personal account actions. Emails are unique per table, and password security is enforced via password_hash field. No admin permissions given. Creation and update timestamps are included for audit and compliance. Does not reference todo_list_todos here (reverse reference handled in todo table).","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"User's unique email address for login and identification. Must be unique within this table.","nullable":false},{"name":"password_hash","type":"string","description":"User password (hashed, never stored in plain text). Required for secure authentication.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the user account was created (ISO 8601, UTC).","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the user account was last updated (ISO 8601, UTC).","nullable":false}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"todo_list_admins","description":"Administrator accounts for system-wide management of users and todos. Records here represent authorized admins with full privileges to view, edit, or delete any todo or user account. Admins log in using a unique email and their password (hashed). No user role overlap—admins are not standard users. Minimal fields for authentication and audit. No direct relation to user or todo tables. Deleted when account is removed (no soft delete).","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Admin's unique email address for login. Must be unique within this table only.","nullable":false},{"name":"password_hash","type":"string","description":"Admin password hash, required for secure login.","nullable":false},{"name":"created_at","type":"datetime","description":"Admin account creation timestamp.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp of last modification to this admin account.","nullable":false}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]}]},{"filename":"schema-02-todos.prisma","namespace":"Todos","models":[{"name":"todo_list_todos","description":"Todo list items representing individual user tasks in the minimal Todo application. Each todo is strictly owned by a single user via the {@link todo_list_users.id} foreign key. The table stores only essential fields: task title, completion status, timestamps for creation/update/completion, and optional soft delete flag (for future extensibility). No labels, priorities, deadlines, or attachments are included, adhering to strict minimalism. Admin users may manage all todos via permissions, not via extra fields.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"todo_list_user_id","type":"uuid","description":"Belonged user's {@link todo_list_users.id}. Enforces ownership and enables cascading deletes when user is removed.","relation":{"name":"user","targetModel":"todo_list_users"},"unique":false,"nullable":false}],"plainFields":[{"name":"title","type":"string","description":"Todo item label/title. Must be non-empty and max 100 characters, trimmed. (Validated in service logic, enforced at application layer.)","nullable":false},{"name":"is_completed","type":"boolean","description":"Whether the todo item is marked as completed (true) or still active (false).","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the todo item was created. Used for sort and audit.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp for most recent modification (description, status change, etc.).","nullable":false},{"name":"completed_at","type":"datetime","description":"If completed, timestamp at which the task was marked as done; set to null if not completed.","nullable":true},{"name":"deleted_at","type":"datetime","description":"Soft delete timestamp; if present, item is considered logically deleted but not removed from database. Enables future extensibility for audit/recovery.","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["todo_list_user_id","is_completed"]}],"ginIndexes":[{"fieldName":"title"}]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-actors.prisma":"/// Registered end-user accounts for the minimal Todo app. Each record\n/// represents a single user allowed to log in, manage only their own todos,\n/// and perform all personal account actions. Emails are unique per table,\n/// and password security is enforced via password_hash field. No admin\n/// permissions given. Creation and update timestamps are included for audit\n/// and compliance. Does not reference todo_list_todos here (reverse\n/// reference handled in todo table).\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// User's unique email address for login and identification. Must be unique\n  /// within this table.\n  email String\n\n  /// User password (hashed, never stored in plain text). Required for secure\n  /// authentication.\n  password_hash String\n\n  /// Timestamp when the user account was created (ISO 8601, UTC).\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the user account was last updated (ISO 8601, UTC).\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  todo_list_todos todo_list_todos[]\n\n  @@unique([email])\n  @@index([created_at])\n}\n\n/// Administrator accounts for system-wide management of users and todos.\n/// Records here represent authorized admins with full privileges to view,\n/// edit, or delete any todo or user account. Admins log in using a unique\n/// email and their password (hashed). No user role overlap—admins are not\n/// standard users. Minimal fields for authentication and audit. No direct\n/// relation to user or todo tables. Deleted when account is removed (no soft\n/// delete).\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_admins {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Admin's unique email address for login. Must be unique within this table\n  /// only.\n  email String\n\n  /// Admin password hash, required for secure login.\n  password_hash String\n\n  /// Admin account creation timestamp.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp of last modification to this admin account.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  @@unique([email])\n  @@index([created_at])\n}\n","schema-02-todos.prisma":"/// Todo list items representing individual user tasks in the minimal Todo\n/// application. Each todo is strictly owned by a single user via the {@link\n/// todo_list_users.id} foreign key. The table stores only essential fields:\n/// task title, completion status, timestamps for creation/update/completion,\n/// and optional soft delete flag (for future extensibility). No labels,\n/// priorities, deadlines, or attachments are included, adhering to strict\n/// minimalism. Admin users may manage all todos via permissions, not via\n/// extra fields.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_todos {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged user's {@link todo_list_users.id}. Enforces ownership and\n  /// enables cascading deletes when user is removed.\n  todo_list_user_id String @db.Uuid\n\n  /// Todo item label/title. Must be non-empty and max 100 characters, trimmed.\n  /// (Validated in service logic, enforced at application layer.)\n  title String\n\n  /// Whether the todo item is marked as completed (true) or still active\n  /// (false).\n  is_completed Boolean\n\n  /// Timestamp when the todo item was created. Used for sort and audit.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp for most recent modification (description, status change, etc.).\n  updated_at DateTime @db.Timestamptz\n\n  /// If completed, timestamp at which the task was marked as done; set to null\n  /// if not completed.\n  completed_at DateTime? @db.Timestamptz\n\n  /// Soft delete timestamp; if present, item is considered logically deleted\n  /// but not removed from database. Enables future extensibility for\n  /// audit/recovery.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user todo_list_users @relation(fields: [todo_list_user_id], references: [id], onDelete: Cascade)\n\n  @@index([todo_list_user_id, is_completed])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/client.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model todo_list_users\n * Registered end-user accounts for the minimal Todo app. Each record\n * represents a single user allowed to log in, manage only their own todos,\n * and perform all personal account actions. Emails are unique per table,\n * and password security is enforced via password_hash field. No admin\n * permissions given. Creation and update timestamps are included for audit\n * and compliance. Does not reference todo_list_todos here (reverse\n * reference handled in todo table).\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_users = $Result.DefaultSelection<Prisma.$todo_list_usersPayload>\n/**\n * Model todo_list_admins\n * Administrator accounts for system-wide management of users and todos.\n * Records here represent authorized admins with full privileges to view,\n * edit, or delete any todo or user account. Admins log in using a unique\n * email and their password (hashed). No user role overlap—admins are not\n * standard users. Minimal fields for authentication and audit. No direct\n * relation to user or todo tables. Deleted when account is removed (no soft\n * delete).\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_admins = $Result.DefaultSelection<Prisma.$todo_list_adminsPayload>\n/**\n * Model todo_list_todos\n * Todo list items representing individual user tasks in the minimal Todo\n * application. Each todo is strictly owned by a single user via the {@link\n * todo_list_users.id} foreign key. The table stores only essential fields:\n * task title, completion status, timestamps for creation/update/completion,\n * and optional soft delete flag (for future extensibility). No labels,\n * priorities, deadlines, or attachments are included, adhering to strict\n * minimalism. Admin users may manage all todos via permissions, not via\n * extra fields.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_todos = $Result.DefaultSelection<Prisma.$todo_list_todosPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Todo_list_users\n * const todo_list_users = await prisma.todo_list_users.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Todo_list_users\n   * const todo_list_users = await prisma.todo_list_users.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.todo_list_users`: Exposes CRUD operations for the **todo_list_users** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_users\n    * const todo_list_users = await prisma.todo_list_users.findMany()\n    * ```\n    */\n  get todo_list_users(): Prisma.todo_list_usersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_list_admins`: Exposes CRUD operations for the **todo_list_admins** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_admins\n    * const todo_list_admins = await prisma.todo_list_admins.findMany()\n    * ```\n    */\n  get todo_list_admins(): Prisma.todo_list_adminsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_list_todos`: Exposes CRUD operations for the **todo_list_todos** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_todos\n    * const todo_list_todos = await prisma.todo_list_todos.findMany()\n    * ```\n    */\n  get todo_list_todos(): Prisma.todo_list_todosDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    todo_list_users: 'todo_list_users',\n    todo_list_admins: 'todo_list_admins',\n    todo_list_todos: 'todo_list_todos'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"todo_list_users\" | \"todo_list_admins\" | \"todo_list_todos\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      todo_list_users: {\n        payload: Prisma.$todo_list_usersPayload<ExtArgs>\n        fields: Prisma.todo_list_usersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_usersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_usersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_usersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_usersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_usersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_usersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_usersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_usersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_usersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          update: {\n            args: Prisma.todo_list_usersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_usersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_usersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_usersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_usersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_usersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_users>\n          }\n          groupBy: {\n            args: Prisma.todo_list_usersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_usersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_usersCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_usersCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_list_admins: {\n        payload: Prisma.$todo_list_adminsPayload<ExtArgs>\n        fields: Prisma.todo_list_adminsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_adminsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_adminsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_adminsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_adminsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_adminsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_adminsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_adminsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_adminsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_adminsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          update: {\n            args: Prisma.todo_list_adminsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_adminsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_adminsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_adminsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_adminsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_adminsPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_adminsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_admins>\n          }\n          groupBy: {\n            args: Prisma.todo_list_adminsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_adminsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_adminsCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_adminsCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_list_todos: {\n        payload: Prisma.$todo_list_todosPayload<ExtArgs>\n        fields: Prisma.todo_list_todosFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_todosFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_todosFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_todosFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_todosFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_todosFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_todosCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_todosCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_todosCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_todosDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          update: {\n            args: Prisma.todo_list_todosUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_todosDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_todosUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_todosUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_todosUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_todosAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_todos>\n          }\n          groupBy: {\n            args: Prisma.todo_list_todosGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_todosGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_todosCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_todosCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`\n     */\n    adapter?: runtime.SqlDriverAdapterFactory | null\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    todo_list_users?: todo_list_usersOmit\n    todo_list_admins?: todo_list_adminsOmit\n    todo_list_todos?: todo_list_todosOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Todo_list_usersCountOutputType\n   */\n\n  export type Todo_list_usersCountOutputType = {\n    todo_list_todos: number\n  }\n\n  export type Todo_list_usersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_todos?: boolean | Todo_list_usersCountOutputTypeCountTodo_list_todosArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_list_usersCountOutputType without action\n   */\n  export type Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_list_usersCountOutputType\n     */\n    select?: Todo_list_usersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_list_usersCountOutputType without action\n   */\n  export type Todo_list_usersCountOutputTypeCountTodo_list_todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_todosWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model todo_list_users\n   */\n\n  export type AggregateTodo_list_users = {\n    _count: Todo_list_usersCountAggregateOutputType | null\n    _min: Todo_list_usersMinAggregateOutputType | null\n    _max: Todo_list_usersMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_usersMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Todo_list_usersMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Todo_list_usersCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_usersMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Todo_list_usersMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Todo_list_usersCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_users to aggregate.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_users\n    **/\n    _count?: true | Todo_list_usersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_usersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_usersMaxAggregateInputType\n  }\n\n  export type GetTodo_list_usersAggregateType<T extends Todo_list_usersAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_users]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_users[P]>\n      : GetScalarType<T[P], AggregateTodo_list_users[P]>\n  }\n\n\n\n\n  export type todo_list_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_usersWhereInput\n    orderBy?: todo_list_usersOrderByWithAggregationInput | todo_list_usersOrderByWithAggregationInput[]\n    by: Todo_list_usersScalarFieldEnum[] | Todo_list_usersScalarFieldEnum\n    having?: todo_list_usersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_usersCountAggregateInputType | true\n    _min?: Todo_list_usersMinAggregateInputType\n    _max?: Todo_list_usersMaxAggregateInputType\n  }\n\n  export type Todo_list_usersGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date\n    updated_at: Date\n    _count: Todo_list_usersCountAggregateOutputType | null\n    _min: Todo_list_usersMinAggregateOutputType | null\n    _max: Todo_list_usersMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_usersGroupByPayload<T extends todo_list_usersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_usersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_usersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_usersGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_usersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    todo_list_todos?: boolean | todo_list_users$todo_list_todosArgs<ExtArgs>\n    _count?: boolean | Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type todo_list_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"todo_list_users\"]>\n  export type todo_list_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_todos?: boolean | todo_list_users$todo_list_todosArgs<ExtArgs>\n    _count?: boolean | Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_list_usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type todo_list_usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $todo_list_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_users\"\n    objects: {\n      todo_list_todos: Prisma.$todo_list_todosPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * User's unique email address for login and identification. Must be unique\n       * within this table.\n       */\n      email: string\n      /**\n       * User password (hashed, never stored in plain text). Required for secure\n       * authentication.\n       */\n      password_hash: string\n      /**\n       * Timestamp when the user account was created (ISO 8601, UTC).\n       */\n      created_at: Date\n      /**\n       * Timestamp when the user account was last updated (ISO 8601, UTC).\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"todo_list_users\"]>\n    composites: {}\n  }\n\n  type todo_list_usersGetPayload<S extends boolean | null | undefined | todo_list_usersDefaultArgs> = $Result.GetResult<Prisma.$todo_list_usersPayload, S>\n\n  type todo_list_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_usersCountAggregateInputType | true\n    }\n\n  export interface todo_list_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_users'], meta: { name: 'todo_list_users' } }\n    /**\n     * Find zero or one Todo_list_users that matches the filter.\n     * @param {todo_list_usersFindUniqueArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_usersFindUniqueArgs>(args: SelectSubset<T, todo_list_usersFindUniqueArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_users that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_usersFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindFirstArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_usersFindFirstArgs>(args?: SelectSubset<T, todo_list_usersFindFirstArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_users that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindFirstOrThrowArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findMany()\n     * \n     * // Get first 10 Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_usersFindManyArgs>(args?: SelectSubset<T, todo_list_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_users.\n     * @param {todo_list_usersCreateArgs} args - Arguments to create a Todo_list_users.\n     * @example\n     * // Create one Todo_list_users\n     * const Todo_list_users = await prisma.todo_list_users.create({\n     *   data: {\n     *     // ... data to create a Todo_list_users\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_usersCreateArgs>(args: SelectSubset<T, todo_list_usersCreateArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_users.\n     * @param {todo_list_usersCreateManyArgs} args - Arguments to create many Todo_list_users.\n     * @example\n     * // Create many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_usersCreateManyArgs>(args?: SelectSubset<T, todo_list_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_users and returns the data saved in the database.\n     * @param {todo_list_usersCreateManyAndReturnArgs} args - Arguments to create many Todo_list_users.\n     * @example\n     * // Create many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_users and only return the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_users.\n     * @param {todo_list_usersDeleteArgs} args - Arguments to delete one Todo_list_users.\n     * @example\n     * // Delete one Todo_list_users\n     * const Todo_list_users = await prisma.todo_list_users.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_users\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_usersDeleteArgs>(args: SelectSubset<T, todo_list_usersDeleteArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_users.\n     * @param {todo_list_usersUpdateArgs} args - Arguments to update one Todo_list_users.\n     * @example\n     * // Update one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_usersUpdateArgs>(args: SelectSubset<T, todo_list_usersUpdateArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_users.\n     * @param {todo_list_usersDeleteManyArgs} args - Arguments to filter Todo_list_users to delete.\n     * @example\n     * // Delete a few Todo_list_users\n     * const { count } = await prisma.todo_list_users.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_usersDeleteManyArgs>(args?: SelectSubset<T, todo_list_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_usersUpdateManyArgs>(args: SelectSubset<T, todo_list_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_users and returns the data updated in the database.\n     * @param {todo_list_usersUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_users.\n     * @example\n     * // Update many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_users and only return the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_users.\n     * @param {todo_list_usersUpsertArgs} args - Arguments to update or create a Todo_list_users.\n     * @example\n     * // Update or create a Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_users\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_users we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_usersUpsertArgs>(args: SelectSubset<T, todo_list_usersUpsertArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersCountArgs} args - Arguments to filter Todo_list_users to count.\n     * @example\n     * // Count the number of Todo_list_users\n     * const count = await prisma.todo_list_users.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_users we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_usersCountArgs>(\n      args?: Subset<T, todo_list_usersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_usersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_usersAggregateArgs>(args: Subset<T, Todo_list_usersAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_usersAggregateType<T>>\n\n    /**\n     * Group by Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_usersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_usersGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_usersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_users model\n   */\n  readonly fields: todo_list_usersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_users.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    todo_list_todos<T extends todo_list_users$todo_list_todosArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_users$todo_list_todosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_users model\n   */\n  interface todo_list_usersFieldRefs {\n    readonly id: FieldRef<\"todo_list_users\", 'String'>\n    readonly email: FieldRef<\"todo_list_users\", 'String'>\n    readonly password_hash: FieldRef<\"todo_list_users\", 'String'>\n    readonly created_at: FieldRef<\"todo_list_users\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_users\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_users findUnique\n   */\n  export type todo_list_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users findUniqueOrThrow\n   */\n  export type todo_list_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users findFirst\n   */\n  export type todo_list_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_users.\n     */\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users findFirstOrThrow\n   */\n  export type todo_list_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_users.\n     */\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users findMany\n   */\n  export type todo_list_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users create\n   */\n  export type todo_list_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_users.\n     */\n    data: XOR<todo_list_usersCreateInput, todo_list_usersUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_users createMany\n   */\n  export type todo_list_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_users.\n     */\n    data: todo_list_usersCreateManyInput | todo_list_usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_users createManyAndReturn\n   */\n  export type todo_list_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_users.\n     */\n    data: todo_list_usersCreateManyInput | todo_list_usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_users update\n   */\n  export type todo_list_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateInput, todo_list_usersUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_users to update.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users updateMany\n   */\n  export type todo_list_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateManyMutationInput, todo_list_usersUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_users to update\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users updateManyAndReturn\n   */\n  export type todo_list_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateManyMutationInput, todo_list_usersUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_users to update\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users upsert\n   */\n  export type todo_list_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_users to update in case it exists.\n     */\n    where: todo_list_usersWhereUniqueInput\n    /**\n     * In case the todo_list_users found by the `where` argument doesn't exist, create a new todo_list_users with this data.\n     */\n    create: XOR<todo_list_usersCreateInput, todo_list_usersUncheckedCreateInput>\n    /**\n     * In case the todo_list_users was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_usersUpdateInput, todo_list_usersUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_users delete\n   */\n  export type todo_list_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_users to delete.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users deleteMany\n   */\n  export type todo_list_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_users to delete\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users.todo_list_todos\n   */\n  export type todo_list_users$todo_list_todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    where?: todo_list_todosWhereInput\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    cursor?: todo_list_todosWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users without action\n   */\n  export type todo_list_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_list_admins\n   */\n\n  export type AggregateTodo_list_admins = {\n    _count: Todo_list_adminsCountAggregateOutputType | null\n    _min: Todo_list_adminsMinAggregateOutputType | null\n    _max: Todo_list_adminsMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_adminsMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Todo_list_adminsMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Todo_list_adminsCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_adminsMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Todo_list_adminsMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Todo_list_adminsCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_adminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_admins to aggregate.\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_admins to fetch.\n     */\n    orderBy?: todo_list_adminsOrderByWithRelationInput | todo_list_adminsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_adminsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_admins\n    **/\n    _count?: true | Todo_list_adminsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_adminsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_adminsMaxAggregateInputType\n  }\n\n  export type GetTodo_list_adminsAggregateType<T extends Todo_list_adminsAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_admins]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_admins[P]>\n      : GetScalarType<T[P], AggregateTodo_list_admins[P]>\n  }\n\n\n\n\n  export type todo_list_adminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_adminsWhereInput\n    orderBy?: todo_list_adminsOrderByWithAggregationInput | todo_list_adminsOrderByWithAggregationInput[]\n    by: Todo_list_adminsScalarFieldEnum[] | Todo_list_adminsScalarFieldEnum\n    having?: todo_list_adminsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_adminsCountAggregateInputType | true\n    _min?: Todo_list_adminsMinAggregateInputType\n    _max?: Todo_list_adminsMaxAggregateInputType\n  }\n\n  export type Todo_list_adminsGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date\n    updated_at: Date\n    _count: Todo_list_adminsCountAggregateOutputType | null\n    _min: Todo_list_adminsMinAggregateOutputType | null\n    _max: Todo_list_adminsMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_adminsGroupByPayload<T extends todo_list_adminsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_adminsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_adminsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_adminsGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_adminsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_adminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_admins\"]>\n\n  export type todo_list_adminsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_admins\"]>\n\n  export type todo_list_adminsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_admins\"]>\n\n  export type todo_list_adminsSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type todo_list_adminsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"todo_list_admins\"]>\n\n  export type $todo_list_adminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_admins\"\n    objects: {}\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Admin's unique email address for login. Must be unique within this table\n       * only.\n       */\n      email: string\n      /**\n       * Admin password hash, required for secure login.\n       */\n      password_hash: string\n      /**\n       * Admin account creation timestamp.\n       */\n      created_at: Date\n      /**\n       * Timestamp of last modification to this admin account.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"todo_list_admins\"]>\n    composites: {}\n  }\n\n  type todo_list_adminsGetPayload<S extends boolean | null | undefined | todo_list_adminsDefaultArgs> = $Result.GetResult<Prisma.$todo_list_adminsPayload, S>\n\n  type todo_list_adminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_adminsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_adminsCountAggregateInputType | true\n    }\n\n  export interface todo_list_adminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_admins'], meta: { name: 'todo_list_admins' } }\n    /**\n     * Find zero or one Todo_list_admins that matches the filter.\n     * @param {todo_list_adminsFindUniqueArgs} args - Arguments to find a Todo_list_admins\n     * @example\n     * // Get one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_adminsFindUniqueArgs>(args: SelectSubset<T, todo_list_adminsFindUniqueArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_admins that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_adminsFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_admins\n     * @example\n     * // Get one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_adminsFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_adminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_admins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsFindFirstArgs} args - Arguments to find a Todo_list_admins\n     * @example\n     * // Get one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_adminsFindFirstArgs>(args?: SelectSubset<T, todo_list_adminsFindFirstArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_admins that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsFindFirstOrThrowArgs} args - Arguments to find a Todo_list_admins\n     * @example\n     * // Get one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_adminsFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_adminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_admins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findMany()\n     * \n     * // Get first 10 Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_adminsWithIdOnly = await prisma.todo_list_admins.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_adminsFindManyArgs>(args?: SelectSubset<T, todo_list_adminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_admins.\n     * @param {todo_list_adminsCreateArgs} args - Arguments to create a Todo_list_admins.\n     * @example\n     * // Create one Todo_list_admins\n     * const Todo_list_admins = await prisma.todo_list_admins.create({\n     *   data: {\n     *     // ... data to create a Todo_list_admins\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_adminsCreateArgs>(args: SelectSubset<T, todo_list_adminsCreateArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_admins.\n     * @param {todo_list_adminsCreateManyArgs} args - Arguments to create many Todo_list_admins.\n     * @example\n     * // Create many Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_adminsCreateManyArgs>(args?: SelectSubset<T, todo_list_adminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_admins and returns the data saved in the database.\n     * @param {todo_list_adminsCreateManyAndReturnArgs} args - Arguments to create many Todo_list_admins.\n     * @example\n     * // Create many Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_admins and only return the `id`\n     * const todo_list_adminsWithIdOnly = await prisma.todo_list_admins.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_adminsCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_adminsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_admins.\n     * @param {todo_list_adminsDeleteArgs} args - Arguments to delete one Todo_list_admins.\n     * @example\n     * // Delete one Todo_list_admins\n     * const Todo_list_admins = await prisma.todo_list_admins.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_admins\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_adminsDeleteArgs>(args: SelectSubset<T, todo_list_adminsDeleteArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_admins.\n     * @param {todo_list_adminsUpdateArgs} args - Arguments to update one Todo_list_admins.\n     * @example\n     * // Update one Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_adminsUpdateArgs>(args: SelectSubset<T, todo_list_adminsUpdateArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_admins.\n     * @param {todo_list_adminsDeleteManyArgs} args - Arguments to filter Todo_list_admins to delete.\n     * @example\n     * // Delete a few Todo_list_admins\n     * const { count } = await prisma.todo_list_admins.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_adminsDeleteManyArgs>(args?: SelectSubset<T, todo_list_adminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_adminsUpdateManyArgs>(args: SelectSubset<T, todo_list_adminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_admins and returns the data updated in the database.\n     * @param {todo_list_adminsUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_admins.\n     * @example\n     * // Update many Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_admins and only return the `id`\n     * const todo_list_adminsWithIdOnly = await prisma.todo_list_admins.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_adminsUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_adminsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_admins.\n     * @param {todo_list_adminsUpsertArgs} args - Arguments to update or create a Todo_list_admins.\n     * @example\n     * // Update or create a Todo_list_admins\n     * const todo_list_admins = await prisma.todo_list_admins.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_admins\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_admins we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_adminsUpsertArgs>(args: SelectSubset<T, todo_list_adminsUpsertArgs<ExtArgs>>): Prisma__todo_list_adminsClient<$Result.GetResult<Prisma.$todo_list_adminsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsCountArgs} args - Arguments to filter Todo_list_admins to count.\n     * @example\n     * // Count the number of Todo_list_admins\n     * const count = await prisma.todo_list_admins.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_admins we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_adminsCountArgs>(\n      args?: Subset<T, todo_list_adminsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_adminsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_adminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_adminsAggregateArgs>(args: Subset<T, Todo_list_adminsAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_adminsAggregateType<T>>\n\n    /**\n     * Group by Todo_list_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_adminsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_adminsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_adminsGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_adminsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_adminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_adminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_admins model\n   */\n  readonly fields: todo_list_adminsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_admins.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_adminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_admins model\n   */\n  interface todo_list_adminsFieldRefs {\n    readonly id: FieldRef<\"todo_list_admins\", 'String'>\n    readonly email: FieldRef<\"todo_list_admins\", 'String'>\n    readonly password_hash: FieldRef<\"todo_list_admins\", 'String'>\n    readonly created_at: FieldRef<\"todo_list_admins\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_admins\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_admins findUnique\n   */\n  export type todo_list_adminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where: todo_list_adminsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_admins findUniqueOrThrow\n   */\n  export type todo_list_adminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where: todo_list_adminsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_admins findFirst\n   */\n  export type todo_list_adminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_admins to fetch.\n     */\n    orderBy?: todo_list_adminsOrderByWithRelationInput | todo_list_adminsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_admins.\n     */\n    cursor?: todo_list_adminsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_admins.\n     */\n    distinct?: Todo_list_adminsScalarFieldEnum | Todo_list_adminsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_admins findFirstOrThrow\n   */\n  export type todo_list_adminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_admins to fetch.\n     */\n    orderBy?: todo_list_adminsOrderByWithRelationInput | todo_list_adminsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_admins.\n     */\n    cursor?: todo_list_adminsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_admins.\n     */\n    distinct?: Todo_list_adminsScalarFieldEnum | Todo_list_adminsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_admins findMany\n   */\n  export type todo_list_adminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_list_admins to fetch.\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_admins to fetch.\n     */\n    orderBy?: todo_list_adminsOrderByWithRelationInput | todo_list_adminsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_admins.\n     */\n    cursor?: todo_list_adminsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_admins.\n     */\n    skip?: number\n    distinct?: Todo_list_adminsScalarFieldEnum | Todo_list_adminsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_admins create\n   */\n  export type todo_list_adminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_admins.\n     */\n    data: XOR<todo_list_adminsCreateInput, todo_list_adminsUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_admins createMany\n   */\n  export type todo_list_adminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_admins.\n     */\n    data: todo_list_adminsCreateManyInput | todo_list_adminsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_admins createManyAndReturn\n   */\n  export type todo_list_adminsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_admins.\n     */\n    data: todo_list_adminsCreateManyInput | todo_list_adminsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_admins update\n   */\n  export type todo_list_adminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_admins.\n     */\n    data: XOR<todo_list_adminsUpdateInput, todo_list_adminsUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_admins to update.\n     */\n    where: todo_list_adminsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_admins updateMany\n   */\n  export type todo_list_adminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_admins.\n     */\n    data: XOR<todo_list_adminsUpdateManyMutationInput, todo_list_adminsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_admins to update\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * Limit how many todo_list_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_admins updateManyAndReturn\n   */\n  export type todo_list_adminsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_admins.\n     */\n    data: XOR<todo_list_adminsUpdateManyMutationInput, todo_list_adminsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_admins to update\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * Limit how many todo_list_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_admins upsert\n   */\n  export type todo_list_adminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_admins to update in case it exists.\n     */\n    where: todo_list_adminsWhereUniqueInput\n    /**\n     * In case the todo_list_admins found by the `where` argument doesn't exist, create a new todo_list_admins with this data.\n     */\n    create: XOR<todo_list_adminsCreateInput, todo_list_adminsUncheckedCreateInput>\n    /**\n     * In case the todo_list_admins was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_adminsUpdateInput, todo_list_adminsUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_admins delete\n   */\n  export type todo_list_adminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n    /**\n     * Filter which todo_list_admins to delete.\n     */\n    where: todo_list_adminsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_admins deleteMany\n   */\n  export type todo_list_adminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_admins to delete\n     */\n    where?: todo_list_adminsWhereInput\n    /**\n     * Limit how many todo_list_admins to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_admins without action\n   */\n  export type todo_list_adminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_admins\n     */\n    select?: todo_list_adminsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_admins\n     */\n    omit?: todo_list_adminsOmit<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_list_todos\n   */\n\n  export type AggregateTodo_list_todos = {\n    _count: Todo_list_todosCountAggregateOutputType | null\n    _min: Todo_list_todosMinAggregateOutputType | null\n    _max: Todo_list_todosMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_todosMinAggregateOutputType = {\n    id: string | null\n    todo_list_user_id: string | null\n    title: string | null\n    is_completed: boolean | null\n    created_at: Date | null\n    updated_at: Date | null\n    completed_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_list_todosMaxAggregateOutputType = {\n    id: string | null\n    todo_list_user_id: string | null\n    title: string | null\n    is_completed: boolean | null\n    created_at: Date | null\n    updated_at: Date | null\n    completed_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_list_todosCountAggregateOutputType = {\n    id: number\n    todo_list_user_id: number\n    title: number\n    is_completed: number\n    created_at: number\n    updated_at: number\n    completed_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_todosMinAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    title?: true\n    is_completed?: true\n    created_at?: true\n    updated_at?: true\n    completed_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_list_todosMaxAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    title?: true\n    is_completed?: true\n    created_at?: true\n    updated_at?: true\n    completed_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_list_todosCountAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    title?: true\n    is_completed?: true\n    created_at?: true\n    updated_at?: true\n    completed_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_todosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_todos to aggregate.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_todos\n    **/\n    _count?: true | Todo_list_todosCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_todosMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_todosMaxAggregateInputType\n  }\n\n  export type GetTodo_list_todosAggregateType<T extends Todo_list_todosAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_todos]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_todos[P]>\n      : GetScalarType<T[P], AggregateTodo_list_todos[P]>\n  }\n\n\n\n\n  export type todo_list_todosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_todosWhereInput\n    orderBy?: todo_list_todosOrderByWithAggregationInput | todo_list_todosOrderByWithAggregationInput[]\n    by: Todo_list_todosScalarFieldEnum[] | Todo_list_todosScalarFieldEnum\n    having?: todo_list_todosScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_todosCountAggregateInputType | true\n    _min?: Todo_list_todosMinAggregateInputType\n    _max?: Todo_list_todosMaxAggregateInputType\n  }\n\n  export type Todo_list_todosGroupByOutputType = {\n    id: string\n    todo_list_user_id: string\n    title: string\n    is_completed: boolean\n    created_at: Date\n    updated_at: Date\n    completed_at: Date | null\n    deleted_at: Date | null\n    _count: Todo_list_todosCountAggregateOutputType | null\n    _min: Todo_list_todosMinAggregateOutputType | null\n    _max: Todo_list_todosMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_todosGroupByPayload<T extends todo_list_todosGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_todosGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_todosGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_todosGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_todosGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_todosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    title?: boolean\n    is_completed?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    completed_at?: boolean\n    deleted_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    title?: boolean\n    is_completed?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    completed_at?: boolean\n    deleted_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    title?: boolean\n    is_completed?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    completed_at?: boolean\n    deleted_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectScalar = {\n    id?: boolean\n    todo_list_user_id?: boolean\n    title?: boolean\n    is_completed?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    completed_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type todo_list_todosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"todo_list_user_id\" | \"title\" | \"is_completed\" | \"created_at\" | \"updated_at\" | \"completed_at\" | \"deleted_at\", ExtArgs[\"result\"][\"todo_list_todos\"]>\n  export type todo_list_todosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }\n  export type todo_list_todosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }\n  export type todo_list_todosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }\n\n  export type $todo_list_todosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_todos\"\n    objects: {\n      user: Prisma.$todo_list_usersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged user's {@link todo_list_users.id}. Enforces ownership and\n       * enables cascading deletes when user is removed.\n       */\n      todo_list_user_id: string\n      /**\n       * Todo item label/title. Must be non-empty and max 100 characters, trimmed.\n       * (Validated in service logic, enforced at application layer.)\n       */\n      title: string\n      /**\n       * Whether the todo item is marked as completed (true) or still active\n       * (false).\n       */\n      is_completed: boolean\n      /**\n       * Timestamp when the todo item was created. Used for sort and audit.\n       */\n      created_at: Date\n      /**\n       * Timestamp for most recent modification (description, status change, etc.).\n       */\n      updated_at: Date\n      /**\n       * If completed, timestamp at which the task was marked as done; set to null\n       * if not completed.\n       */\n      completed_at: Date | null\n      /**\n       * Soft delete timestamp; if present, item is considered logically deleted\n       * but not removed from database. Enables future extensibility for\n       * audit/recovery.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n    composites: {}\n  }\n\n  type todo_list_todosGetPayload<S extends boolean | null | undefined | todo_list_todosDefaultArgs> = $Result.GetResult<Prisma.$todo_list_todosPayload, S>\n\n  type todo_list_todosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_todosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_todosCountAggregateInputType | true\n    }\n\n  export interface todo_list_todosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_todos'], meta: { name: 'todo_list_todos' } }\n    /**\n     * Find zero or one Todo_list_todos that matches the filter.\n     * @param {todo_list_todosFindUniqueArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_todosFindUniqueArgs>(args: SelectSubset<T, todo_list_todosFindUniqueArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_todos that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_todosFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_todosFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_todosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_todos that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindFirstArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_todosFindFirstArgs>(args?: SelectSubset<T, todo_list_todosFindFirstArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_todos that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindFirstOrThrowArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_todosFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_todosFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_todos that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findMany()\n     * \n     * // Get first 10 Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_todosFindManyArgs>(args?: SelectSubset<T, todo_list_todosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_todos.\n     * @param {todo_list_todosCreateArgs} args - Arguments to create a Todo_list_todos.\n     * @example\n     * // Create one Todo_list_todos\n     * const Todo_list_todos = await prisma.todo_list_todos.create({\n     *   data: {\n     *     // ... data to create a Todo_list_todos\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_todosCreateArgs>(args: SelectSubset<T, todo_list_todosCreateArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_todos.\n     * @param {todo_list_todosCreateManyArgs} args - Arguments to create many Todo_list_todos.\n     * @example\n     * // Create many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_todosCreateManyArgs>(args?: SelectSubset<T, todo_list_todosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_todos and returns the data saved in the database.\n     * @param {todo_list_todosCreateManyAndReturnArgs} args - Arguments to create many Todo_list_todos.\n     * @example\n     * // Create many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_todos and only return the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_todosCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_todosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_todos.\n     * @param {todo_list_todosDeleteArgs} args - Arguments to delete one Todo_list_todos.\n     * @example\n     * // Delete one Todo_list_todos\n     * const Todo_list_todos = await prisma.todo_list_todos.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_todos\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_todosDeleteArgs>(args: SelectSubset<T, todo_list_todosDeleteArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_todos.\n     * @param {todo_list_todosUpdateArgs} args - Arguments to update one Todo_list_todos.\n     * @example\n     * // Update one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_todosUpdateArgs>(args: SelectSubset<T, todo_list_todosUpdateArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_todos.\n     * @param {todo_list_todosDeleteManyArgs} args - Arguments to filter Todo_list_todos to delete.\n     * @example\n     * // Delete a few Todo_list_todos\n     * const { count } = await prisma.todo_list_todos.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_todosDeleteManyArgs>(args?: SelectSubset<T, todo_list_todosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_todosUpdateManyArgs>(args: SelectSubset<T, todo_list_todosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_todos and returns the data updated in the database.\n     * @param {todo_list_todosUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_todos.\n     * @example\n     * // Update many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_todos and only return the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_todosUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_todosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_todos.\n     * @param {todo_list_todosUpsertArgs} args - Arguments to update or create a Todo_list_todos.\n     * @example\n     * // Update or create a Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_todos\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_todos we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_todosUpsertArgs>(args: SelectSubset<T, todo_list_todosUpsertArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosCountArgs} args - Arguments to filter Todo_list_todos to count.\n     * @example\n     * // Count the number of Todo_list_todos\n     * const count = await prisma.todo_list_todos.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_todos we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_todosCountArgs>(\n      args?: Subset<T, todo_list_todosCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_todosCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_todosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_todosAggregateArgs>(args: Subset<T, Todo_list_todosAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_todosAggregateType<T>>\n\n    /**\n     * Group by Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_todosGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_todosGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_todosGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_todosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_todosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_todos model\n   */\n  readonly fields: todo_list_todosFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_todos.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_todosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends todo_list_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_usersDefaultArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_todos model\n   */\n  interface todo_list_todosFieldRefs {\n    readonly id: FieldRef<\"todo_list_todos\", 'String'>\n    readonly todo_list_user_id: FieldRef<\"todo_list_todos\", 'String'>\n    readonly title: FieldRef<\"todo_list_todos\", 'String'>\n    readonly is_completed: FieldRef<\"todo_list_todos\", 'Boolean'>\n    readonly created_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n    readonly completed_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_todos findUnique\n   */\n  export type todo_list_todosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos findUniqueOrThrow\n   */\n  export type todo_list_todosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos findFirst\n   */\n  export type todo_list_todosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_todos.\n     */\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos findFirstOrThrow\n   */\n  export type todo_list_todosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_todos.\n     */\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos findMany\n   */\n  export type todo_list_todosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos create\n   */\n  export type todo_list_todosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_todos.\n     */\n    data: XOR<todo_list_todosCreateInput, todo_list_todosUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_todos createMany\n   */\n  export type todo_list_todosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_todos.\n     */\n    data: todo_list_todosCreateManyInput | todo_list_todosCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_todos createManyAndReturn\n   */\n  export type todo_list_todosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_todos.\n     */\n    data: todo_list_todosCreateManyInput | todo_list_todosCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_todos update\n   */\n  export type todo_list_todosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateInput, todo_list_todosUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_todos to update.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos updateMany\n   */\n  export type todo_list_todosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_todos to update\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_todos updateManyAndReturn\n   */\n  export type todo_list_todosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_todos to update\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_todos upsert\n   */\n  export type todo_list_todosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_todos to update in case it exists.\n     */\n    where: todo_list_todosWhereUniqueInput\n    /**\n     * In case the todo_list_todos found by the `where` argument doesn't exist, create a new todo_list_todos with this data.\n     */\n    create: XOR<todo_list_todosCreateInput, todo_list_todosUncheckedCreateInput>\n    /**\n     * In case the todo_list_todos was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_todosUpdateInput, todo_list_todosUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_todos delete\n   */\n  export type todo_list_todosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_todos to delete.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos deleteMany\n   */\n  export type todo_list_todosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_todos to delete\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_todos without action\n   */\n  export type todo_list_todosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Todo_list_usersScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Todo_list_usersScalarFieldEnum = (typeof Todo_list_usersScalarFieldEnum)[keyof typeof Todo_list_usersScalarFieldEnum]\n\n\n  export const Todo_list_adminsScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Todo_list_adminsScalarFieldEnum = (typeof Todo_list_adminsScalarFieldEnum)[keyof typeof Todo_list_adminsScalarFieldEnum]\n\n\n  export const Todo_list_todosScalarFieldEnum: {\n    id: 'id',\n    todo_list_user_id: 'todo_list_user_id',\n    title: 'title',\n    is_completed: 'is_completed',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    completed_at: 'completed_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Todo_list_todosScalarFieldEnum = (typeof Todo_list_todosScalarFieldEnum)[keyof typeof Todo_list_todosScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Boolean'\n   */\n  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type todo_list_usersWhereInput = {\n    AND?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    OR?: todo_list_usersWhereInput[]\n    NOT?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    id?: UuidFilter<\"todo_list_users\"> | string\n    email?: StringFilter<\"todo_list_users\"> | string\n    password_hash?: StringFilter<\"todo_list_users\"> | string\n    created_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    todo_list_todos?: Todo_list_todosListRelationFilter\n  }\n\n  export type todo_list_usersOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    todo_list_todos?: todo_list_todosOrderByRelationAggregateInput\n  }\n\n  export type todo_list_usersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    OR?: todo_list_usersWhereInput[]\n    NOT?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    password_hash?: StringFilter<\"todo_list_users\"> | string\n    created_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    todo_list_todos?: Todo_list_todosListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type todo_list_usersOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: todo_list_usersCountOrderByAggregateInput\n    _max?: todo_list_usersMaxOrderByAggregateInput\n    _min?: todo_list_usersMinOrderByAggregateInput\n  }\n\n  export type todo_list_usersScalarWhereWithAggregatesInput = {\n    AND?: todo_list_usersScalarWhereWithAggregatesInput | todo_list_usersScalarWhereWithAggregatesInput[]\n    OR?: todo_list_usersScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_usersScalarWhereWithAggregatesInput | todo_list_usersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_users\"> | string\n    email?: StringWithAggregatesFilter<\"todo_list_users\"> | string\n    password_hash?: StringWithAggregatesFilter<\"todo_list_users\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_users\"> | Date | string\n  }\n\n  export type todo_list_adminsWhereInput = {\n    AND?: todo_list_adminsWhereInput | todo_list_adminsWhereInput[]\n    OR?: todo_list_adminsWhereInput[]\n    NOT?: todo_list_adminsWhereInput | todo_list_adminsWhereInput[]\n    id?: UuidFilter<\"todo_list_admins\"> | string\n    email?: StringFilter<\"todo_list_admins\"> | string\n    password_hash?: StringFilter<\"todo_list_admins\"> | string\n    created_at?: DateTimeFilter<\"todo_list_admins\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_admins\"> | Date | string\n  }\n\n  export type todo_list_adminsOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_adminsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: todo_list_adminsWhereInput | todo_list_adminsWhereInput[]\n    OR?: todo_list_adminsWhereInput[]\n    NOT?: todo_list_adminsWhereInput | todo_list_adminsWhereInput[]\n    password_hash?: StringFilter<\"todo_list_admins\"> | string\n    created_at?: DateTimeFilter<\"todo_list_admins\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_admins\"> | Date | string\n  }, \"id\" | \"email\">\n\n  export type todo_list_adminsOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: todo_list_adminsCountOrderByAggregateInput\n    _max?: todo_list_adminsMaxOrderByAggregateInput\n    _min?: todo_list_adminsMinOrderByAggregateInput\n  }\n\n  export type todo_list_adminsScalarWhereWithAggregatesInput = {\n    AND?: todo_list_adminsScalarWhereWithAggregatesInput | todo_list_adminsScalarWhereWithAggregatesInput[]\n    OR?: todo_list_adminsScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_adminsScalarWhereWithAggregatesInput | todo_list_adminsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_admins\"> | string\n    email?: StringWithAggregatesFilter<\"todo_list_admins\"> | string\n    password_hash?: StringWithAggregatesFilter<\"todo_list_admins\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_admins\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_admins\"> | Date | string\n  }\n\n  export type todo_list_todosWhereInput = {\n    AND?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    OR?: todo_list_todosWhereInput[]\n    NOT?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    id?: UuidFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    title?: StringFilter<\"todo_list_todos\"> | string\n    is_completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    deleted_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    user?: XOR<Todo_list_usersScalarRelationFilter, todo_list_usersWhereInput>\n  }\n\n  export type todo_list_todosOrderByWithRelationInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    is_completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    user?: todo_list_usersOrderByWithRelationInput\n  }\n\n  export type todo_list_todosWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    OR?: todo_list_todosWhereInput[]\n    NOT?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    title?: StringFilter<\"todo_list_todos\"> | string\n    is_completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    deleted_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    user?: XOR<Todo_list_usersScalarRelationFilter, todo_list_usersWhereInput>\n  }, \"id\">\n\n  export type todo_list_todosOrderByWithAggregationInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    is_completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: todo_list_todosCountOrderByAggregateInput\n    _max?: todo_list_todosMaxOrderByAggregateInput\n    _min?: todo_list_todosMinOrderByAggregateInput\n  }\n\n  export type todo_list_todosScalarWhereWithAggregatesInput = {\n    AND?: todo_list_todosScalarWhereWithAggregatesInput | todo_list_todosScalarWhereWithAggregatesInput[]\n    OR?: todo_list_todosScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_todosScalarWhereWithAggregatesInput | todo_list_todosScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidWithAggregatesFilter<\"todo_list_todos\"> | string\n    title?: StringWithAggregatesFilter<\"todo_list_todos\"> | string\n    is_completed?: BoolWithAggregatesFilter<\"todo_list_todos\"> | boolean\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_todos\"> | Date | string\n    completed_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_todos\"> | Date | string | null\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_todos\"> | Date | string | null\n  }\n\n  export type todo_list_usersCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    todo_list_todos?: todo_list_todosCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    todo_list_todos?: todo_list_todosUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    todo_list_todos?: todo_list_todosUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_usersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    todo_list_todos?: todo_list_todosUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_usersCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_usersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_usersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_adminsCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_adminsUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_adminsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_adminsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_adminsCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_adminsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_adminsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_todosCreateInput = {\n    id: string\n    title: string\n    is_completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n    deleted_at?: Date | string | null\n    user: todo_list_usersCreateNestedOneWithoutTodo_list_todosInput\n  }\n\n  export type todo_list_todosUncheckedCreateInput = {\n    id: string\n    todo_list_user_id: string\n    title: string\n    is_completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_todosUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    user?: todo_list_usersUpdateOneRequiredWithoutTodo_list_todosNestedInput\n  }\n\n  export type todo_list_todosUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosCreateManyInput = {\n    id: string\n    todo_list_user_id: string\n    title: string\n    is_completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_todosUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type Todo_list_todosListRelationFilter = {\n    every?: todo_list_todosWhereInput\n    some?: todo_list_todosWhereInput\n    none?: todo_list_todosWhereInput\n  }\n\n  export type todo_list_todosOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type todo_list_usersCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_usersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_usersMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type todo_list_adminsCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_adminsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_adminsMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type BoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type Todo_list_usersScalarRelationFilter = {\n    is?: todo_list_usersWhereInput\n    isNot?: todo_list_usersWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type todo_list_todosCountOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    is_completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_list_todosMaxOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    is_completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_list_todosMinOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    is_completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type BoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type todo_list_todosCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n  }\n\n  export type todo_list_todosUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type todo_list_todosUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_todosUpsertWithWhereUniqueWithoutUserInput | todo_list_todosUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    set?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    disconnect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    delete?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    update?: todo_list_todosUpdateWithWhereUniqueWithoutUserInput | todo_list_todosUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_todosUpdateManyWithWhereWithoutUserInput | todo_list_todosUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n  }\n\n  export type todo_list_todosUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_todosUpsertWithWhereUniqueWithoutUserInput | todo_list_todosUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    set?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    disconnect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    delete?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    update?: todo_list_todosUpdateWithWhereUniqueWithoutUserInput | todo_list_todosUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_todosUpdateManyWithWhereWithoutUserInput | todo_list_todosUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n  }\n\n  export type todo_list_usersCreateNestedOneWithoutTodo_list_todosInput = {\n    create?: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    connectOrCreate?: todo_list_usersCreateOrConnectWithoutTodo_list_todosInput\n    connect?: todo_list_usersWhereUniqueInput\n  }\n\n  export type BoolFieldUpdateOperationsInput = {\n    set?: boolean\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type todo_list_usersUpdateOneRequiredWithoutTodo_list_todosNestedInput = {\n    create?: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    connectOrCreate?: todo_list_usersCreateOrConnectWithoutTodo_list_todosInput\n    upsert?: todo_list_usersUpsertWithoutTodo_list_todosInput\n    connect?: todo_list_usersWhereUniqueInput\n    update?: XOR<XOR<todo_list_usersUpdateToOneWithWhereWithoutTodo_list_todosInput, todo_list_usersUpdateWithoutTodo_list_todosInput>, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedBoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type todo_list_todosCreateWithoutUserInput = {\n    id: string\n    title: string\n    is_completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_todosUncheckedCreateWithoutUserInput = {\n    id: string\n    title: string\n    is_completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_todosCreateOrConnectWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    create: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_todosCreateManyUserInputEnvelope = {\n    data: todo_list_todosCreateManyUserInput | todo_list_todosCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_list_todosUpsertWithWhereUniqueWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    update: XOR<todo_list_todosUpdateWithoutUserInput, todo_list_todosUncheckedUpdateWithoutUserInput>\n    create: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_todosUpdateWithWhereUniqueWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    data: XOR<todo_list_todosUpdateWithoutUserInput, todo_list_todosUncheckedUpdateWithoutUserInput>\n  }\n\n  export type todo_list_todosUpdateManyWithWhereWithoutUserInput = {\n    where: todo_list_todosScalarWhereInput\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type todo_list_todosScalarWhereInput = {\n    AND?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n    OR?: todo_list_todosScalarWhereInput[]\n    NOT?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n    id?: UuidFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    title?: StringFilter<\"todo_list_todos\"> | string\n    is_completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    deleted_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n  }\n\n  export type todo_list_usersCreateWithoutTodo_list_todosInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_usersUncheckedCreateWithoutTodo_list_todosInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_usersCreateOrConnectWithoutTodo_list_todosInput = {\n    where: todo_list_usersWhereUniqueInput\n    create: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n  }\n\n  export type todo_list_usersUpsertWithoutTodo_list_todosInput = {\n    update: XOR<todo_list_usersUpdateWithoutTodo_list_todosInput, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n    create: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    where?: todo_list_usersWhereInput\n  }\n\n  export type todo_list_usersUpdateToOneWithWhereWithoutTodo_list_todosInput = {\n    where?: todo_list_usersWhereInput\n    data: XOR<todo_list_usersUpdateWithoutTodo_list_todosInput, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n  }\n\n  export type todo_list_usersUpdateWithoutTodo_list_todosInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_todosCreateManyUserInput = {\n    id: string\n    title: string\n    is_completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_todosUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/client.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./default\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Actors](#actors)\n- [Todos](#todos)\n\n## Actors\n\n```mermaid\nerDiagram\n\"todo_list_users\" {\n  String id PK\n  String email UK\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n}\n\"todo_list_admins\" {\n  String id PK\n  String email UK\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n}\n```\n\n### `todo_list_users`\n\nRegistered end-user accounts for the minimal Todo app. Each record\nrepresents a single user allowed to log in, manage only their own todos,\nand perform all personal account actions. Emails are unique per table,\nand password security is enforced via password_hash field. No admin\npermissions given. Creation and update timestamps are included for audit\nand compliance. Does not reference todo_list_todos here (reverse\nreference handled in todo table).\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`\n  > User's unique email address for login and identification. Must be unique\n  > within this table.\n- `password_hash`\n  > User password (hashed, never stored in plain text). Required for secure\n  > authentication.\n- `created_at`: Timestamp when the user account was created (ISO 8601, UTC).\n- `updated_at`: Timestamp when the user account was last updated (ISO 8601, UTC).\n\n### `todo_list_admins`\n\nAdministrator accounts for system-wide management of users and todos.\nRecords here represent authorized admins with full privileges to view,\nedit, or delete any todo or user account. Admins log in using a unique\nemail and their password (hashed). No user role overlap—admins are not\nstandard users. Minimal fields for authentication and audit. No direct\nrelation to user or todo tables. Deleted when account is removed (no soft\ndelete).\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`\n  > Admin's unique email address for login. Must be unique within this table\n  > only.\n- `password_hash`: Admin password hash, required for secure login.\n- `created_at`: Admin account creation timestamp.\n- `updated_at`: Timestamp of last modification to this admin account.\n\n## Todos\n\n```mermaid\nerDiagram\n\"todo_list_todos\" {\n  String id PK\n  String todo_list_user_id FK\n  String title\n  Boolean is_completed\n  DateTime created_at\n  DateTime updated_at\n  DateTime completed_at \"nullable\"\n  DateTime deleted_at \"nullable\"\n}\n```\n\n### `todo_list_todos`\n\nTodo list items representing individual user tasks in the minimal Todo\napplication. Each todo is strictly owned by a single user via the {@link\ntodo_list_users.id} foreign key. The table stores only essential fields:\ntask title, completion status, timestamps for creation/update/completion,\nand optional soft delete flag (for future extensibility). No labels,\npriorities, deadlines, or attachments are included, adhering to strict\nminimalism. Admin users may manage all todos via permissions, not via\nextra fields.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `todo_list_user_id`\n  > Belonged user's [todo_list_users.id](#todo_list_users). Enforces ownership and\n  > enables cascading deletes when user is removed.\n- `title`\n  > Todo item label/title. Must be non-empty and max 100 characters, trimmed.\n  > (Validated in service logic, enforced at application layer.)\n- `is_completed`\n  > Whether the todo item is marked as completed (true) or still active\n  > (false).\n- `created_at`: Timestamp when the todo item was created. Used for sort and audit.\n- `updated_at`: Timestamp for most recent modification (description, status change, etc.).\n- `completed_at`\n  > If completed, timestamp at which the task was marked as done; set to null\n  > if not completed.\n- `deleted_at`\n  > Soft delete timestamp; if present, item is considered logically deleted\n  > but not removed from database. Enables future extensibility for\n  > audit/recovery.\n","diagrams":{"Actors":"```mermaid\nerDiagram\n\"todo_list_users\" {\n  String id PK\n  String email UK\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n}\n\"todo_list_admins\" {\n  String id PK\n  String email UK\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n}\n```","Todos":"```mermaid\nerDiagram\n\"todo_list_todos\" {\n  String id PK\n  String todo_list_user_id FK\n  String title\n  Boolean is_completed\n  DateTime created_at\n  DateTime updated_at\n  DateTime completed_at \"nullable\"\n  DateTime deleted_at \"nullable\"\n}\n```"}},"created_at":"2025-09-30T15:49:02.394Z","completed_at":"2025-09-30T15:52:39.537Z","step":0},{"id":"01999b53-6c19-747b-90ee-d7114199b754","type":"userMessage","contents":[{"type":"text","text":"Create the API interface specification."}],"created_at":"2025-09-30T15:52:39.705Z"},{"type":"interface","id":"01999b61-019d-736b-aabb-6d9209d4eb15","instruction":"Create minimal RESTful API interfaces for the basic Todo list features based strictly on the requirements for a simple Todo application. The API should support essential operations: creating a todo, retrieving the list of todos, updating the status or text of a todo, and deleting a todo. Do not add any endpoints or request/response details beyond what is necessary for these minimal tasks.","authorizations":[{"role":"user","operations":[{"specification":"Defines the registration process for new users in the minimal Todo list application. Tied to the 'todo_list_users' table, this operation allows anyone (public) to create an account by providing required fields: unique email and password (hashed via appropriate security procedures). On successful registration, a new record is inserted into 'todo_list_users' with 'email', 'password_hash', 'created_at', and 'updated_at' fields set. A new JWT access token and refresh token are issued if creation succeeds. No admin privileges are granted. All required validations for unique email and strong password are enforced, as noted in the database schema column comments. If the email is already registered, the operation returns an error.\n\nThe registration function is crucial for onboarding, supporting a minimal onboarding path aligned with the strict minimalism requirement—no profile, roles, or extra fields around registration.\n\nSecurity is managed by ensuring the password is never stored or returned in plain text, and the authentication token is built from verified credentials only. Rate limiting or additional anti-abuse controls can be added at the implementation level. Registration is required before any personal Todo management features are unlocked.\n\nThe primary business context for this operation is for new users creating their first identity in the system. No further workflow is required for 'user' registration. Related operations are 'login' and 'refresh', which complete the authentication workflow for subsequent accesses.","authorizationType":"join","description":"This operation enables public registration of a new user for the minimal Todo application. It creates a record in the 'todo_list_users' table with the provided email and hashed password. Both 'created_at' and 'updated_at' are set with the account creation timestamp (UTC ISO 8601).\n\nAll fields referenced (email, password_hash, created_at, updated_at) must be present and valid as per schema. The operation verifies email uniqueness and generates tokens upon successful join. The password is securely hashed as defined in the 'password_hash' column (never in plain text).\n\nNo privilege is granted beyond ordinary user (cannot access any other data). Account registration issues a user JWT token pair without any admin capability, precisely in line with minimalism principles for account management.\n\nSecurity practices require email uniqueness, password strength validation, secure token generation, and all onboarded fields are directly mapped to schema fields with no extension. This operation must be called only by unauthenticated/public clients.\n\nThis operation is always the first in the authentication flow, followed by login for future accesses or refresh for renewing tokens. It is related to the 'login' and 'refresh' operations for a complete authentication lifecycle.","summary":"Register a new user in the 'todo_list_users' table and receive JWT tokens for session start.","parameters":[],"requestBody":{"description":"User registration information for 'todo_list_users' (email, password)","typeName":"ITodoListUser.IJoin"},"responseBody":{"description":"JWT tokens and authorized user metadata after registration (authentication success)","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/user/join","method":"post"},{"specification":"Defines the user login flow for the minimal Todo application, corresponding to credential verification in the 'todo_list_users' table. Takes email and password as input, validates the credentials against 'todo_list_users.email' and 'password_hash'. On verification success, issues a new JWT access token and refresh token with payload fields reflecting user identity and permissions per schema. Updates the 'updated_at' field to record last activity timestamp. If login fails (email not registered or password mismatch), returns a clear error message without specifying which field was incorrect, following security best practices.\n\nThis operation is tightly bound to the core authentication workflow—users must log in before accessing any todo management operations. Rate limiting can be applied by implementation to protect against brute force attacks. All email and password checks use only actual schema fields—'email' and 'password_hash'.\n\nNo password or sensitive data is returned, only tokens and schema-mandated user information. This login operation is essential for member ('user') and admin flows.\n\nSecurity is managed by safe handling of credentials, correct password hashing, and non-disclosure of credentials. Only registered users should call this operation, not guests. The related operations are 'join' (for registration), and 'refresh' (for session renewal).","authorizationType":"login","description":"This operation authenticates users of the minimal Todo app by validating their provided email and password. It queries only 'todo_list_users', using fields 'email' and 'password_hash', and—upon successful credential match—issues new JWT tokens for access and refresh, following the strict security requirements.\n\nLogin updates the 'updated_at' field to log last login activity. No extra account or role information is returned; the authentication response includes only required fields.\n\nSecurity is ensured by: never revealing actual password or failure specifics, hashing all credentials, and rejecting all logins lacking valid schema-matching records. Each login attempt is isolated to the user account referenced by email.\n\nThe login process is the second step in end-user authentication workflows, after registration. Token refresh and logout are handled by additional endpoints. This operation is not accessible for admin or guest roles—it is only for member users as defined by the schema.","summary":"Authenticate a user in 'todo_list_users' with email/password and issue new JWT tokens.","parameters":[],"requestBody":{"description":"Login information (email and password) per 'todo_list_users' schema.","typeName":"ITodoListUser.ILogin"},"responseBody":{"description":"JWT tokens and authorized user metadata after successful login.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/user/login","method":"post"},{"specification":"Defines the JWT token refresh operation for authenticated users in the minimal Todo list application. This is tied to the 'todo_list_users' table and is accessible only with a valid refresh token. The operation's input is a refresh token, which is verified for validity and activity status; upon successful verification, a new access/refresh token pair is issued to the user. No other account details are modified during refresh, but the 'updated_at' field of the user is updated to log the token renewal event.\n\nThe refresh endpoint supports stateless session renewal per business requirements, allowing seamless session continuation without repeated credential entry, as long as a valid refresh token exists. Token validation, revocation handling, and expiration enforcement are managed by back-end business logic, not exposed through this interface.\n\nSecurity is achieved through strict mapping of incoming tokens to actual user schema entries; no sensitive information is exposed. All fields referenced correspond precisely with the 'todo_list_users' schema, field names, and definitions. Related authentication operations include registration/join and login.\n\nThe refresh operation is a crucial part of JWT-based session longevity, allows short-lived access tokens, and supports secure, user-friendly authentication cycles without repeated manual login. No admin or guest privilege is available.","authorizationType":"refresh","description":"This endpoint allows authenticated users to renew their session by submitting a valid JWT refresh token. It references the 'todo_list_users' table for token validation and—if valid—generates new access and refresh tokens. The 'updated_at' field is updated to reflect token renewal.\n\nNo additional details are altered in the user record. Security is managed by fully verifying the refresh token, rejecting invalid or expired tokens, and exposing no extra account data.\n\nAll token operations are strictly mapped to real schema fields, and the response returns the minimal necessary authorized DTO with no extra information. This operation is essential for maintaining user login persistence under JWT strategies. Only available to users with valid refresh tokens issued by the system.\n\nThe refresh endpoint completes the authentication cycle in coordination with registration and login. Failure to provide a valid refresh token results in an authentication error with no account data disclosed.","summary":"Refresh JWT tokens for a user in 'todo_list_users', updating the session securely.","parameters":[],"requestBody":{"description":"Refresh token for renewing authentication in 'todo_list_users'.","typeName":"ITodoListUser.IRefresh"},"responseBody":{"description":"New JWT tokens and authorized user metadata after a successful refresh.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/user/refresh","method":"post"}]},{"role":"admin","operations":[{"specification":"Implements administrator authentication and account management for the minimal Todo list application, mapped to the todo_list_admins table. This includes registration (join), login, and JWT token refresh based on admin records identified by unique email and password_hash. New admin accounts are registered with an email address and hashed password, and issued both access and refresh tokens on join. All passwords are securely stored via the password_hash field as specified, and email must be unique as enforced by the Prisma schema. Timestamps (created_at, updated_at) are included for audit purposes. This operation serves as the only entrypoint for creating admin-level access, and admin privileges are strictly separated from regular users at the table level. No additional account properties are referenced, as only essential identity and security fields exist in the schema.","authorizationType":"join","description":"This API registers a new admin account using the essential fields specified in the todo_list_admins schema: unique email and password_hash, issued at registration time. Each admin account is uniquely identified by the email and has its password securely stored as a hash. Upon successful registration, the endpoint issues a new access token and refresh token, embodying the authentication standard required for future privileged access by admins.\n\nThe implementation validates the email for uniqueness at the database level (@@unique on email field) and ensures the password is securely hashed before being persisted. The timestamps for creation and update (created_at, updated_at) are automatically managed for audit purposes and are not user-supplied.\n\nAdmin registration is functionally distinct from standard user registration: only entries in the todo_list_admins table can obtain admin-level access. There is no role overlap; admin accounts do not provide standard user functionality and have no reference to the todos or user tables. This precise separation is both a security and audit measure.\n\nFor security, registration input is validated for email uniqueness and password completeness. Passwords should be strong, and only hashes ever stored. Token issuance adheres to business rules for admin session management and access control.\n\nThis operation is necessary for all admin workflow authentication and is the exclusive way to add new admins. All subsequent admin login and session refresh flows rely on successful join.","summary":"Register a new admin account in todo_list_admins and issue initial admin tokens.","parameters":[],"requestBody":{"description":"Admin registration payload: email and hashed password (password_hash).","typeName":"ITodoListAdmin.ICreate"},"responseBody":{"description":"Authorized admin entity and authentication tokens.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/admin/join","method":"post"},{"specification":"Authenticate an administrator using email and password, validating against todo_list_admins. Issues new JWT access and refresh tokens for active sessions. Only admin records are considered (table: todo_list_admins) and authentication requires password matching via password_hash. No additional properties are referenced from the schema. Admin status is determined strictly by presence in the todo_list_admins table.","authorizationType":"login","description":"This API provides administrator login via email and password as defined in todo_list_admins. Email must be unique and previously registered. Password authentication is implemented by comparing the received password, securely hashed, to the stored password_hash field. Admin status is strictly enforced via membership in the todo_list_admins table; regular users are not permitted to authenticate as admins.\n\nUpon successful authentication, the endpoint generates and returns new access and refresh tokens, encapsulated as required for privileged sessions. JWT tokens contain admin role and identity claims to distinguish access scope.\n\nNo further user attributes are referenced, and only fields email and password_hash from the schema are required to validate credentials. The schema requires all admin emails to be unique, reducing impersonation risk.\n\nFor security, ensure passwords are always transmitted securely and never logged or exposed. Login attempts are limited to prevent brute-force attacks as dictated in higher-level security policy and business rules documents.\n\nThis endpoint is essential to admin authentication and is required before any privileged or system-wide access is granted. The tokens returned are used for all subsequent admin-level operations until expiration or revocation.","summary":"Authenticate an admin account from todo_list_admins and issue JWT access and refresh tokens.","parameters":[],"requestBody":{"description":"Authentication payload: admin email and password (plain).","typeName":"ITodoListAdmin.ILogin"},"responseBody":{"description":"Authorized admin identity and JWT authentication tokens.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/admin/login","method":"post"},{"specification":"Allows administrators to obtain fresh JWT access and refresh tokens using a valid refresh token. Supported by the todo_list_admins schema where admin identity is determined by stored refresh token validation. No additional table fields are required beyond unique admin identification. Tokens are reissued with current admin claims and expiration policies as per business rules for session management.","authorizationType":"refresh","description":"This API endpoint enables administrators to renew their session by presenting a valid refresh token, as per JWT session lifecycle for admin accounts managed in todo_list_admins. It uses the refresh token to validate the admin's identity and re-issues a new pair of access and refresh tokens on success. Only tokens mapped to an existing admin's identity in todo_list_admins are valid for refresh.\n\nNo extra data fields are referenced from the admin schema beyond identity linkage required by the token. This operation is essential for maintaining secure and continuous admin sessions without repeated credentials entry.\n\nSecurity best practices mandate that expired, revoked, or invalid refresh tokens must be rejected. Tokens are tied directly to admin accounts and cannot be shared or used cross-role or cross-user. The JWT contents encode admin role information and enforce privilege separation from regular users in the system.\n\nNo password or email is required for this operation—only the refresh token supplied by the client. This endpoint is a foundational part of admin authentication flows and supports stateless, scalable session management for admins.\n\nThis operation is necessary to maintain admin authentication state and avoid repeated logins. All advanced admin functions require a non-expired valid access token issued through the login or refresh endpoints.","summary":"Refresh an admin JWT access and refresh token set for ongoing sessions.","parameters":[],"requestBody":{"description":"Refresh token request, typically providing the current refresh token.","typeName":"ITodoListAdmin.IRefresh"},"responseBody":{"description":"Authorized admin data and renewed JWT tokens.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/admin/refresh","method":"post"}]}],"document":{"operations":[{"specification":"Defines the registration process for new users in the minimal Todo list application. Tied to the 'todo_list_users' table, this operation allows anyone (public) to create an account by providing required fields: unique email and password (hashed via appropriate security procedures). On successful registration, a new record is inserted into 'todo_list_users' with 'email', 'password_hash', 'created_at', and 'updated_at' fields set. A new JWT access token and refresh token are issued if creation succeeds. No admin privileges are granted. All required validations for unique email and strong password are enforced, as noted in the database schema column comments. If the email is already registered, the operation returns an error.\n\nThe registration function is crucial for onboarding, supporting a minimal onboarding path aligned with the strict minimalism requirement—no profile, roles, or extra fields around registration.\n\nSecurity is managed by ensuring the password is never stored or returned in plain text, and the authentication token is built from verified credentials only. Rate limiting or additional anti-abuse controls can be added at the implementation level. Registration is required before any personal Todo management features are unlocked.\n\nThe primary business context for this operation is for new users creating their first identity in the system. No further workflow is required for 'user' registration. Related operations are 'login' and 'refresh', which complete the authentication workflow for subsequent accesses.","authorizationType":"join","description":"This operation enables public registration of a new user for the minimal Todo application. It creates a record in the 'todo_list_users' table with the provided email and hashed password. Both 'created_at' and 'updated_at' are set with the account creation timestamp (UTC ISO 8601).\n\nAll fields referenced (email, password_hash, created_at, updated_at) must be present and valid as per schema. The operation verifies email uniqueness and generates tokens upon successful join. The password is securely hashed as defined in the 'password_hash' column (never in plain text).\n\nNo privilege is granted beyond ordinary user (cannot access any other data). Account registration issues a user JWT token pair without any admin capability, precisely in line with minimalism principles for account management.\n\nSecurity practices require email uniqueness, password strength validation, secure token generation, and all onboarded fields are directly mapped to schema fields with no extension. This operation must be called only by unauthenticated/public clients.\n\nThis operation is always the first in the authentication flow, followed by login for future accesses or refresh for renewing tokens. It is related to the 'login' and 'refresh' operations for a complete authentication lifecycle.","summary":"Register a new user in the 'todo_list_users' table and receive JWT tokens for session start.","parameters":[],"requestBody":{"description":"User registration information for 'todo_list_users' (email, password)","typeName":"ITodoListUser.IJoin"},"responseBody":{"description":"JWT tokens and authorized user metadata after registration (authentication success)","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/user/join","method":"post"},{"specification":"Defines the user login flow for the minimal Todo application, corresponding to credential verification in the 'todo_list_users' table. Takes email and password as input, validates the credentials against 'todo_list_users.email' and 'password_hash'. On verification success, issues a new JWT access token and refresh token with payload fields reflecting user identity and permissions per schema. Updates the 'updated_at' field to record last activity timestamp. If login fails (email not registered or password mismatch), returns a clear error message without specifying which field was incorrect, following security best practices.\n\nThis operation is tightly bound to the core authentication workflow—users must log in before accessing any todo management operations. Rate limiting can be applied by implementation to protect against brute force attacks. All email and password checks use only actual schema fields—'email' and 'password_hash'.\n\nNo password or sensitive data is returned, only tokens and schema-mandated user information. This login operation is essential for member ('user') and admin flows.\n\nSecurity is managed by safe handling of credentials, correct password hashing, and non-disclosure of credentials. Only registered users should call this operation, not guests. The related operations are 'join' (for registration), and 'refresh' (for session renewal).","authorizationType":"login","description":"This operation authenticates users of the minimal Todo app by validating their provided email and password. It queries only 'todo_list_users', using fields 'email' and 'password_hash', and—upon successful credential match—issues new JWT tokens for access and refresh, following the strict security requirements.\n\nLogin updates the 'updated_at' field to log last login activity. No extra account or role information is returned; the authentication response includes only required fields.\n\nSecurity is ensured by: never revealing actual password or failure specifics, hashing all credentials, and rejecting all logins lacking valid schema-matching records. Each login attempt is isolated to the user account referenced by email.\n\nThe login process is the second step in end-user authentication workflows, after registration. Token refresh and logout are handled by additional endpoints. This operation is not accessible for admin or guest roles—it is only for member users as defined by the schema.","summary":"Authenticate a user in 'todo_list_users' with email/password and issue new JWT tokens.","parameters":[],"requestBody":{"description":"Login information (email and password) per 'todo_list_users' schema.","typeName":"ITodoListUser.ILogin"},"responseBody":{"description":"JWT tokens and authorized user metadata after successful login.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/user/login","method":"post"},{"specification":"Defines the JWT token refresh operation for authenticated users in the minimal Todo list application. This is tied to the 'todo_list_users' table and is accessible only with a valid refresh token. The operation's input is a refresh token, which is verified for validity and activity status; upon successful verification, a new access/refresh token pair is issued to the user. No other account details are modified during refresh, but the 'updated_at' field of the user is updated to log the token renewal event.\n\nThe refresh endpoint supports stateless session renewal per business requirements, allowing seamless session continuation without repeated credential entry, as long as a valid refresh token exists. Token validation, revocation handling, and expiration enforcement are managed by back-end business logic, not exposed through this interface.\n\nSecurity is achieved through strict mapping of incoming tokens to actual user schema entries; no sensitive information is exposed. All fields referenced correspond precisely with the 'todo_list_users' schema, field names, and definitions. Related authentication operations include registration/join and login.\n\nThe refresh operation is a crucial part of JWT-based session longevity, allows short-lived access tokens, and supports secure, user-friendly authentication cycles without repeated manual login. No admin or guest privilege is available.","authorizationType":"refresh","description":"This endpoint allows authenticated users to renew their session by submitting a valid JWT refresh token. It references the 'todo_list_users' table for token validation and—if valid—generates new access and refresh tokens. The 'updated_at' field is updated to reflect token renewal.\n\nNo additional details are altered in the user record. Security is managed by fully verifying the refresh token, rejecting invalid or expired tokens, and exposing no extra account data.\n\nAll token operations are strictly mapped to real schema fields, and the response returns the minimal necessary authorized DTO with no extra information. This operation is essential for maintaining user login persistence under JWT strategies. Only available to users with valid refresh tokens issued by the system.\n\nThe refresh endpoint completes the authentication cycle in coordination with registration and login. Failure to provide a valid refresh token results in an authentication error with no account data disclosed.","summary":"Refresh JWT tokens for a user in 'todo_list_users', updating the session securely.","parameters":[],"requestBody":{"description":"Refresh token for renewing authentication in 'todo_list_users'.","typeName":"ITodoListUser.IRefresh"},"responseBody":{"description":"New JWT tokens and authorized user metadata after a successful refresh.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/user/refresh","method":"post"},{"specification":"Implements administrator authentication and account management for the minimal Todo list application, mapped to the todo_list_admins table. This includes registration (join), login, and JWT token refresh based on admin records identified by unique email and password_hash. New admin accounts are registered with an email address and hashed password, and issued both access and refresh tokens on join. All passwords are securely stored via the password_hash field as specified, and email must be unique as enforced by the Prisma schema. Timestamps (created_at, updated_at) are included for audit purposes. This operation serves as the only entrypoint for creating admin-level access, and admin privileges are strictly separated from regular users at the table level. No additional account properties are referenced, as only essential identity and security fields exist in the schema.","authorizationType":"join","description":"This API registers a new admin account using the essential fields specified in the todo_list_admins schema: unique email and password_hash, issued at registration time. Each admin account is uniquely identified by the email and has its password securely stored as a hash. Upon successful registration, the endpoint issues a new access token and refresh token, embodying the authentication standard required for future privileged access by admins.\n\nThe implementation validates the email for uniqueness at the database level (@@unique on email field) and ensures the password is securely hashed before being persisted. The timestamps for creation and update (created_at, updated_at) are automatically managed for audit purposes and are not user-supplied.\n\nAdmin registration is functionally distinct from standard user registration: only entries in the todo_list_admins table can obtain admin-level access. There is no role overlap; admin accounts do not provide standard user functionality and have no reference to the todos or user tables. This precise separation is both a security and audit measure.\n\nFor security, registration input is validated for email uniqueness and password completeness. Passwords should be strong, and only hashes ever stored. Token issuance adheres to business rules for admin session management and access control.\n\nThis operation is necessary for all admin workflow authentication and is the exclusive way to add new admins. All subsequent admin login and session refresh flows rely on successful join.","summary":"Register a new admin account in todo_list_admins and issue initial admin tokens.","parameters":[],"requestBody":{"description":"Admin registration payload: email and hashed password (password_hash).","typeName":"ITodoListAdmin.ICreate"},"responseBody":{"description":"Authorized admin entity and authentication tokens.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/admin/join","method":"post"},{"specification":"Authenticate an administrator using email and password, validating against todo_list_admins. Issues new JWT access and refresh tokens for active sessions. Only admin records are considered (table: todo_list_admins) and authentication requires password matching via password_hash. No additional properties are referenced from the schema. Admin status is determined strictly by presence in the todo_list_admins table.","authorizationType":"login","description":"This API provides administrator login via email and password as defined in todo_list_admins. Email must be unique and previously registered. Password authentication is implemented by comparing the received password, securely hashed, to the stored password_hash field. Admin status is strictly enforced via membership in the todo_list_admins table; regular users are not permitted to authenticate as admins.\n\nUpon successful authentication, the endpoint generates and returns new access and refresh tokens, encapsulated as required for privileged sessions. JWT tokens contain admin role and identity claims to distinguish access scope.\n\nNo further user attributes are referenced, and only fields email and password_hash from the schema are required to validate credentials. The schema requires all admin emails to be unique, reducing impersonation risk.\n\nFor security, ensure passwords are always transmitted securely and never logged or exposed. Login attempts are limited to prevent brute-force attacks as dictated in higher-level security policy and business rules documents.\n\nThis endpoint is essential to admin authentication and is required before any privileged or system-wide access is granted. The tokens returned are used for all subsequent admin-level operations until expiration or revocation.","summary":"Authenticate an admin account from todo_list_admins and issue JWT access and refresh tokens.","parameters":[],"requestBody":{"description":"Authentication payload: admin email and password (plain).","typeName":"ITodoListAdmin.ILogin"},"responseBody":{"description":"Authorized admin identity and JWT authentication tokens.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/admin/login","method":"post"},{"specification":"Allows administrators to obtain fresh JWT access and refresh tokens using a valid refresh token. Supported by the todo_list_admins schema where admin identity is determined by stored refresh token validation. No additional table fields are required beyond unique admin identification. Tokens are reissued with current admin claims and expiration policies as per business rules for session management.","authorizationType":"refresh","description":"This API endpoint enables administrators to renew their session by presenting a valid refresh token, as per JWT session lifecycle for admin accounts managed in todo_list_admins. It uses the refresh token to validate the admin's identity and re-issues a new pair of access and refresh tokens on success. Only tokens mapped to an existing admin's identity in todo_list_admins are valid for refresh.\n\nNo extra data fields are referenced from the admin schema beyond identity linkage required by the token. This operation is essential for maintaining secure and continuous admin sessions without repeated credentials entry.\n\nSecurity best practices mandate that expired, revoked, or invalid refresh tokens must be rejected. Tokens are tied directly to admin accounts and cannot be shared or used cross-role or cross-user. The JWT contents encode admin role information and enforce privilege separation from regular users in the system.\n\nNo password or email is required for this operation—only the refresh token supplied by the client. This endpoint is a foundational part of admin authentication flows and supports stateless, scalable session management for admins.\n\nThis operation is necessary to maintain admin authentication state and avoid repeated logins. All advanced admin functions require a non-expired valid access token issued through the login or refresh endpoints.","summary":"Refresh an admin JWT access and refresh token set for ongoing sessions.","parameters":[],"requestBody":{"description":"Refresh token request, typically providing the current refresh token.","typeName":"ITodoListAdmin.IRefresh"},"responseBody":{"description":"Authorized admin data and renewed JWT tokens.","typeName":"ITodoListAdmin.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/admin/refresh","method":"post"},{"specification":"This operation retrieves a paginated, filtered list of user accounts registered in the minimal Todo List application. It is based on the todo_list_users table in the Prisma schema, with support for search (by email) and pagination (offset/limit), allowing administrators to audit or manage users efficiently. No sensitive business logic other than filtering and sorting is exposed; authentication ensures only privileged roles can use this endpoint.","path":"/todoList/admin/users","method":"patch","summary":"List all registered users with paging and search (admin only)","description":"Retrieve a paginated and optionally filtered list of all registered user accounts in the minimal Todo List application. This endpoint allows administrators to search by email and supports pagination for large numbers of users, leveraging the todo_list_users table as defined in the schema.\n\nThe endpoint enforces access restrictions: only authenticated administrators can use this operation. Regular users are forbidden from accessing this API. Results include all standard fields (user id, email, timestamps) but do not contain password hashes or other sensitive information.\n\nCommon use cases include system administration, maintenance, and audit reviews by privileged staff. Related endpoints manage creation, update, or deletion of users and their associated data.","parameters":[],"requestBody":{"description":"Request parameters for user search, including email filter and pagination controls","typeName":"ITodoListUser.IRequest"},"responseBody":{"description":"Paginated results containing summary information for user accounts","typeName":"IPageITodoListUser.ISummary"},"authorizationRoles":["admin"],"name":"index","authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"This operation retrieves the details of a single user account from the todo_list_users table by unique userId. It is used by administrators to view the profile and metadata of any registered user. Regular users are not allowed to use this endpoint for other users. The endpoint returns all standard user details except sensitive authentication data, and is protected for admin-only access.","path":"/todoList/admin/users/{userId}","method":"get","summary":"Get details for a specific user account (admin only)","description":"Retrieve full information about a single user registered in the minimal Todo List application, using the provided userId as a lookup. This endpoint accesses the todo_list_users table and is intended strictly for administrative use, enforcing security via authentication and role checks.\n\nReturned data includes the user's id, email, account creation and update timestamps, and does not include password hashes. Only administrators can access this endpoint for any userId; regular users may not use this endpoint.\n\nThis API complements other endpoints for user creation, update, and deletion, allowing administrators to inspect account-specific data as needed for auditing or maintenance.","parameters":[{"name":"userId","description":"Unique identifier for the user to be retrieved","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Details of the target user account, excluding sensitive authentication data","typeName":"ITodoListUser"},"authorizationRoles":["admin"],"name":"at","authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"This operation updates (replaces) the information of a specific registered user referenced by userId within the todo_list_users table. Only administrative accounts are authorized. The request body contains only mutable user fields (for example, email or password hash update). Immutable fields, such as creation date and user id, cannot be changed. Business logic enforces unique email addresses and triggers updated_at. Password hashes must be pre-hashed when supplied.","path":"/todoList/admin/users/{userId}","method":"put","summary":"Update a specific user's information by ID (admin only)","description":"Update the properties (e.g., email, password hash) of a registered user in the minimal Todo List app, targeting the user account identified by userId. This operation modifies the todo_list_users table, enforcing all business rules for uniqueness, permissions, and field validation.\n\nOnly administrators may perform this operation, and all field updates must comply with data constraints: unique, properly formatted email; hashed password; and required timestamps. Upon successful update, updated_at is set to the current timestamp. Sensitive operations are logged for audit purposes.\n\nThis API is designed for rare administrative corrections, security responses, or manual account management; regular users cannot update other user records via this endpoint.","parameters":[{"name":"userId","description":"Unique identifier of the user to be updated","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Object containing updatable user fields (such as email or password hash)","typeName":"ITodoListUser.IUpdate"},"responseBody":{"description":"The updated user account record reflecting all changes","typeName":"ITodoListUser"},"authorizationRoles":["admin"],"name":"update","authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"This operation completely removes a user account from the todo_list_users table, referencing the userId as primary key. It performs a hard delete: the user record and all their associated todos are permanently erased from the system. No soft delete mechanism is in use for user accounts. Only admins can call this operation. This ensures compliance with data integrity and privacy requirements, enforcing cascading deletes for all related todos and preventing orphaned task records.","path":"/todoList/admin/users/{userId}","method":"delete","summary":"Delete a user and cascade-remove all their todos (admin only)","description":"Permanently remove a user account, including all owned todo tasks, from the system. This operation acts on the todo_list_users table, using the provided userId as the target. It enforces security, allowing only authenticated administrators to invoke it. The delete is physically executed (hard delete), severing all related data rather than simply flagging records as deleted.\n\nUpon successful completion, the user account and all todos connected through the foreign key to todo_list_todos are erased. This supports privacy mandates and prevents orphaned or leaked records. No response body is returned if successful; errors are signaled with appropriate codes and messages in case of permission, referential, or internal failures.\n\nThis endpoint is to be used by administrators in the rare case of account removal due to user request, policy violation, or data privacy obligations. Irrecoverable data loss is a consequence, so extra audit logging or confirmation mechanisms should be employed by clients.","parameters":[{"name":"userId","description":"Unique identifier of the user to be deleted","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin"],"name":"erase","authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"Retrieves a paginated list of administrator accounts for system-wide management of the minimal Todo application. Each record in this operation represents an admin user with full privileges, as defined in the todo_list_admins table of the Prisma schema. The operation supports searching, filtering, and sorting administrators by email or creation date, primarily for maintenance or emergency recovery purposes. Does not expose sensitive information like password hashes. Admins are responsible for overseeing users and todos, and this endpoint is key for audit and control.","path":"/todoList/admin/admins","method":"patch","summary":"Search and retrieve a paginated list of administrator accounts from todo_list_admins.","description":"This API operation returns a filtered and paginated list of administrator accounts registered in the system. It operates over the todo_list_admins table, providing system-wide visibility for superusers and allowing easy search, filtering, and sorting based on email or the account creation date.\n\nAuthorization is strictly required: only users with the admin role may access this endpoint, as regular users are never permitted to view or manage administrator information. The returned data excludes sensitive fields such as password hashes, focusing only on operational metadata.\n\nThe operation is essential for maintenance, emergency support, and security audits. It is typically paired with endpoints for viewing the details of a specific administrator or for performing create, update, or delete actions. Error scenarios include forbidden access for non-admins, validation failures on filter parameters, and unexpected server errors.","parameters":[],"requestBody":{"description":"Filtering and pagination criteria for listing administrators.","typeName":"ITodoListAdmin.IRequest"},"responseBody":{"description":"Paginated list of administrator account summaries matching search criteria.","typeName":"IPageITodoListAdmin.ISummary"},"authorizationType":null,"authorizationRole":"admin","name":"index","prerequisites":[]},{"specification":"Retrieves the detailed profile of a specific administrator user from the todo_list_admins table, identified by adminId. This operation presents relevant profile data except for sensitive fields (like password_hash), giving authorized admins the ability to view metadata and history for a particular admin account for maintenance, audit, or troubleshooting activities.","path":"/todoList/admin/admins/{adminId}","method":"get","summary":"Get detailed information for a specific administrator by adminId from todo_list_admins.","description":"This API operation provides authorized admin users with the full metadata profile of a particular administrator account, uniquely identified by adminId in the todo_list_admins table. It is used for viewing core attributes such as email, timestamps, and other audit-relevant fields, while ensuring that password hashes and other sensitive data remain undisclosed.\n\nAccess to this endpoint is restricted strictly to users with admin privileges. Security and privacy are enforced at the endpoint and service layer. The information supplied helps with system maintenance, user audits, or when troubleshooting admin privileges and actions.\n\nRelated operations include listing all admins and enabling update or delete actions by adminId. Error responses include forbidden access for non-admins, not found for missing adminId, and resource access violations for unauthorized requests.","parameters":[{"name":"adminId","description":"The unique identifier (UUID) of the administrator to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Administrator profile data matching the supplied adminId.","typeName":"ITodoListAdmin"},"authorizationType":null,"authorizationRole":"admin","name":"at","prerequisites":[{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"description":"An admin must exist in the system before querying their administrator profile by adminId. The only available POST operation that creates an admin entity is POST /todoList/admin/todos; this must be completed to obtain a valid adminId for the GET operation."}]},{"specification":"Updates the metadata for a specific administrator account in the todo_list_admins table, targeted by adminId. Supports changing updatable attributes like email or password (hashed), and updates audit timestamps. This operation is available exclusively to users with the admin role to manage privileges, rotate credentials, or correct metadata. Does not support changing the adminId itself.","path":"/todoList/admin/admins/{adminId}","method":"put","summary":"Update administrator profile details for a target admin, identified by adminId.","description":"This API endpoint allows authorized admin users to update an administrator record in the todo_list_admins table, selected by the adminId parameter. Supported fields for update typically include the admin's email address and a new password hash, as well as tracking changes in the updated_at timestamp for audit.\n\nStrict access controls are in effect: only users with admin privileges may invoke this operation. Changing adminId is not permitted; all updates are constrained to permitted fields. The response supplies the new metadata profile after updating.\n\nRelated endpoints include detail retrieval, list, and delete actions. Errors include forbidden for non-admins, not found for invalid adminId, and validation errors on input data.","parameters":[{"name":"adminId","description":"The unique identifier (UUID) of the administrator to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"New metadata for the administrator, such as email or password hash, to apply to the target adminId.","typeName":"ITodoListAdmin.IUpdate"},"responseBody":{"description":"The updated administrator profile after modification.","typeName":"ITodoListAdmin"},"authorizationType":null,"authorizationRole":"admin","name":"update","prerequisites":[{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"description":"An admin account must be created before it can be updated. POST /todoList/admin/todos is required to obtain a valid adminId reference for this operation."}]},{"specification":"Removes a specific administrator account from the todo_list_admins table, targeted by adminId. This is a hard delete (no soft deletion fields present in schema). Only users with the admin role may invoke this operation. Permanently deletes the admin account and all associated privileges—a critical operation to be audited.","path":"/todoList/admin/admins/{adminId}","method":"delete","summary":"Delete a specific administrator account, identified by adminId (hard delete) from todo_list_admins.","description":"This API operation allows an authorized admin to permanently remove an administrator account from the todo_list_admins table, selecting the record by adminId. The deletion is irreversible: the record is physically removed, along with the associated email and password data. As there is no deleted_at or similar soft delete flag in the schema, this is a hard delete operation.\n\nAccess is strictly limited to admin users, and this action should only be performed with care, typically when an admin is leaving the organization or privileges must be revoked. The operation will log the deletion for audit purposes and enforce all necessary security checks.\n\nPotential errors include forbidden access for non-admins, not found for invalid adminId, and resource conflicts (e.g., if last remaining admin; business logic must ensure at least one admin remains).","parameters":[{"name":"adminId","description":"The unique identifier (UUID) of the administrator to delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"admin","name":"erase","prerequisites":[{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"description":"An admin account must exist before it can be deleted. Use POST /todoList/admin/todos to create an admin before performing the DELETE operation on adminId."}]},{"specification":"This operation retrieves a paginated, filtered list of Todo items for the currently authenticated user, or for all users if the requester has 'admin' permissions. It operates on the todo_list_todos table from the Prisma schema. Filtering criteria may include completion status and search on task title, and results are sorted reverse-chronologically by creation date. The returned results are limited to a page size for performance and usability, supporting pagination and sorting options consistent with minimal Todo list requirements. Only the essential fields from the schema (id, title, is_completed, timestamps, etc.) are exposed. Admin users can access all todos; regular users see only their own.","description":"Retrieve a filtered, paginated list of Todo items using advanced search capabilities. This operation is available to authenticated users wishing to view their own todos, or to administrators wishing to view all users' todos. The returned data is sorted in reverse-chronological order by creation date, as described in the requirements.\n\nAuthorization and role validation are enforced so that standard users can access only their own todos, while admins can access the entire dataset. Text search for task titles and filtering by completion status are included based on application-level logic. Validation ensures users may not access data outside their permission scope.\n\nResults are paginated for efficiency and may be further sorted or filtered as required by client use cases. The type definitions for both the request and response DTOs are based directly on the minimal todo_list_todos schema structure, including PK, title, completion status, timestamps, and ownership references (for admin views).","summary":"Search and retrieve a filtered, paginated list of Todo items.","authorizationRoles":["user","admin"],"path":"/todoList/user/todos","method":"patch","name":"index","parameters":[],"requestBody":{"description":"Filter, search, and pagination options for retrieving Todo items.","typeName":"ITodoListTodo.IRequest"},"responseBody":{"description":"Paginated list of Todo summary items matching search/authorization criteria.","typeName":"IPageITodoListTodo.ISummary"},"authorizationRole":"user","authorizationType":null,"prerequisites":[]},{"specification":"This operation retrieves a paginated, filtered list of Todo items for the currently authenticated user, or for all users if the requester has 'admin' permissions. It operates on the todo_list_todos table from the Prisma schema. Filtering criteria may include completion status and search on task title, and results are sorted reverse-chronologically by creation date. The returned results are limited to a page size for performance and usability, supporting pagination and sorting options consistent with minimal Todo list requirements. Only the essential fields from the schema (id, title, is_completed, timestamps, etc.) are exposed. Admin users can access all todos; regular users see only their own.","description":"Retrieve a filtered, paginated list of Todo items using advanced search capabilities. This operation is available to authenticated users wishing to view their own todos, or to administrators wishing to view all users' todos. The returned data is sorted in reverse-chronological order by creation date, as described in the requirements.\n\nAuthorization and role validation are enforced so that standard users can access only their own todos, while admins can access the entire dataset. Text search for task titles and filtering by completion status are included based on application-level logic. Validation ensures users may not access data outside their permission scope.\n\nResults are paginated for efficiency and may be further sorted or filtered as required by client use cases. The type definitions for both the request and response DTOs are based directly on the minimal todo_list_todos schema structure, including PK, title, completion status, timestamps, and ownership references (for admin views).","summary":"Search and retrieve a filtered, paginated list of Todo items.","authorizationRoles":["user","admin"],"path":"/todoList/admin/todos","method":"patch","name":"index","parameters":[],"requestBody":{"description":"Filter, search, and pagination options for retrieving Todo items.","typeName":"ITodoListTodo.IRequest"},"responseBody":{"description":"Paginated list of Todo summary items matching search/authorization criteria.","typeName":"IPageITodoListTodo.ISummary"},"authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"This operation retrieves the detailed information for a single Todo item identified by ID, from the todo_list_todos table in the Prisma schema. The authenticated user may only request their own Todo items unless they have 'admin' role, in which case any Todo is accessible. The operation returns all relevant fields per the schema, including id, title, is_completed, timestamps, and relational owner ID. Proper validation ensures that only authorized access is permitted, with clear error handling for forbidden or missing resources.","description":"Retrieve the details of a specific Todo item given its unique identifier. This operation enforces security by confirming that the requester is either the owner of the Todo (standard user) or has administrative privileges. The detailed response includes all relevant schema fields: id, belonged user id, title, completion status, creation timestamp, last updated timestamp, completion timestamp, and deleted timestamp (for soft-deleted items).\n\nIf the Todo is not found or the requesting user lacks permission, the system returns an appropriate error. This function is essential to enable clients to display or further manipulate a single Todo item in detail. Any fields not present in the minimal schema are excluded from the response.","summary":"Retrieve the details of a specific Todo item by ID.","authorizationRoles":["user","admin"],"path":"/todoList/user/todos/{todoId}","method":"get","name":"at","parameters":[{"name":"todoId","description":"Unique identifier for the target Todo item.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed information for the requested Todo item, if permitted.","typeName":"ITodoListTodo"},"authorizationRole":"user","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoList/user/todos","method":"post"},"description":"A Todo item must be created before its details can be retrieved by ID."}]},{"specification":"This operation retrieves the detailed information for a single Todo item identified by ID, from the todo_list_todos table in the Prisma schema. The authenticated user may only request their own Todo items unless they have 'admin' role, in which case any Todo is accessible. The operation returns all relevant fields per the schema, including id, title, is_completed, timestamps, and relational owner ID. Proper validation ensures that only authorized access is permitted, with clear error handling for forbidden or missing resources.","description":"Retrieve the details of a specific Todo item given its unique identifier. This operation enforces security by confirming that the requester is either the owner of the Todo (standard user) or has administrative privileges. The detailed response includes all relevant schema fields: id, belonged user id, title, completion status, creation timestamp, last updated timestamp, completion timestamp, and deleted timestamp (for soft-deleted items).\n\nIf the Todo is not found or the requesting user lacks permission, the system returns an appropriate error. This function is essential to enable clients to display or further manipulate a single Todo item in detail. Any fields not present in the minimal schema are excluded from the response.","summary":"Retrieve the details of a specific Todo item by ID.","authorizationRoles":["user","admin"],"path":"/todoList/admin/todos/{todoId}","method":"get","name":"at","parameters":[{"name":"todoId","description":"Unique identifier for the target Todo item.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed information for the requested Todo item, if permitted.","typeName":"ITodoListTodo"},"authorizationRole":"admin","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"description":"A Todo item must be created before its details can be retrieved by ID."}]},{"specification":"This operation creates a new Todo item for the authenticated user, persisting it into the todo_list_todos table per the Prisma schema. It requires a valid title up to 100 characters and initializes related fields, such as completion state (defaults to incomplete), creation, and update timestamps. The item is associated with the requesting user via foreign key. Input validation prevents empty titles or titles exceeding length, and ownership is enforced by server-side association. The response returns the created Todo object.","description":"Create a new Todo item for the authenticated user. The title field is mandatory, must be trimmed, non-empty, and no longer than 100 characters. On creation, the item is marked incomplete, and all timestamps (creation, update) are set to the current time. Ownership association is automatic, ensuring users cannot create Todos for others; admin users can also create Todos for their own admin account.\n\nAny business-rule or validation violations, such as duplicate titles (if such logic is enforced in application), title length issues, or whitespace-only titles, are reported with clear error messages. Only fields defined in the minimal schema (id, title, is_completed, timestamps, user ownership) are processed. The operation does not support setting completed or deleted fields upon creation; these fields are managed by update endpoints or internal logic.","summary":"Create a new Todo item for the current authenticated user.","authorizationRoles":["user","admin"],"path":"/todoList/user/todos","method":"post","name":"create","parameters":[],"requestBody":{"description":"Data required for creating a new Todo item: minimal, only title required.","typeName":"ITodoListTodo.ICreate"},"responseBody":{"description":"The created Todo item with all schema fields, as stored in the database.","typeName":"ITodoListTodo"},"authorizationRole":"user","authorizationType":null,"prerequisites":[]},{"specification":"This operation creates a new Todo item for the authenticated user, persisting it into the todo_list_todos table per the Prisma schema. It requires a valid title up to 100 characters and initializes related fields, such as completion state (defaults to incomplete), creation, and update timestamps. The item is associated with the requesting user via foreign key. Input validation prevents empty titles or titles exceeding length, and ownership is enforced by server-side association. The response returns the created Todo object.","description":"Create a new Todo item for the authenticated user. The title field is mandatory, must be trimmed, non-empty, and no longer than 100 characters. On creation, the item is marked incomplete, and all timestamps (creation, update) are set to the current time. Ownership association is automatic, ensuring users cannot create Todos for others; admin users can also create Todos for their own admin account.\n\nAny business-rule or validation violations, such as duplicate titles (if such logic is enforced in application), title length issues, or whitespace-only titles, are reported with clear error messages. Only fields defined in the minimal schema (id, title, is_completed, timestamps, user ownership) are processed. The operation does not support setting completed or deleted fields upon creation; these fields are managed by update endpoints or internal logic.","summary":"Create a new Todo item for the current authenticated user.","authorizationRoles":["user","admin"],"path":"/todoList/admin/todos","method":"post","name":"create","parameters":[],"requestBody":{"description":"Data required for creating a new Todo item: minimal, only title required.","typeName":"ITodoListTodo.ICreate"},"responseBody":{"description":"The created Todo item with all schema fields, as stored in the database.","typeName":"ITodoListTodo"},"authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"This operation updates an existing Todo item for which the authenticated user is the owner, or (if admin) for any Todo. It operates on the todo_list_todos table from the Prisma schema. The request can update the title (validating required constraints) and/or the completion status. The operation also updates the updated_at timestamp, and the completed_at timestamp if the is_completed flag is set. All fields are validated per schema and requirements. Ownership is checked; standard users may update only their own todos, while admins may update any Todo.","description":"Update the details of an existing Todo item, as specified by its UUID. The operation enforces strict validation for title updates: the title must be non-empty, without leading or trailing whitespace, and within the 100-character schema constraint. The operation supports updating the is_completed flag, managing the completed_at timestamp accordingly: if a Todo is marked complete, completed_at is set; if marked as incomplete, completed_at is cleared.\n\nOnly users who own the Todo can update it, except for admin users who may update any item. All changes are subject to full field validation as specified in the business rules. The updated Todo is returned in the response. If permission is denied, or if the item does not exist, the operation returns a clear error.","summary":"Update a specific Todo item’s title or completion status.","authorizationRoles":["user","admin"],"path":"/todoList/user/todos/{todoId}","method":"put","name":"update","parameters":[{"name":"todoId","description":"Unique identifier for the Todo item to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"New values for the Todo's fields: title and/or completion status.","typeName":"ITodoListTodo.IUpdate"},"responseBody":{"description":"The updated Todo item after changes are saved.","typeName":"ITodoListTodo"},"authorizationRole":"user","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoList/user/todos","method":"post"},"description":"Todo item must be created before it can be updated. The item is referenced by todoId, which can only exist if the Todo has already been created."}]},{"specification":"This operation updates an existing Todo item for which the authenticated user is the owner, or (if admin) for any Todo. It operates on the todo_list_todos table from the Prisma schema. The request can update the title (validating required constraints) and/or the completion status. The operation also updates the updated_at timestamp, and the completed_at timestamp if the is_completed flag is set. All fields are validated per schema and requirements. Ownership is checked; standard users may update only their own todos, while admins may update any Todo.","description":"Update the details of an existing Todo item, as specified by its UUID. The operation enforces strict validation for title updates: the title must be non-empty, without leading or trailing whitespace, and within the 100-character schema constraint. The operation supports updating the is_completed flag, managing the completed_at timestamp accordingly: if a Todo is marked complete, completed_at is set; if marked as incomplete, completed_at is cleared.\n\nOnly users who own the Todo can update it, except for admin users who may update any item. All changes are subject to full field validation as specified in the business rules. The updated Todo is returned in the response. If permission is denied, or if the item does not exist, the operation returns a clear error.","summary":"Update a specific Todo item’s title or completion status.","authorizationRoles":["user","admin"],"path":"/todoList/admin/todos/{todoId}","method":"put","name":"update","parameters":[{"name":"todoId","description":"Unique identifier for the Todo item to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"New values for the Todo's fields: title and/or completion status.","typeName":"ITodoListTodo.IUpdate"},"responseBody":{"description":"The updated Todo item after changes are saved.","typeName":"ITodoListTodo"},"authorizationRole":"admin","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"description":"Todo item must be created before it can be updated. The operation is performed using todoId, which can only exist after the Todo item has been created for the admin."}]},{"specification":"This operation permanently deletes an existing Todo task from the database. It targets the todo_list_todos table in the Todo List application's Prisma schema. The operation is designed to enable either the owner (user) of the todo or an administrator to remove a specific todo item by its unique identifier. The deletion is a hard delete, as indicated by business requirements and the absence of any persistent soft-delete business rule (though a deleted_at column exists for potential future use). Related permission and audit constraints should be handled in the service layer: a user may only delete their own todos, while an admin can delete any todo.","path":"/todoList/user/todos/{todoId}","method":"delete","summary":"Permanently delete a Todo task from the todo_list_todos table by its ID.","description":"This API operation deletes a specific Todo task from the todo_list_todos table. Only authenticated users can invoke this endpoint, and business logic must ensure either that the requester is the owner of the todo or has admin privileges. If the user is not the owner and is not an administrator, the operation is denied.\n\nThe operation takes the todoId as a path parameter. The todoId must be a valid UUID corresponding to an existing Todo task. If no such Todo exists, the service should return an error or not-found status. Upon successful deletion, the Todo task is permanently removed from the database and cannot be recovered via standard means. The operation does not return a response body; a successful status code confirms deletion.\n\nThe todo_list_todos table defines the association between Todo tasks and users. Owning users are identified by the todo_list_user_id foreign key. The deleted_at column exists for potential future extensibility regarding soft deletes, but this operation performs a true hard delete, erasing both data and all related links. Admin users may invoke this operation on any todo, and all permission management should be implemented in business/service logic.","parameters":[{"name":"todoId","description":"Unique identifier of the Todo task to be deleted (UUID format).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["user","admin"],"name":"erase","authorizationRole":"user","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoList/user/todos","method":"post"},"description":"A Todo item must be created before it can be deleted by its ID."}]},{"specification":"This operation permanently deletes an existing Todo task from the database. It targets the todo_list_todos table in the Todo List application's Prisma schema. The operation is designed to enable either the owner (user) of the todo or an administrator to remove a specific todo item by its unique identifier. The deletion is a hard delete, as indicated by business requirements and the absence of any persistent soft-delete business rule (though a deleted_at column exists for potential future use). Related permission and audit constraints should be handled in the service layer: a user may only delete their own todos, while an admin can delete any todo.","path":"/todoList/admin/todos/{todoId}","method":"delete","summary":"Permanently delete a Todo task from the todo_list_todos table by its ID.","description":"This API operation deletes a specific Todo task from the todo_list_todos table. Only authenticated users can invoke this endpoint, and business logic must ensure either that the requester is the owner of the todo or has admin privileges. If the user is not the owner and is not an administrator, the operation is denied.\n\nThe operation takes the todoId as a path parameter. The todoId must be a valid UUID corresponding to an existing Todo task. If no such Todo exists, the service should return an error or not-found status. Upon successful deletion, the Todo task is permanently removed from the database and cannot be recovered via standard means. The operation does not return a response body; a successful status code confirms deletion.\n\nThe todo_list_todos table defines the association between Todo tasks and users. Owning users are identified by the todo_list_user_id foreign key. The deleted_at column exists for potential future extensibility regarding soft deletes, but this operation performs a true hard delete, erasing both data and all related links. Admin users may invoke this operation on any todo, and all permission management should be implemented in business/service logic.","parameters":[{"name":"todoId","description":"Unique identifier of the Todo task to be deleted (UUID format).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["user","admin"],"name":"erase","authorizationRole":"admin","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"description":"A Todo item must be created before it can be deleted by its ID through the admin operation."}]}],"components":{"authorization":[{"name":"user","description":"A registered user who can log in, log out, and manage their own personal todo list, but cannot access or modify other users’ data. Can create, update, mark as complete/incomplete, and delete their own tasks.","kind":"member"},{"name":"admin","description":"An administrator who can view and manage all users and todos in the system, has permission to perform maintenance and emergency recovery tasks.","kind":"admin"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageITodoListUser.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListUser.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoListAdmin.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListAdmin.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoListTodo.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListTodo.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"ITodoListUser.IJoin":{"type":"object","properties":{"email":{"type":"string","format":"email","maxLength":255,"description":"User's unique email address for registration and authentication.\n\nThis field corresponds to the 'email' column in the 'todo_list_users' table of the minimal Todo app's database. Email addresses must be unique, properly formatted, and trimmed of any leading or trailing whitespace during validation. The application enforces uniqueness and format checks for security and usability. Example: user@example.com.\n\nCannot be empty and is required during user registration."},"password":{"type":"string","minLength":8,"maxLength":72,"description":"Plaintext password for user registration. This field is required in the join (registration) operation only, and is NOT stored in the database. At the service layer, this password will be securely hashed and persisted as 'password_hash'. Minimum length enforced for basic security.\n\nThe password must be strong enough to satisfy current business rules and is never returned in any response. Example: P@ssw0rd123. Cannot be empty, and must NOT be shorter or longer than the defined constraints."}},"required":["email","password"],"description":"Request body for registering a new end user account in the minimal Todo app.\n\nThis schema represents only the inputs necessary for user onboarding: unique email and plaintext password. No optional or extra fields are permitted, strictly maintaining minimalism. Format and uniqueness validations are handled server-side during registration. The password will be stored as a hash after initial handling; never returned or stored in plain text."},"ITodoListUser.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"The unique identifier of the newly registered user, mapped from 'todo_list_users.id'.\n\nThis value is a UUID and can be used as a stable user reference throughout the application."},"email":{"type":"string","format":"email","description":"Authorized user's email address after successful registration, login, or refresh operation.\n\nThis field is sourced from the 'todo_list_users.email' column, guaranteed to be unique and valid."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created (ISO 8601 UTC). Set automatically at registration."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of last update to the user account (ISO 8601 UTC). Set automatically when account metadata changes. Used for audit and concurrency purposes."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","email","created_at","updated_at","token"],"description":"Authorization response structure for end-user registration, login, or token refresh.\n\nThis schema is returned whenever a user successfully authenticates through join, login, or refresh operations. All sensitive values, such as the plain password or underlying hash, are omitted. Only public data and the JWT token group are returned, in compliance with minimal security best practices."},"ITodoListUser.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Registered email address used to identify the end user during login.\n\nCorresponds directly to the 'email' field in 'todo_list_users'. This value is used as the primary lookup credential and must be unique within users."},"password":{"type":"string","description":"The plaintext password entered by the user at login time.\n\nThis value must match the user's password before hashing. It is not stored, is not returned in any response, and is compared securely only during authentication. After hashing and verification, this value is discarded."}},"required":["email","password"],"description":"Request body for authenticating a user with login credentials.\n\nThis schema is required for user login operations in the minimal Todo app. The server processes these values, validates credentials against 'todo_list_users', and never returns them in plain text or in any output."},"ITodoListUser.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Existing refresh token associated with the authenticated user.\n\nThis token is provided to extend and maintain the user session, subject to validation and expiration rules."}},"required":["refresh_token"],"description":"Request body for renewing an authentication session with a refresh token.\n\nThis schema must be provided when requesting a new set of authentication tokens using a previously issued refresh token.\n\nOnly the 'refresh_token' property is required, and structure follows best practices for secure JWT session renewal."},"ITodoListAdmin.ICreate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Admin's unique email address for login. This field must be unique within the todo_list_admins table and is required for identification and authentication.\n\nThe email is used as the primary credential for admin login and must conform to standard email formatting rules. Uniqueness is enforced at the database level, ensuring no duplicate admin accounts can use the same email address. Examples: admin@example.com, system.owner@mail.com.\n\nRefer to Prisma schema field: email in todo_list_admins."},"password":{"type":"string","minLength":8,"description":"Plaintext password for the new admin account, submitted for registration only. The system will hash this password according to security best practices before persisting it in the password_hash field in the database.\n\nThis field is required for initial registration and should never be returned or stored in plaintext. Validation for minimum length and password strength occurs before hashing and storage.\n\nExamples: \"StrongP@ssword123\", \"adminPassword!2025\".\n\nRefer to security best practices in requirements analysis."}},"required":["email","password"],"description":"Payload required to create a new administrator account in the minimal Todo application. Includes only the essential fields: a unique email address and a plaintext password (which will be hashed by the system before storage).\n\nThis structure enforces minimum security and uniqueness standards for administrator registration. It should never include output-only or system-generated fields such as id, created_at, or password_hash. See Prisma schema 'todo_list_admins', field comments."},"ITodoListAdmin.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authenticated administrator. This value comes from the id column in todo_list_admins and is assigned at registration.\n\nThis property is used for identity in authorization, logging, and audit trails. Format: standard RFC 4122 UUID, e.g., \"6b9f1ce0-3622-47c3-8591-061430c4e8f9\"."},"email":{"type":"string","format":"email","description":"Admin user's unique email address for login and identification.\n\nReferenced in the 'email' column of the 'todo_list_admins' table. Each admin must have a unique email address. Changing this value may impact loginability and security logging. Used for authentication and system notifications when necessary."},"created_at":{"type":"string","format":"date-time","description":"Timestamp marking the admin account creation.\n\nMatches the 'created_at' field in the 'todo_list_admins' table. Timezone is UTC, formatted according to ISO 8601. Used for auditing, tracking account history, and system monitoring."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp representing the last modification of the administrator record.\n\nMatches the 'updated_at' column in the 'todo_list_admins' table (ISO 8601, UTC). Updated whenever significant changes to the admin profile, password, or core metadata are made."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","email","created_at","updated_at","token"],"description":"Authorization response for an authenticated Todo List application administrator. Returned upon successful registration (join), login, or token refresh. Includes the administrator's unique ID and session JWT tokens for continued access.\n\nThe structure complies with best security practices by not returning any password or sensitive credential fields. Description aligns with business rules for IAuthorized types per requirements analysis."},"ITodoListAdmin.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The admin's unique email address for login. This must correspond to a registered administrator account in todo_list_admins.\n\nValidation is enforced for proper email formatting and existence in the database. This is a required property in the login process."},"password":{"type":"string","minLength":8,"description":"The plaintext password submitted for authentication. This is verified against the stored credential (password_hash) for the admin account after hashing.\n\nPasswords must meet minimum length and strength criteria and are never stored or returned in plaintext. This field is only accepted at login; it is not part of responses.\n\nRefer to field-level constraints in business and security requirements."}},"required":["email","password"],"description":"Payload structure for administrator login requests in the Todo List minimal application. Must include the registered email address and the corresponding plaintext password for authentication.\n\nNo extra properties are included. This structure adheres strictly to schema and security requirements, referencing only the credentials needed for login."},"ITodoListAdmin.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"JWT refresh token required to renew an admin session and obtain new access/refresh tokens. Provided only by the authentication system and expected to match a valid issued token for the admin in question.\n\nThis property must be non-empty and must conform to the format of tokens issued by the system under previous successful authentication or registration."}},"required":["refresh_token"],"description":"Payload required for administrator token refresh operations in the minimal Todo List app. Must supply a currently valid refresh token issued for the admin account.\n\nNo extraneous properties are accepted; the structure is secured and minimal, mapped directly to backend session management logic."},"ITodoListUser.IRequest":{"type":"object","properties":{"page":{"type":"integer","format":"uint32","description":"Page number (starting at 1). Used for pagination when listing users. Must be a positive integer. Optional. Defaults to 1 if not provided."},"limit":{"type":"integer","format":"uint32","description":"Maximum number of users returned per page. Used for pagination when listing users. Optional. Defaults to 100. Should not exceed application-enforced page size limits."},"email":{"type":"string","description":"Optional email filter for user search. If provided, only users whose email contains or matches this value will be included. Supports partial matching or case-insensitive search depending on implementation."},"sort":{"oneOf":[{"const":"created_at","description":"Sort field for user list. Allows sorting users by 'created_at' timestamp or 'email' address. Enum constraint: only 'created_at' or 'email' accepted. Optional."},{"const":"email","description":"Sort field for user list. Allows sorting users by 'created_at' timestamp or 'email' address. Enum constraint: only 'created_at' or 'email' accepted. Optional."}],"description":"Sort field for user list. Allows sorting users by 'created_at' timestamp or 'email' address. Enum constraint: only 'created_at' or 'email' accepted. Optional."},"order":{"oneOf":[{"const":"asc","description":"Sort order direction: use 'asc' for ascending and 'desc' for descending results. Default is 'desc' for reverse-chronological ordering. Optional."},{"const":"desc","description":"Sort order direction: use 'asc' for ascending and 'desc' for descending results. Default is 'desc' for reverse-chronological ordering. Optional."}],"description":"Sort order direction: use 'asc' for ascending and 'desc' for descending results. Default is 'desc' for reverse-chronological ordering. Optional."}},"required":[],"description":"Request parameters for searching and paginating the user list. Used by administrators to retrieve a filtered and ordered list of user accounts from the 'todo_list_users' table.\n\nUse page and limit for paginated fetches, email to filter for a specific address, and sort/order to control presentation for admin audit or maintenance screens."},"ITodoListUser":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique user identifier (UUID, version 4, generated at registration). Corresponds to the 'id' primary key in the 'todo_list_users' table. Read-only; never user supplied."},"email":{"type":"string","description":"User's unique email address for login and identification. Enforced unique at the database level in 'todo_list_users'. Required at registration; must remain unique in updates."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created (ISO 8601 UTC). Set automatically at registration."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of last update to the user account (ISO 8601 UTC). Set automatically when account metadata changes. Used for audit and concurrency purposes."}},"required":["id","email","created_at","updated_at"],"description":"Represents a registered user in the minimal Todo List application. Maps directly to the 'todo_list_users' Prisma table. Contains core user account data for display, administration, or identification in downstream operations.\n\nSensitive data, such as password hashes, are strictly excluded. Only business logic and audit-relevant fields (id, email, timestamps) are exposed. Intended for use in account views for both administrators and users themselves."},"ITodoListUser.IUpdate":{"type":"object","properties":{"email":{"type":"string","description":"New email address for the user. If provided, must be unique within the system and comply with standard email formatting requirements. Optional—if omitted, the email remains unchanged."},"password_hash":{"type":"string","description":"New password hash to replace the existing password for secure login. Must be a valid output of the configured password hashing algorithm (never plain text). Optional; if omitted, password remains unchanged."}},"required":[],"description":"Object for specifying updates to a user account by an administrator. Used in the PUT operation for /todoList/admin/users/{userId}. Allows changes to mutable fields only, as per the underlying Prisma schema constraints. The only updatable fields are 'email' and 'password_hash'; id and timestamps are immutable or set by the backend. Password_hash must be pre-hashed before using this interface. Any field not included will remain unchanged.\n\nBusiness logic must validate uniqueness, non-emptiness, and format rules for updated values."},"ITodoListAdmin.IRequest":{"type":"object","properties":{"page":{"type":"integer","format":"uint32","description":"Page number (starting at 1). Used for administrator listing pagination. Optional. Defaults to 1."},"limit":{"type":"integer","format":"uint32","description":"Maximum number of admins returned per page. Pagination support for scalability and performance. Optional. Defaults to 100."},"email":{"type":"string","description":"Optional email address filter for admin search. Allows partial or case-insensitive matches depending on backend implementation. Used for maintenance, audit, or admin account discovery."},"sort":{"oneOf":[{"const":"created_at","description":"Sort field for administrator list. Use 'created_at' for chronological sorting and 'email' for alphabetic presentation. Enum constraint. Optional."},{"const":"email","description":"Sort field for administrator list. Use 'created_at' for chronological sorting and 'email' for alphabetic presentation. Enum constraint. Optional."}],"description":"Sort field for administrator list. Use 'created_at' for chronological sorting and 'email' for alphabetic presentation. Enum constraint. Optional."},"order":{"oneOf":[{"const":"asc","description":"Sort order: 'asc' for ascending, 'desc' for descending. Default may be 'desc' for recent-first. Enum constraint. Optional."},{"const":"desc","description":"Sort order: 'asc' for ascending, 'desc' for descending. Default may be 'desc' for recent-first. Enum constraint. Optional."}],"description":"Sort order: 'asc' for ascending, 'desc' for descending. Default may be 'desc' for recent-first. Enum constraint. Optional."}},"required":[],"description":"Request object for paginated, sorted administrator list retrieval and searching on '/todoList/admin/admins' API. Used only by admin users for operational, maintenance, or audit purposes.\n\nSupports advanced admin search, email filtering, and sorting needs. Matches constraints and capabilities defined in business rules and Prisma schema."},"ITodoListAdmin":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the admin account.\n\nRepresents the primary key in the 'todo_list_admins' table. Used to uniquely distinguish administrator users and manage their access rights. This value is generated by the system at registration and is not mutable."},"email":{"type":"string","format":"email","description":"Admin user's unique email address for login and identification.\n\nReferenced in the 'email' column of the 'todo_list_admins' table. Each admin must have a unique email address. Changing this value may impact loginability and security logging. Used for authentication and system notifications when necessary."},"created_at":{"type":"string","format":"date-time","description":"Timestamp marking the admin account creation.\n\nMatches the 'created_at' field in the 'todo_list_admins' table. Timezone is UTC, formatted according to ISO 8601. Used for auditing, tracking account history, and system monitoring."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp representing the last modification of the administrator record.\n\nMatches the 'updated_at' column in the 'todo_list_admins' table (ISO 8601, UTC). Updated whenever significant changes to the admin profile, password, or core metadata are made."}},"required":["id","email","created_at","updated_at"],"description":"Administrator entity schema for the minimal Todo list application.\n\nRepresents a registered admin user as defined in the 'todo_list_admins' table, containing only essential identification and audit fields. This structure excludes sensitive authentication information, instead providing a secure, audit-focused, minimal representation of admin account metadata.\n\nAll properties directly correspond to columns in the Prisma schema, facilitating system-wide administration and access management while enforcing strict minimalism."},"ITodoListAdmin.IUpdate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"New email address for the administrator account.\n\nUpdates the 'email' field in 'todo_list_admins'. Value must be unique and properly formatted (validated as email). Optional in update, but if provided must adhere to all uniqueness and syntax business rules."},"password_hash":{"type":"string","description":"New password hash for setting or rotating administrator credentials.\n\nCorresponds to the 'password_hash' column in 'todo_list_admins'. Must be the result of a secure hashing procedure by the backend. Never plain text. Optional in update, only provided if password is actually changed."}},"required":[],"description":"Update DTO for administrator records in the minimal Todo system.\n\nAllows modification of certain admin attributes: email and (hashed) password. All fields are optional to allow partial updates. Only system-assigned properties are changeable; id and timestamps are managed by the backend and are immutable in this structure. All modifications are audited in created_at/updated_at timestamps, as defined in the Prisma schema."},"ITodoListTodo.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Current page number for paginated results.\n\nControls paging when listing Todo items. Must be a positive integer if present. Default determined by implementation."},"limit":{"type":"integer","minimum":1,"maximum":100,"description":"Maximum number of Todo items to return in a single page of results.\n\nOptional. Capped for minimal app at 100 to prevent excessive resource usage. Defaults may apply in implementation."},"search":{"type":"string","description":"Text query for matching Todo 'title' (case-insensitive, partial match).\n\nEnables searching Todos via substring or pattern-match against the 'title' field, using advanced database filtering as supported by backend."},"is_completed":{"type":"boolean","description":"Filter by completed/incomplete status of Todos.\n\nWhen provided, restricts results to Todos marked as either completed (true) or active (false). Optional; omitting will not filter by status."}},"required":[],"description":"Request DTO for searching and paginating Todo items in the minimal Todo list application.\n\nSupports both member and admin search over the 'todo_list_todos' table, based on authorization context. Provides pagination, full-text search on 'title', and optional filtering by completion status. All parameters are strictly optional to support both simple and advanced querying.\n\nEach property is mapped to a column or filter supported by the Prisma schema and backend API.\n\nBusiness rules and security filtering based on authentication are expected to be applied before query execution."},"ITodoListTodo":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"The unique identifier for a Todo item. Corresponds to the 'id' field in the 'todo_list_todos' table. Used for lookups, updates, and deletion. System generated, never client supplied."},"todo_list_user_id":{"type":"string","format":"uuid","description":"Foreign key identifying the owner user for this Todo.\n\nReferences 'todo_list_users.id'. Enforced for ownership validation and cascading deletes when user is removed. Used for admin/system queries; regular users only see their own id here."},"title":{"type":"string","maxLength":100,"description":"The label or title describing the Todo task.\n\nSourced from the 'title' field in 'todo_list_todos'. Application logic requires it to be non-empty, trimmed, and at most 100 characters in length. Used for display and search."},"is_completed":{"type":"boolean","description":"Whether the Todo item is marked as completed (true) or is still active (false).\n\nMapped to the 'is_completed' field in the schema. Drives UI display logic and filter options in queries."},"created_at":{"type":"string","format":"date-time","description":"Timestamp of when the Todo item was created (UTC, ISO 8601).\n\nMatches 'created_at' in the database. Immutable. Used for auditing, ordering, and filtering."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of the most recent modification to the Todo (UTC, ISO 8601).\n\nSourced from 'updated_at' in the schema. Updated on edit or status change. Used for syncing and tracking changes."},"completed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the Todo was marked as complete, or null if not completed.\n\nNull when is_completed is false. Set to date-time (ISO 8601, UTC) when task is completed. Sourced from 'completed_at' field."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"If present, records the (soft) deletion timestamp for the Todo item. Null if not deleted.\n\nMapped to 'deleted_at' field in 'todo_list_todos' for future extensibility. Hard deletes are currently performed, so this will usually be null."}},"required":["id","todo_list_user_id","title","is_completed","created_at","updated_at"],"description":"Main schema for an individual Todo item in the minimal Todo List application.\n\nAll fields directly correspond to columns in the 'todo_list_todos' Prisma schema, defining ownership, content, completion status, and auditing information. The presence of required fields is enforced by database and application logic."},"ITodoListTodo.ICreate":{"type":"object","properties":{"title":{"type":"string","maxLength":100,"description":"Title of the Todo item. Must be non-empty, trimmed of whitespace, cannot include line breaks or special formatting. Maximum length after trimming is 100 characters. Required when creating a new Todo item. This property implements field-level validation as described in the business rules and mapped directly to the 'title' column in the todo_list_todos table. Example: 'Buy groceries'.\n\nThis property is validated at the application logic layer for minimalism and must never be omitted in the creation DTO."}},"required":["title"],"description":"Create DTO for adding a new Todo item to the user's list.\n\nThis schema defines the minimal required fields to create a Todo: only 'title' is accepted, matching the strict business rules of the minimal Todo app. Ownership and system-managed fields (is_completed, timestamps, user ID) are not client-supplied and are set automatically by the backend. No extraneous or optional properties are present, enforcing absolute simplicity. All business validation (non-empty, max length, trimmed) applies."},"ITodoListTodo.IUpdate":{"type":"object","properties":{"title":{"type":"string","maxLength":100,"description":"Optional updated title for the Todo item. If provided, must be non-empty after trimming, maximum 100 characters, and contain no line breaks or formatting. Mapped to the 'title' column in todo_list_todos. Null or omitted means no title update.\n\nValidation ensures the updated title is consistent with creation rules, aligning with business rules that only allow description/title and status to be modified in updates."},"is_completed":{"type":"boolean","description":"Optional updated completion status for this Todo item. True marks the task as completed, false sets it as active/incomplete. If set, the completed_at timestamp is updated or cleared automatically by business logic as required. Directly tied to the is_completed column in todo_list_todos. Null or omission leaves status unchanged.\n\nUpdate business rules dictate only status and title can be modified."}},"required":[],"description":"Update DTO for an existing Todo item.\n\nAllows partial updates: title and/or completion status can be changed. No system-managed fields (owner, timestamps, ID) are present. Properties are optional and may be supplied in any combination. Business rules enforce application of all validation on supplied fields. Only permitted fields for update are included, in line with minimalism and business requirements."},"ITodoListUser.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the user (UUID format). Serves as the primary key in the todo_list_users table. This value is never mutable and always required in the summary. Used to reference this user in administrative views.\n\nSee also 'id' column documentation in the Prisma schema."},"email":{"type":"string","description":"The registered email address of the user. Must be unique within todo_list_users, follows standard email format constraints. Only exposed in summary/admin contexts (not publicly visible). Used to identify login credentials and for display in administrative lists.\n\nDirectly corresponds to the 'email' column in the Prisma schema."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the account was created (UTC ISO 8601). Used for auditing and administrative purposes, may be used for sorting user lists. Directly corresponds to the 'created_at' column in todo_list_users. Never null, always present for every user."}},"required":["id","email","created_at"],"description":"Summary (ISummary) DTO for listing user accounts. This schema is used when displaying user information in admin or audit contexts, such as paginated user lists. It includes only safe, non-sensitive, and business-critical fields: id, email, and created_at. Security: does not expose password hashes or internal fields.\n\nEvery property directly maps to core columns in todo_list_users, ensuring complete data integrity and privacy."},"ITodoListAdmin.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the admin record. This value is the primary key for the todo_list_admins table and is assigned automatically at creation. UUID format, never changes after creation.\n\nReferenced in administrative audit trails and security logs."},"email":{"type":"string","description":"Registered email for the admin account. Must be unique within todo_list_admins and is used for login and identification in all admin operations. Has format and uniqueness enforced through schema."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the admin account was created (UTC ISO 8601). Used for auditing and tracking admin onboarding dates. Sourced from the 'created_at' column of todo_list_admins."}},"required":["id","email","created_at"],"description":"Summary (ISummary) DTO for displaying minimal administrator account information, commonly used in paginated or search admin lists. Only essential fields are included (id, email, created_at)—internal fields such as password hash are partially or completely omitted for security. This summary exposes no sensitive credentials or system-only metadata.\n\nAll properties are direct mappings from the todo_list_admins schema, supporting transparent system management while preserving privacy."},"ITodoListTodo.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the Todo item. This is the primary key for todo_list_todos in the database schema, defined as a UUID.\n\nThis field is used to reference, update, or delete a specific Todo. It must never be reused or guessed and is automatically generated by the database upon creation. Used throughout the application as the unique handle for each task."},"title":{"type":"string","description":"The title or label of the Todo item. This is a short string representing the task description, limited to 100 characters and trimmed of whitespace according to business validation rules.\n\nThe title must be non-empty and concise to ensure rapid review by users. Invalid or long titles are rejected at the application layer. When presented in summary (list) views, this is the canonical field the user sees."},"is_completed":{"type":"boolean","description":"Indicates whether the Todo item has been marked as complete (true) or is still active/incomplete (false).\n\nThis status controls list display filters and determines whether the completed_at field is populated. Summarized views always show the completion status to allow users to quickly scan finished versus pending items."},"created_at":{"type":"string","format":"date-time","description":"The ISO 8601 UTC timestamp when the Todo was created in the system. This field is set automatically by the database/server and is used for sorting items in reverse-chronological order as per requirements.\n\nThis timestamp is essential for user audit trails and is always provided, ensuring consistent experience for chronological browsing."},"updated_at":{"type":"string","format":"date-time","description":"The ISO 8601 UTC timestamp for the latest time the Todo was modified (title or completion status was changed). Always applied and updated server-side, never directly editable by end users.\n\nThis is used for sorting or display purposes in some UI flows and for audit throughout the application."}},"required":["id","title","is_completed","created_at","updated_at"],"description":"Summary information about a single Todo task, suitable for list or overview views in a minimal Todo list application.\n\nThis schema corresponds directly to the todo_list_todos table in the database, providing only the essential properties needed to identify and render a Todo in list contexts. It intentionally omits detail or soft delete tracking. All properties are non-sensitive, public, and mapped 1:1 with the minimal entity fields required for the business function."}}}},"created_at":"2025-09-30T15:52:42.196Z","completed_at":"2025-09-30T16:07:29.949Z","step":0,"missed":[]},{"id":"01999b61-15a1-706b-8af7-e9b13de893ae","type":"userMessage","contents":[{"type":"text","text":"Make the e2e test functions."}],"created_at":"2025-09-30T16:07:35.073Z"},{"type":"test","id":"01999b68-d51d-77b8-b91d-2d256ffb4405","instruction":"Generate minimal E2E test suites that cover only the essential Todo list operations: creating a Todo item, retrieving all Todos, updating a Todo item, and deleting a Todo item. Focus on basic usage scenarios for each endpoint. Avoid tests for non-existent or advanced features.","files":[{"scenario":{"endpoint":{"path":"/auth/user/join","method":"post"},"draft":"Test the basic workflow for registering a new user. Ensure that providing a unique email and a valid password creates a new account and returns JWT tokens, enabling further Todo operations for this user. No additional information is required from the user beyond email and password. Verify token issuance and that user registration rejects repeat emails but allows clean registration with a new identity.","functionName":"test_api_user_registration_success","dependencies":[]},"location":"test/features/api/auth/test_api_user_registration_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test user registration workflow for the minimal Todo list app.\n *\n * This test exercises the user registration flow via POST /auth/user/join. It\n * verifies that a unique email and a strong password can register successfully\n * and that the returned value includes fully valid user and authentication\n * properties. It also checks that duplicate registration attempts fail with the\n * same email, but a new account can be created with a different email.\n *\n * 1. Generate a random, unique email and password.\n * 2. Register a user with those credentials; expect success.\n * 3. Validate that the result matches ITodoListUser.IAuthorized:\n *\n *    - Id is a UUID\n *    - Email matches input\n *    - Date fields are proper ISO strings\n *    - Token is an IAuthorizationToken with all required fields and proper formats\n * 4. Attempt to register again with the same email; expect failure.\n * 5. Register another account with a different unique email; expect success.\n */\nexport async function test_api_user_registration_success(\n  connection: api.IConnection,\n) {\n  // 1. Generate unique credentials\n  const uniqueEmail1 = typia.random<\n    string & tags.MaxLength<255> & tags.Format<\"email\">\n  >();\n  const password = RandomGenerator.alphaNumeric(12);\n\n  // 2. Register user (should succeed)\n  const authorized1 = await api.functional.auth.user.join(connection, {\n    body: {\n      email: uniqueEmail1,\n      password,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(authorized1);\n  TestValidator.equals(\n    \"registered email matches input\",\n    authorized1.email,\n    uniqueEmail1,\n  );\n\n  // 3. Verify ITodoListUser.IAuthorized structure\n  typia.assert<ITodoListUser.IAuthorized>(authorized1);\n  TestValidator.predicate(\n    \"authorized1.id is uuid\",\n    typeof authorized1.id === \"string\" && authorized1.id.length > 0,\n  );\n  TestValidator.predicate(\n    \"authorized1.created_at is ISO string\",\n    !isNaN(Date.parse(authorized1.created_at)),\n  );\n  TestValidator.predicate(\n    \"authorized1.updated_at is ISO string\",\n    !isNaN(Date.parse(authorized1.updated_at)),\n  );\n  typia.assert<IAuthorizationToken>(authorized1.token);\n  TestValidator.predicate(\n    \"token.access present\",\n    typeof authorized1.token.access === \"string\" &&\n      authorized1.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"token.refresh present\",\n    typeof authorized1.token.refresh === \"string\" &&\n      authorized1.token.refresh.length > 0,\n  );\n  TestValidator.predicate(\n    \"token.expired_at is ISO string\",\n    !isNaN(Date.parse(authorized1.token.expired_at)),\n  );\n  TestValidator.predicate(\n    \"token.refreshable_until is ISO string\",\n    !isNaN(Date.parse(authorized1.token.refreshable_until)),\n  );\n\n  // 4. Attempt duplicate registration (should fail)\n  await TestValidator.error(\n    \"registering with duplicate email fails\",\n    async () => {\n      await api.functional.auth.user.join(connection, {\n        body: {\n          email: uniqueEmail1,\n          password: RandomGenerator.alphaNumeric(12),\n        } satisfies ITodoListUser.IJoin,\n      });\n    },\n  );\n\n  // 5. Register with another unique email (should succeed)\n  const uniqueEmail2 = typia.random<\n    string & tags.MaxLength<255> & tags.Format<\"email\">\n  >();\n  const authorized2 = await api.functional.auth.user.join(connection, {\n    body: {\n      email: uniqueEmail2,\n      password: RandomGenerator.alphaNumeric(12),\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(authorized2);\n  TestValidator.equals(\n    \"second registered email matches input\",\n    authorized2.email,\n    uniqueEmail2,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/login","method":"post"},"draft":"Test administrator login by first registering a new admin account, then attempting to log in using the registered credentials. Verify that upon successful authentication, JWT tokens are issued, the response contains authorized admin identity, and that invalid credentials are rejected. This scenario validates the essential authentication workflow for administrators, ensuring that only credentials from a properly joined admin account are capable of receiving tokens and access. Also ensure no extra user fields are exposed in the response.","functionName":"test_api_admin_login_existing","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register a new admin to enable login with valid credentials"}]},"location":"test/features/api/auth/test_api_admin_login_existing.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validate admin login and authentication contract.\n *\n * This test will:\n *\n * 1. Register a new admin via POST /auth/admin/join using a unique email and\n *    strong password.\n * 2. Attempt login via POST /auth/admin/login with the same credentials, expecting\n *    a successful response matching ITodoListAdmin.IAuthorized (id, email,\n *    created_at, updated_at, token only).\n * 3. Validate the .token prop is present and matches IAuthorizationToken.\n * 4. Confirm that extra user fields (e.g. password, password_hash) are not\n *    returned.\n * 5. Attempt login with the same email but invalid password, expecting an error.\n *\n * This ensures the essential admin authentication workflow is correct and\n * contract is not leaky.\n */\nexport async function test_api_admin_login_existing(\n  connection: api.IConnection,\n) {\n  // Prepare unique admin credentials\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(12); // Strong password\n\n  // 1. Register new admin\n  const joinAdmin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email,\n      password,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(joinAdmin);\n  TestValidator.equals(\n    \"joined admin email matches input\",\n    joinAdmin.email,\n    email,\n  );\n\n  // 2. Login with correct credentials\n  const loginResp = await api.functional.auth.admin.login(connection, {\n    body: {\n      email,\n      password,\n    } satisfies ITodoListAdmin.ILogin,\n  });\n  typia.assert(loginResp);\n  TestValidator.equals(\"login email matches input\", loginResp.email, email);\n  TestValidator.equals(\"login id remains the same\", loginResp.id, joinAdmin.id);\n  TestValidator.equals(\"token is present\", typeof loginResp.token, \"object\");\n  typia.assert(loginResp.token);\n  // Ensure sensitive fields are not present\n  TestValidator.predicate(\n    \"response has only expected fields\",\n    () =>\n      Object.keys(loginResp).sort().join(\",\") ===\n      [\"created_at\", \"email\", \"id\", \"token\", \"updated_at\"].sort().join(\",\"),\n  );\n  // Ensure token has expected fields\n  TestValidator.predicate(\n    \"token has only expected fields\",\n    () =>\n      Object.keys(loginResp.token).sort().join(\",\") ===\n      [\"access\", \"expired_at\", \"refresh\", \"refreshable_until\"].sort().join(\",\"),\n  );\n\n  // 3. Login with invalid password\n  await TestValidator.error(\"login fails with wrong password\", async () => {\n    await api.functional.auth.admin.login(connection, {\n      body: {\n        email,\n        password: password + \"wrong\", // Invalid\n      } satisfies ITodoListAdmin.ILogin,\n    });\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/refresh","method":"post"},"draft":"Test administrator session renewal by registering a new admin, logging in to obtain the issued refresh token, and then using that token to request refreshed access/refresh tokens. Validate that refreshed tokens are issued on valid refresh token submission and access is denied for expired or invalid tokens. This verifies secure, seamless extension of admin sessions per JWT-based workflows with correct audit timestamp updates.","functionName":"test_api_admin_token_refresh_after_authentication","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register a new admin account for session refresh testing"}]},"location":"test/features/api/auth/test_api_admin_token_refresh_after_authentication.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Verify admin JWT refresh token lifecycle: registration, initial token\n * issuance, and chained refresh.\n *\n * 1. Register a new admin via /auth/admin/join (provides authorized object with\n *    refresh token).\n * 2. Use the refresh token to perform /auth/admin/refresh, ensuring a new set of\n *    tokens (access, refresh) are issued.\n * 3. Assert new tokens differ from the originals (to confirm effective refresh)\n *    and all expected fields are present.\n * 4. Optionally, attempt to refresh again with new refresh token to confirm\n *    repeatability (JWT session extension).\n * 5. Only success flow will be tested due to API/DTO constraints (error/expiry\n *    simulation not implemented).\n */\nexport async function test_api_admin_token_refresh_after_authentication(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin\n  const adminInput = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12), // minLength<8>\n  } satisfies ITodoListAdmin.ICreate;\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: adminInput,\n  });\n  typia.assert(admin);\n  TestValidator.equals(\"admin email matches\", admin.email, adminInput.email);\n\n  // 2. Use refresh token to refresh session\n  const refresh1 = await api.functional.auth.admin.refresh(connection, {\n    body: {\n      refresh_token: admin.token.refresh,\n    } satisfies ITodoListAdmin.IRefresh,\n  });\n  typia.assert(refresh1);\n  TestValidator.notEquals(\n    \"new token differs from original\",\n    refresh1.token.refresh,\n    admin.token.refresh,\n  );\n  TestValidator.notEquals(\n    \"new access differs from original\",\n    refresh1.token.access,\n    admin.token.access,\n  );\n  TestValidator.equals(\n    \"admin id remains same after refresh\",\n    refresh1.id,\n    admin.id,\n  );\n  TestValidator.equals(\n    \"admin email remains same after refresh\",\n    refresh1.email,\n    admin.email,\n  );\n\n  // 3. Chain refresh: use new refresh token to obtain fresh tokens again\n  const refresh2 = await api.functional.auth.admin.refresh(connection, {\n    body: {\n      refresh_token: refresh1.token.refresh,\n    } satisfies ITodoListAdmin.IRefresh,\n  });\n  typia.assert(refresh2);\n  TestValidator.notEquals(\n    \"refresh2 token differs from refresh1\",\n    refresh2.token.refresh,\n    refresh1.token.refresh,\n  );\n  TestValidator.notEquals(\n    \"refresh2 access differs from refresh1\",\n    refresh2.token.access,\n    refresh1.token.access,\n  );\n  TestValidator.equals(\n    \"admin id remains same on chained refresh\",\n    refresh2.id,\n    admin.id,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/users","method":"patch"},"draft":"Test that an authenticated administrator can retrieve a paginated and filtered list of user accounts, including search by email and paging controls. Ensure that the user list does not include sensitive fields such as password hashes, and validate correct paging, filtering, and sorting functionality. Confirm that unauthorized requests not authenticated as admin are rejected.","functionName":"test_api_admin_list_users_paging_and_search","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Authenticate as admin for access to the user list endpoint"}]},"location":"test/features/api/todo_list_admin/test_api_admin_list_users_paging_and_search.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListUser\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate the admin-only paginated and searchable user list endpoint with\n * various paging, email filter, and sort options, as well as access control\n * enforcement.\n *\n * 1. Register a new admin account\n * 2. List users as admin, retrieve first page\n * 3. List users as admin, request a specific limit\n * 4. List users as admin, search by random email substring (if any user exists)\n * 5. List users as admin, sort by email ascending and descending and by created_at\n *    ascending/descending\n * 6. Attempt to list users without authentication to verify access is forbidden\n */\nexport async function test_api_admin_list_users_paging_and_search(\n  connection: api.IConnection,\n) {\n  // 1. Register and login as new admin\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const admin: ITodoListAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password: RandomGenerator.alphaNumeric(12),\n      } satisfies ITodoListAdmin.ICreate,\n    });\n  typia.assert(admin);\n\n  // 2. List users as admin - default paging (should succeed)\n  const defaultRes: IPageITodoListUser.ISummary =\n    await api.functional.todoList.admin.users.index(connection, {\n      body: {},\n    });\n  typia.assert(defaultRes);\n  TestValidator.predicate(\n    \"response includes only safe user fields (id, email, created_at)\",\n    ArrayUtil.has(defaultRes.data, (user) => {\n      const keys = Object.keys(user ?? {});\n      // must include all three required, no more\n      return (\n        Array.isArray(keys) &&\n        keys.length === 3 &&\n        keys.includes(\"id\") &&\n        keys.includes(\"email\") &&\n        keys.includes(\"created_at\")\n      );\n    }),\n  );\n\n  // 3. List users with limit=2 (if >=2 users)\n  const limit = 2 as number & tags.Type<\"int32\">;\n  const pagedRes: IPageITodoListUser.ISummary =\n    await api.functional.todoList.admin.users.index(connection, {\n      body: { limit },\n    });\n  typia.assert(pagedRes);\n  if (pagedRes.data.length > limit) {\n    throw new Error(\"More users returned than limit\");\n  }\n\n  // 4. Search by email substring (if any user exists)\n  if (defaultRes.data.length > 0) {\n    const randomUser = RandomGenerator.pick(defaultRes.data);\n    const emailFragment = randomUser.email.substring(\n      1,\n      Math.max(2, randomUser.email.length - 1),\n    );\n    const filteredRes: IPageITodoListUser.ISummary =\n      await api.functional.todoList.admin.users.index(connection, {\n        body: { email: emailFragment },\n      });\n    typia.assert(filteredRes);\n    TestValidator.predicate(\n      \"each user matches filter email fragment\",\n      filteredRes.data.every((user) => user.email.includes(emailFragment)),\n    );\n  }\n\n  // 5. Test sort and order params\n  const sortFields = [\"email\", \"created_at\"] as const;\n  const orderDirs = [\"asc\", \"desc\"] as const;\n  for (const sort of sortFields) {\n    for (const order of orderDirs) {\n      const sortedRes: IPageITodoListUser.ISummary =\n        await api.functional.todoList.admin.users.index(connection, {\n          body: { sort, order },\n        });\n      typia.assert(sortedRes);\n      if (sortedRes.data.length > 1) {\n        const comp = (a: ITodoListUser.ISummary, b: ITodoListUser.ISummary) => {\n          if (sort === \"email\") {\n            return order === \"asc\"\n              ? a.email.localeCompare(b.email)\n              : b.email.localeCompare(a.email);\n          }\n          // sort === \"created_at\"\n          return order === \"asc\"\n            ? a.created_at.localeCompare(b.created_at)\n            : b.created_at.localeCompare(a.created_at);\n        };\n        for (let i = 1; i < sortedRes.data.length; ++i) {\n          TestValidator.predicate(\n            `users are sorted by ${sort} ${order}`,\n            comp(sortedRes.data[i - 1], sortedRes.data[i]) <= 0,\n          );\n        }\n      }\n    }\n  }\n\n  // 6. Test unauthenticated user (expect error)\n  const noAuthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\n    \"unauthenticated user forbidden from user list\",\n    async () => {\n      await api.functional.todoList.admin.users.index(noAuthConn, {\n        body: {},\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/users/{userId}","method":"get"},"draft":"Test that an authenticated administrator can view the profile and metadata details of any registered user by userId. Validate the returned data excludes sensitive information (like password hashes) and only includes valid schema fields. Confirm that the endpoint enforces access restrictions and returns a proper error for unauthorized requests or when the user does not exist.","functionName":"test_api_admin_retrieve_user_details","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Authenticate as admin for privileged access to user detail endpoint"}]},"location":"test/features/api/todo_list_admin/test_api_admin_retrieve_user_details.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test that an authenticated administrator can retrieve user details by userId,\n * receives only allowed schema fields (id, email, created_at, updated_at), and\n * error response for unauthorized or non-existent user scenarios.\n *\n * 1. Register a new admin and acquire authentication.\n * 2. Simulate presence of a user (by using a random userId) for not-found error or\n *    real one if such API is available.\n * 3. As admin, perform GET /todoList/admin/users/{userId}: expect ITodoListUser\n *    schema, typia.assert.\n * 4. As unauthorized/unauthenticated, try GET /todoList/admin/users/{userId}:\n *    expect error thrown.\n * 5. As admin, request non-existent userId: expect error thrown.\n */\nexport async function test_api_admin_retrieve_user_details(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin for privileged access\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const admin: ITodoListAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password: RandomGenerator.alphaNumeric(12),\n      } satisfies ITodoListAdmin.ICreate,\n    });\n  typia.assert(admin);\n\n  // Generate a fake/test user id (simulate non-existence)\n  const nonexistentUserId: string = typia.random<\n    string & tags.Format<\"uuid\">\n  >();\n\n  // 2. Try to fetch non-existent user: should return error (authenticated)\n  await TestValidator.error(\n    \"admin gets error for non-existent user\",\n    async () => {\n      await api.functional.todoList.admin.users.at(connection, {\n        userId: nonexistentUserId,\n      });\n    },\n  );\n\n  // 3. Attempt as unauthorized user: create connection with empty headers\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\n    \"unauthorized request to admin user details\",\n    async () => {\n      await api.functional.todoList.admin.users.at(unauthConn, {\n        userId: nonexistentUserId,\n      });\n    },\n  );\n\n  // 4. If we had a user registration API, we'd register a test user here, but since DTOs do not include user creation, skip to admin (simulate existing user fetch by reusing nonexistentUserId, expect error)\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/users/{userId}","method":"put"},"draft":"Test that an admin can update a user's email or password by userId using the admin update endpoint. The admin authenticates, updates the specified user's email and/or password hash, and receives the updated user record in response. Ensures business rules for unique email, proper password hashing, and timestamp management are honored.","functionName":"test_api_admin_user_update_basic","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Authenticate as admin to perform user updates"}]},"location":"test/features/api/todo_list_user/test_api_admin_user_update_basic.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test that an admin can update a user's email or password by userId using the\n * admin update endpoint.\n *\n * - Register a new admin via /auth/admin/join\n * - Create a random user (simulate DB insert via a direct API call or random\n *   entity if no public user API)\n * - Admin updates the user's email and checks for the update\n * - Admin updates the user's password (password_hash) and checks for the update\n * - Verify timestamps (updated_at changes)\n * - Test that updating to a duplicate email fails\n */\nexport async function test_api_admin_user_update_basic(\n  connection: api.IConnection,\n) {\n  // 1. Register as admin\n  const adminEmail: string & tags.Format<\"email\"> = typia.random<\n    string & tags.Format<\"email\">\n  >();\n  const adminPassword: string = RandomGenerator.alphaNumeric(12);\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPassword,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(admin);\n  // 2. Create a user to be updated (simulate or prepare fixture)\n  // As we have no user registration endpoint in the available API,\n  // we'll simulate an existing user record via typia.random\n  const existingUser: ITodoListUser = typia.random<ITodoListUser>();\n\n  // 3. Update the user's email by admin\n  const newEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const updateEmail = await api.functional.todoList.admin.users.update(\n    connection,\n    {\n      userId: existingUser.id,\n      body: {\n        email: newEmail,\n      } satisfies ITodoListUser.IUpdate,\n    },\n  );\n  typia.assert(updateEmail);\n  TestValidator.equals(\"user id must match\", updateEmail.id, existingUser.id);\n  TestValidator.equals(\"email updated\", updateEmail.email, newEmail);\n  TestValidator.predicate(\n    \"created_at unchanged after update\",\n    updateEmail.created_at === existingUser.created_at,\n  );\n  TestValidator.predicate(\n    \"updated_at changed after update\",\n    updateEmail.updated_at !== existingUser.updated_at,\n  );\n\n  // 4. Update the user's password_hash by admin\n  const newPasswordHash = RandomGenerator.alphaNumeric(32);\n  const updatePassword = await api.functional.todoList.admin.users.update(\n    connection,\n    {\n      userId: existingUser.id,\n      body: {\n        password_hash: newPasswordHash,\n      } satisfies ITodoListUser.IUpdate,\n    },\n  );\n  typia.assert(updatePassword);\n  TestValidator.equals(\n    \"user id remains for password update\",\n    updatePassword.id,\n    existingUser.id,\n  );\n  TestValidator.equals(\n    \"email stays as previous after non-email change\",\n    updatePassword.email,\n    newEmail,\n  );\n  TestValidator.predicate(\n    \"updated_at changed after password update\",\n    updatePassword.updated_at !== updateEmail.updated_at,\n  );\n\n  // 5. Try updating a user with a duplicate email (should error)\n  const anotherUser: ITodoListUser = typia.random<ITodoListUser>();\n  await TestValidator.error(\n    \"updating user to duplicate email should fail\",\n    async () => {\n      await api.functional.todoList.admin.users.update(connection, {\n        userId: anotherUser.id,\n        body: {\n          email: newEmail,\n        } satisfies ITodoListUser.IUpdate,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/users/{userId}","method":"delete"},"draft":"Test that an admin can delete a user and trigger the cascading removal of all their associated todos. The admin authenticates, deletes the specified user by userId, and verifies that both the user and all of their todos are permanently removed from the database.","functionName":"test_api_admin_user_delete_with_todos_cascade","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Authenticate as admin to perform user deletion"}]},"location":"test/features/api/todo_list_admin/test_api_admin_user_delete_with_todos_cascade.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Test that an admin can delete a user and trigger the cascading removal of all\n * their associated todos.\n *\n * Steps:\n *\n * 1. Register a new admin account to receive authentication tokens (using\n *    api.functional.auth.admin.join).\n * 2. Create a random userId (UUID) representing a user to be deleted (since user\n *    creation is outside the exposed API/DTO scope).\n * 3. As the authenticated admin, call the erase endpoint:\n *    api.functional.todoList.admin.users.erase({ userId }).\n * 4. Validate the operation completes without error. Since there are no\n *    endpoints/DTOs provided to validate user or todo existence, test will\n *    focus on authentication and endpoint flow.\n */\nexport async function test_api_admin_user_delete_with_todos_cascade(\n  connection: api.IConnection,\n) {\n  // 1. Register admin\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = typia.random<string & tags.MinLength<8>>();\n  const adminAuth = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPassword,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(adminAuth);\n\n  // 2. Prepare a userId (UUID) for deletion\n  const userId = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 3. As admin, delete the user\n  await api.functional.todoList.admin.users.erase(connection, { userId });\n\n  // 4. The absence of errors is the primary check due to limited API/DTO exposure\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/admins","method":"patch"},"draft":"Test that an authenticated admin can retrieve a paginated list of administrator accounts. Admin authenticates and requests the admin index endpoint, supplying optional filtering or pagination parameters, and verifies correct paginated listing of admin accounts is returned.","functionName":"test_api_admin_admins_index_pagination","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Authenticate as admin to view admin index"}]},"location":"test/features/api/todo_list_admin/test_api_admin_admins_index_pagination.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAdmin\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validate that an authenticated admin can retrieve a paginated list of admin\n * accounts.\n *\n * 1. Register a new admin using unique, random email and password.\n * 2. Issue several additional admins (to verify pagination and listing content\n *    order).\n * 3. Request the /todoList/admin/admins index endpoint as authenticated admin:\n *\n *    - Default pagination (no body, or empty body)\n *    - Custom page/limit\n *    - Filter by email (partial match)\n * 4. Validate returned data structure, fields, and pagination content makes sense.\n * 5. Logout or simulate as unauthenticated: request the endpoint to confirm\n *    forbidden access.\n */\nexport async function test_api_admin_admins_index_pagination(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin\n  const adminBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphabets(10),\n  } satisfies ITodoListAdmin.ICreate;\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: adminBody,\n  });\n  typia.assert(admin);\n\n  // 2. Create additional admins for pagination/variation\n  const admins = await ArrayUtil.asyncMap(\n    ArrayUtil.repeat(4, (i) => i),\n    async () => {\n      const body = {\n        email: typia.random<string & tags.Format<\"email\">>(),\n        password: RandomGenerator.alphabets(10),\n      } satisfies ITodoListAdmin.ICreate;\n      const created = await api.functional.auth.admin.join(connection, {\n        body,\n      });\n      typia.assert(created);\n      return created;\n    },\n  );\n\n  // 3. Request paginated admin list (default: page 1, limit 100)\n  const outDefault = await api.functional.todoList.admin.admins.index(\n    connection,\n    {\n      body: {} satisfies ITodoListAdmin.IRequest,\n    },\n  );\n  typia.assert(outDefault);\n  TestValidator.predicate(\n    \"should have at least one admin listed\",\n    outDefault.data.length > 0,\n  );\n  TestValidator.predicate(\n    \"pagination meta should match sum of admins count\",\n    outDefault.pagination.records >= admins.length + 1,\n  );\n\n  // 3b. Request admin list with custom page/limit\n  const outCustom = await api.functional.todoList.admin.admins.index(\n    connection,\n    {\n      body: { page: 1, limit: 2 } satisfies ITodoListAdmin.IRequest,\n    },\n  );\n  typia.assert(outCustom);\n  TestValidator.equals(\n    \"custom limit reflected in result\",\n    outCustom.pagination.limit,\n    2,\n  );\n\n  // 3c. Request with email filter (using the just-created admin's email substring)\n  const emailPartial = admin.email.substring(0, admin.email.indexOf(\"@\"));\n  const outFilter = await api.functional.todoList.admin.admins.index(\n    connection,\n    {\n      body: { email: emailPartial } satisfies ITodoListAdmin.IRequest,\n    },\n  );\n  typia.assert(outFilter);\n  TestValidator.predicate(\n    \"filtered result contains at least matching email\",\n    outFilter.data.some((summary) => summary.email.includes(emailPartial)),\n  );\n\n  // 4. Logout: simulate request as unauthenticated (new connection w/o headers)\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\n    \"should reject unauthenticated access\",\n    async () => {\n      await api.functional.todoList.admin.admins.index(unauthConn, {\n        body: {} satisfies ITodoListAdmin.IRequest,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/admins/{adminId}","method":"get"},"draft":"Test that an admin can retrieve detailed metadata of a specific administrator by adminId. The admin authenticates, ensures an admin account exists (by creating an admin Todo which returns an adminId), then fetches the profile with the get endpoint and validates all expected fields are present.","functionName":"test_api_admin_get_admin_by_id","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Authenticate as admin to allow admin detail retrieval"},{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"purpose":"Create an admin Todo to obtain a valid adminId for profile retrieval"}]},"location":"test/features/api/admin/test_api_admin_get_admin_by_id.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\n\n/**\n * Validate that an admin can retrieve their detailed profile by adminId.\n *\n * Steps:\n *\n * 1. Register a new admin user (store resulting id, email, etc.).\n * 2. Ensure authentication as this admin (token is handled by join).\n * 3. Create a Todo as the admin to confirm setup.\n * 4. Retrieve the admin profile using the /todoList/admin/admins/{adminId}\n *    endpoint with own id.\n * 5. Validate all required ITodoListAdmin fields are present with expected\n *    types/formats.\n * 6. Match the returned admin data against registration values for consistency.\n */\nexport async function test_api_admin_get_admin_by_id(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin, returns IAuthorized (id, email, timestamps, token)\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const password: string & tags.MinLength<8> = RandomGenerator.alphaNumeric(12);\n  const joinResult = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password: password,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(joinResult);\n\n  // 2. (join already set the admin's access token in connection)\n\n  // 3. Create a Todo as this admin (to simulate activity; not strictly required)\n  const todo = await api.functional.todoList.admin.todos.create(connection, {\n    body: {\n      title: RandomGenerator.paragraph({\n        sentences: 2,\n        wordMin: 3,\n        wordMax: 9,\n      }),\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo);\n\n  // 4. Retrieve admin profile with their id\n  const result = await api.functional.todoList.admin.admins.at(connection, {\n    adminId: joinResult.id,\n  });\n  typia.assert(result);\n\n  // 5. Validate all fields and format constraints\n  TestValidator.equals(\"admin id matches\", result.id, joinResult.id);\n  TestValidator.equals(\"admin email matches\", result.email, joinResult.email);\n  TestValidator.equals(\n    \"created_at matches\",\n    result.created_at,\n    joinResult.created_at,\n  );\n  TestValidator.equals(\n    \"updated_at matches\",\n    result.updated_at,\n    joinResult.updated_at,\n  );\n  // Check format using typia.assert ensures all constraints, nothing more needed\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/todos/{todoId}","method":"put"},"draft":"Checks that an admin can update any Todo item, covering both title and completion status changes. Follows the entire setup flow by registering as admin, creating a Todo item as admin, updating the item, and observing that the updates are persisted. Confirms that admin permissions allow updating any Todo and that the schema constraints are enforced.","functionName":"test_api_todo_update_by_admin","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register and authenticate a new admin to allow privileged Todo operations."},{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"purpose":"Create a Todo item as an admin to later update."}]},"location":"test/features/api/todo_list/test_api_todo_update_by_admin.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\n\n/**\n * Validate that an admin can update any Todo item, changing both the title and\n * completion status.\n *\n * 1. Register new admin\n * 2. Create a Todo as admin\n * 3. Update the Todo by changing both its title and is_completed status\n * 4. Validate update result: title and is_completed have changed, schema\n *    constraints are preserved.\n */\nexport async function test_api_todo_update_by_admin(\n  connection: api.IConnection,\n) {\n  // 1. Register new admin\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = typia.random<string & tags.MinLength<8>>();\n  const adminAuth: ITodoListAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password: adminPassword,\n      } satisfies ITodoListAdmin.ICreate,\n    });\n  typia.assert(adminAuth);\n\n  // 2. Create a Todo as admin\n  const createTitle = RandomGenerator.paragraph({\n    sentences: 3,\n    wordMin: 2,\n    wordMax: 10,\n  });\n  const createdTodo: ITodoListTodo =\n    await api.functional.todoList.admin.todos.create(connection, {\n      body: {\n        title: createTitle,\n      } satisfies ITodoListTodo.ICreate,\n    });\n  typia.assert(createdTodo);\n\n  // 3. Update the Todo by changing both its title and is_completed status\n  const updateTitle = RandomGenerator.paragraph({\n    sentences: 4,\n    wordMin: 2,\n    wordMax: 10,\n  });\n  const updatedTodo: ITodoListTodo =\n    await api.functional.todoList.admin.todos.update(connection, {\n      todoId: createdTodo.id,\n      body: {\n        title: updateTitle,\n        is_completed: true,\n      } satisfies ITodoListTodo.IUpdate,\n    });\n  typia.assert(updatedTodo);\n\n  // 4. Validate update result: title and is_completed have changed, schema constraints are preserved.\n  TestValidator.equals(\"updated title applied\", updatedTodo.title, updateTitle);\n  TestValidator.equals(\n    \"updated is_completed is true\",\n    updatedTodo.is_completed,\n    true,\n  );\n  TestValidator.notEquals(\n    \"updated_at changed after update\",\n    updatedTodo.updated_at,\n    createdTodo.updated_at,\n  );\n  TestValidator.predicate(\n    \"title max length enforced\",\n    updatedTodo.title.length <= 100,\n  );\n  TestValidator.predicate(\n    \"created_at not changed after update\",\n    updatedTodo.created_at === createdTodo.created_at,\n  );\n  TestValidator.predicate(\n    \"admin can modify any Todo\",\n    updatedTodo.todo_list_user_id === createdTodo.todo_list_user_id,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/todos/{todoId}","method":"delete"},"draft":"Verifies that an admin can delete any Todo item in the system. The scenario starts with admin registration, Todo creation by that admin, deletion by admin, and confirms the item is no longer accessible. Reinforces system expectations about the admin's ability to manage and delete all Todo entries.","functionName":"test_api_todo_delete_by_admin","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register and authenticate an admin for privileged Todo operations."},{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"purpose":"Create a Todo item as admin to prepare for deletion."}]},"location":"test/features/api/todo/test_api_todo_delete_by_admin.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\n\n/**\n * Verifies that an admin can delete any Todo item in the system.\n *\n * 1. Register an admin\n * 2. Admin creates a Todo item\n * 3. Admin deletes the created Todo item\n * 4. Attempt to delete the same Todo item again and check error\n *\n * Business rules:\n *\n * - Admins must have privileged access to create and delete Todo entries\n * - After deletion, the Todo should no longer exist\n */\nexport async function test_api_todo_delete_by_admin(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = RandomGenerator.alphaNumeric(12);\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPassword,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(admin);\n\n  // 2. Admin creates a new Todo\n  const todo = await api.functional.todoList.admin.todos.create(connection, {\n    body: {\n      title: RandomGenerator.paragraph({ sentences: 3 }),\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo);\n\n  // 3. Admin deletes the Todo\n  await api.functional.todoList.admin.todos.erase(connection, {\n    todoId: todo.id,\n  });\n\n  // 4. After deletion, further attempts throw errors (negative test)\n  await TestValidator.error(\n    \"deleting already-deleted Todo should fail\",\n    async () => {\n      await api.functional.todoList.admin.todos.erase(connection, {\n        todoId: todo.id,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/admins/{adminId}","method":"put"},"draft":"Test updating an administrator's profile details (such as changing the email or password hash) as an authenticated admin user. Steps: 1) Register a new admin account using join; 2) Create a Todo as the new admin (to fulfill prerequisite for having an adminId with activity); 3) Update the admin's profile details using the PUT endpoint. Verifies successful metadata update and audit timestamp change.","functionName":"test_api_admin_profile_update_success","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create and authenticate as admin for updating the profile."},{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"purpose":"Generate an admin entity with a valid adminId (required for referencing the admin to update)."}]},"location":"test/features/api/todo_list_admin/test_api_admin_profile_update_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\n\n/**\n * Test updating an admin's profile (email) after registering and creating a\n * Todo item.\n *\n * Steps:\n *\n * 1. Register a new admin and obtain id/token (join).\n * 2. As this admin, create a Todo (to ensure valid adminId via activity).\n * 3. Update admin profile's email via PUT (adminId, new email).\n * 4. Validate id is unchanged, email is updated, created_at is unchanged,\n *    updated_at is updated.\n */\nexport async function test_api_admin_profile_update_success(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin\n  const email1 = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(12);\n  const authorized = await api.functional.auth.admin.join(connection, {\n    body: { email: email1, password } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(authorized);\n\n  // 2. Create a Todo as this admin (to make adminId usable)\n  const todo = await api.functional.todoList.admin.todos.create(connection, {\n    body: {\n      title: RandomGenerator.paragraph({ sentences: 3 }),\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo);\n  TestValidator.equals(\n    \"admin id matches on todo\",\n    todo.todo_list_user_id,\n    authorized.id,\n  );\n\n  // 3. Update profile (change email)\n  const email2 = typia.random<string & tags.Format<\"email\">>();\n  const result = await api.functional.todoList.admin.admins.update(connection, {\n    adminId: authorized.id,\n    body: { email: email2 } satisfies ITodoListAdmin.IUpdate,\n  });\n  typia.assert(result);\n\n  // 4. Validate expected changes\n  TestValidator.equals(\"admin id unchanged\", result.id, authorized.id);\n  TestValidator.equals(\"email updated\", result.email, email2);\n  TestValidator.equals(\n    \"created at unchanged\",\n    result.created_at,\n    authorized.created_at,\n  );\n  TestValidator.notEquals(\n    \"updated_at refreshed\",\n    result.updated_at,\n    authorized.updated_at,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/admins/{adminId}","method":"delete"},"draft":"Test deleting an administrator account as an authenticated admin user. Steps: 1) Register and authenticate a new admin; 2) Create a Todo as the new admin to ensure the adminId exists for deletion; 3) Delete the admin profile using the DELETE endpoint. Validate that the admin record is permanently deleted and access to this adminId fails afterward.","functionName":"test_api_admin_delete_account_success","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register and authenticate as admin for deletion rights."},{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"purpose":"Generate a valid adminId by creating an admin-owned todo (needed for DELETE operation)."}]},"location":"test/features/api/todo_list_admin/test_api_admin_delete_account_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\n\n/**\n * Validate permanent admin account deletion in the Todo list minimal API.\n *\n * This test covers the full workflow of registering a new admin, creating a\n * Todo as admin, deleting the admin, and confirming that access is revoked.\n *\n * Steps:\n *\n * 1. Register a new admin (generate a unique email and a valid strong password).\n * 2. On successful join, obtain the IAuthorized payload and extract the adminId.\n * 3. As the authenticated admin, create a Todo (minimal required: random valid\n *    title).\n * 4. Call the erase endpoint to delete the admin (using adminId).\n * 5. Try creating another Todo as the deleted admin, expect failure\n *    (TestValidator.error must confirm the account is gone and can't be used).\n */\nexport async function test_api_admin_delete_account_success(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin\n  const adminCreateBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12),\n  } satisfies ITodoListAdmin.ICreate;\n  const adminAuth = await api.functional.auth.admin.join(connection, {\n    body: adminCreateBody,\n  });\n  typia.assert(adminAuth);\n\n  // 2. Extract adminId for deletion\n  const adminId = adminAuth.id;\n\n  // 3. Create a Todo as the admin\n  const todo = await api.functional.todoList.admin.todos.create(connection, {\n    body: {\n      title: RandomGenerator.paragraph({\n        sentences: 3,\n        wordMin: 3,\n        wordMax: 10,\n      }),\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo);\n  TestValidator.equals(\n    \"Todo is owned by admin\",\n    todo.todo_list_user_id,\n    adminId,\n  );\n\n  // 4. Delete the admin\n  await api.functional.todoList.admin.admins.erase(connection, {\n    adminId,\n  });\n\n  // 5. Further operations with this admin (now deleted) must fail\n  await TestValidator.error(\n    \"Deleted admin cannot create Todo anymore\",\n    async () => {\n      await api.functional.todoList.admin.todos.create(connection, {\n        body: {\n          title: RandomGenerator.paragraph({\n            sentences: 3,\n            wordMin: 3,\n            wordMax: 10,\n          }),\n        } satisfies ITodoListTodo.ICreate,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/todos","method":"patch"},"draft":"Test retrieving a paginated list of Todo items as an authenticated admin. Steps: 1) Register an admin using join; 2) Create a Todo as the admin; 3) Retrieve the Todo list via admin PATCH endpoint. Verifies admin receives todos including those owned by self or (if other users exist) others.","functionName":"test_api_admin_todo_list_retrieval","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register and authenticate as admin for accessing all todos."},{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"purpose":"Create a Todo as admin to be visible in results."},{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/admin/join) must be executed before any operations requiring 'admin' role authorization. \nIt establishes the necessary user account and authentication context for the 'admin' role, enabling subsequent API calls that depend on this specific authorization level. \nWithout this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/todo_list/test_api_admin_todo_list_retrieval.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\n\n/**\n * Minimal E2E test: Admin registration, create todo, retrieve todo list as\n * admin\n *\n * 1. Register an admin using /auth/admin/join and store credentials\n * 2. Create a Todo as the authenticated admin using /todoList/admin/todos (POST)\n * 3. Retrieve the paginated list of Todos with /todoList/admin/todos (PATCH) as\n *    admin\n * 4. Assert the created Todo appears in the paginated result set\n */\nexport async function test_api_admin_todo_list_retrieval(\n  connection: api.IConnection,\n) {\n  // 1. Admin registration\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = RandomGenerator.alphaNumeric(12);\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPassword,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(admin);\n\n  // 2. Create a Todo as admin\n  const title = RandomGenerator.paragraph({\n    sentences: 1,\n    wordMin: 3,\n    wordMax: 10,\n  });\n  const todo = await api.functional.todoList.admin.todos.create(connection, {\n    body: {\n      title,\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo);\n\n  // 3. Retrieve the paginated Todo list as admin\n  const page = await api.functional.todoList.admin.todos.index(connection, {\n    body: {}, // minimal request; all parameters optional\n  });\n  typia.assert(page);\n\n  // 4. Assert created Todo is present in paginated admin view\n  const found = page.data.find((t) => t.id === todo.id);\n  TestValidator.predicate(\n    \"created Todo appears in admin-retrieved list\",\n    found !== undefined,\n  );\n  if (found) {\n    TestValidator.equals(\"Todo title matches\", found.title, title);\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/login","method":"post"},"draft":"Test user login by verifying that a previously registered user can authenticate successfully with correct credentials and receive JWT access and refresh tokens. The scenario includes registering a new user and then performing login. Verifies token issuance and correct update to last activity timestamp.","functionName":"test_api_user_login_success","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register a new user so valid login credentials are available"}]},"location":"test/features/api/auth/test_api_user_login_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate the user login authentication flow for the minimal Todo app.\n *\n * This test ensures that a new user can join (register) successfully and then\n * log in immediately using the same credentials. Upon successful login, it\n * asserts that valid JWT access/refresh tokens are issued, the returned\n * structure matches ITodoListUser.IAuthorized, and the account's updated_at\n * timestamp is changed on login (demonstrating last login/update tracking by\n * the backend).\n *\n * Test steps:\n *\n * 1. Register a new user account with random email/password\n * 2. Attempt login with the same credentials\n * 3. Assert tokens are present and valid structure\n * 4. Assert 'updated_at' has changed between registration and login, confirming\n *    login is tracked\n */\nexport async function test_api_user_login_success(connection: api.IConnection) {\n  // 1. Register a new user account\n  const joinInput = typia.random<ITodoListUser.IJoin>();\n  const joinResult: ITodoListUser.IAuthorized =\n    await api.functional.auth.user.join(connection, { body: joinInput });\n  typia.assert(joinResult);\n  // 2. Login with same credentials\n  const loginResult: ITodoListUser.IAuthorized =\n    await api.functional.auth.user.login(connection, { body: joinInput });\n  typia.assert(loginResult);\n  // 3. Assert tokens and structure\n  TestValidator.predicate(\n    \"access token present\",\n    typeof loginResult.token.access === \"string\" &&\n      loginResult.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"refresh token present\",\n    typeof loginResult.token.refresh === \"string\" &&\n      loginResult.token.refresh.length > 0,\n  );\n  typia.assert<IAuthorizationToken>(loginResult.token);\n  // 4. Assert updated_at is changed between join and login\n  TestValidator.notEquals(\n    \"updated_at changed after login\",\n    loginResult.updated_at,\n    joinResult.updated_at,\n  );\n  // 5. Assert core user fields did not change\n  TestValidator.equals(\"user id stable\", loginResult.id, joinResult.id);\n  TestValidator.equals(\n    \"user email stable\",\n    loginResult.email,\n    joinResult.email,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/refresh","method":"post"},"draft":"Test that providing an invalid or expired refresh token results in a refresh failure. No tokens are issued and an authentication error is returned. The sequence involves registration, login, and then the refresh attempt using an invalid/modified token string.","functionName":"test_api_user_token_refresh_invalid_token","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register a new user account for refresh scenario"},{"endpoint":{"path":"/auth/user/login","method":"post"},"purpose":"Log in the user to obtain refresh token before using an invalid/modified token"}]},"location":"test/features/api/auth/test_api_user_token_refresh_invalid_token.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate that authentication refresh fails with an invalid (tampered) refresh\n * token.\n *\n * 1. Register a new user via /auth/user/join.\n * 2. Log in with the new user credentials via /auth/user/login to receive a valid\n *    refresh token.\n * 3. Modify the refresh token so it becomes clearly invalid (e.g., drop several\n *    characters or append garbage).\n * 4. Attempt to refresh with the invalid refresh token via /auth/user/refresh.\n * 5. Assert that the refresh attempt fails (i.e., error is thrown and no new\n *    tokens are issued).\n */\nexport async function test_api_user_token_refresh_invalid_token(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user\n  const email = `${RandomGenerator.alphabets(8)}@test.com`;\n  const password = RandomGenerator.alphaNumeric(12);\n  const userAuth = await api.functional.auth.user.join(connection, {\n    body: {\n      email,\n      password,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(userAuth);\n\n  // 2. Log in with the new user credentials\n  const loginAuth = await api.functional.auth.user.login(connection, {\n    body: {\n      email,\n      password,\n    } satisfies ITodoListUser.ILogin,\n  });\n  typia.assert(loginAuth);\n  const refreshToken = loginAuth.token.refresh;\n\n  // 3. Modify the refresh token\n  const invalidRefreshToken =\n    refreshToken.slice(0, Math.floor(refreshToken.length / 2)) + \"_INVALID\";\n\n  // 4. Attempt to refresh with the invalid token. Should fail.\n  await TestValidator.error(\n    \"refresh with invalid refresh token triggers auth failure\",\n    async () => {\n      await api.functional.auth.user.refresh(connection, {\n        body: {\n          refresh_token: invalidRefreshToken,\n        } satisfies ITodoListUser.IRefresh,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/join","method":"post"},"draft":"Test that a new admin can register with a unique email and valid password hash. Verifies issuance of admin authentication tokens and successful creation of account in the admin table. Validates minimal onboarding flow is properly supported for admins.","functionName":"test_api_admin_registration","dependencies":[]},"location":"test/features/api/auth/test_api_admin_registration.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\n\n/**\n * Validate the registration of a new Todo List admin using minimal required\n * onboarding fields.\n *\n * This test ensures a new admin can be created by providing a unique email and\n * a password that satisfies minimum strength (at least 8 characters). It\n * verifies that the /auth/admin/join endpoint returns a properly shaped\n * IAuthorized response containing:\n *\n * - A UUID id\n * - The same unique email as used in registration\n * - Created_at and updated_at as ISO 8601 timestamps\n * - A token object with both access and refresh JWTs, and correct expiration\n *   fields The response and all nested fields are validated using typia.assert,\n *   confirming strict compliance with authentication and business onboarding\n *   contracts. The test does NOT check error flows (such as duplicate\n *   registration or short passwords) as only the minimal valid registration\n *   scenario is required.\n */\nexport async function test_api_admin_registration(connection: api.IConnection) {\n  // Generate email and password according to DTO constraints\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(10); // minLength<8>\n\n  // Attempt registration\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email,\n      password,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  // Full type validation\n  typia.assert(admin);\n\n  // Business property checks\n  TestValidator.equals(\"returned email matches input\", admin.email, email);\n  TestValidator.predicate(\n    \"admin id is valid UUID\",\n    typeof admin.id === \"string\" && admin.id.length === 36,\n  );\n  TestValidator.predicate(\n    \"created_at is ISO string\",\n    /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z/.test(admin.created_at),\n  );\n  TestValidator.predicate(\n    \"updated_at is ISO string\",\n    /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z/.test(admin.updated_at),\n  );\n  // Token fields are non-empty\n  TestValidator.predicate(\n    \"access token exists\",\n    typeof admin.token.access === \"string\" && admin.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"refresh token exists\",\n    typeof admin.token.refresh === \"string\" && admin.token.refresh.length > 0,\n  );\n  TestValidator.predicate(\n    \"expired_at is ISO string\",\n    /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z/.test(admin.token.expired_at),\n  );\n  TestValidator.predicate(\n    \"refreshable_until is ISO string\",\n    /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z/.test(\n      admin.token.refreshable_until,\n    ),\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"draft":"Test minimal Todo item creation flow by an authenticated admin. Scenario: 1) Register a new admin account using /auth/admin/join; 2) Use issued token to create a Todo item via POST /todoList/admin/todos with a simple, valid title; 3) Assert the created Todo returns correct fields (id, title, timestamps, is_completed=false, owner is admin). This covers basic creation for admin usage.","functionName":"test_api_admin_todo_creation_basic","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register and authenticate as admin for authorized Todo creation"}]},"location":"test/features/api/todo_list/test_api_admin_todo_creation_basic.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\n\n/**\n * Minimal E2E test for admin Todo creation in a Todo List application.\n *\n * This test covers only the bare essential scenario:\n *\n * 1. Register a new admin using /auth/admin/join with a unique email/password\n * 2. Use the received admin authentication (token is set by SDK)\n * 3. Create a Todo item via POST /todoList/admin/todos with a valid short title\n * 4. Validate the created Todo has correct fields:\n *\n *    - Id and todo_list_user_id are UUIDs and todo_list_user_id matches admin's id\n *    - Title is as supplied\n *    - Is_completed is false\n *    - Timestamps (created_at, updated_at) are present and valid ISO strings\n *    - Completed_at and deleted_at are null or undefined\n */\nexport async function test_api_admin_todo_creation_basic(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword: string = typia.random<string & tags.MinLength<8>>();\n\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPassword,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(admin);\n\n  // 2. Create a Todo as the authenticated admin\n  const todoTitle: string = RandomGenerator.paragraph({\n    sentences: 1,\n    wordMin: 4,\n    wordMax: 10,\n  });\n  const newTodo = await api.functional.todoList.admin.todos.create(connection, {\n    body: {\n      title: todoTitle,\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(newTodo);\n\n  // 3. Validate created Todo fields\n  TestValidator.equals(\n    \"todo_list_user_id matches admin id\",\n    newTodo.todo_list_user_id,\n    admin.id,\n  );\n  TestValidator.equals(\"title matches input\", newTodo.title, todoTitle);\n  TestValidator.equals(\"is_completed is false\", newTodo.is_completed, false);\n  TestValidator.predicate(\n    \"id, created_at, updated_at are non-empty\",\n    Boolean(newTodo.id) &&\n      Boolean(newTodo.created_at) &&\n      Boolean(newTodo.updated_at),\n  );\n  TestValidator.equals(\n    \"completed_at is null or undefined\",\n    newTodo.completed_at,\n    null,\n  );\n  TestValidator.equals(\n    \"deleted_at is null or undefined\",\n    newTodo.deleted_at,\n    null,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/admin/todos/{todoId}","method":"get"},"draft":"Test that an admin can retrieve details of a Todo item they created. Scenario: 1) Register a new admin account; 2) Create a Todo item as admin via POST /todoList/admin/todos; 3) Retrieve that Todo by its id via GET /todoList/admin/todos/{todoId} and verify output matches the created Todo (id, title, timestamps, completion state, linked to admin).","functionName":"test_api_admin_todo_retrieval_by_id","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Register and authenticate as admin before any operation"},{"endpoint":{"path":"/todoList/admin/todos","method":"post"},"purpose":"Create a Todo to be retrieved by id"}]},"location":"test/features/api/todo_list_todo/test_api_admin_todo_retrieval_by_id.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\n\n/**\n * Validate admin can retrieve their own created Todo item by id.\n *\n * 1. Register a new admin by calling api.functional.auth.admin.join with a unique,\n *    valid email and strong password (randomized each run).\n * 2. Create a Todo as that admin, using api.functional.todoList.admin.todos.create\n *    (provide valid random title).\n * 3. Retrieve the Todo by id using api.functional.todoList.admin.todos.at (the id\n *    from step 2).\n * 4. Assert via TestValidator.equals that key fields match: id, title, created_at,\n *    is_completed, updated_at, todo_list_user_id. Confirm ownership is the\n *    current admin user id and is_completed is false upon creation. Validate\n *    all types/objects with typia.assert. The test ends here, as deletion or\n *    update is not in scope.\n */\nexport async function test_api_admin_todo_retrieval_by_id(\n  connection: api.IConnection,\n) {\n  // 1. Register a new admin (unique email and strong password)\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = RandomGenerator.alphaNumeric(12);\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password: adminPassword,\n    } satisfies ITodoListAdmin.ICreate,\n  });\n  typia.assert(admin);\n\n  // 2. Create a Todo item as this admin\n  const todoTitle = RandomGenerator.paragraph({\n    sentences: 3,\n    wordMin: 4,\n    wordMax: 10,\n  });\n  const createdTodo = await api.functional.todoList.admin.todos.create(\n    connection,\n    {\n      body: { title: todoTitle } satisfies ITodoListTodo.ICreate,\n    },\n  );\n  typia.assert(createdTodo);\n\n  // 3. Retrieve the Todo by id\n  const retrievedTodo = await api.functional.todoList.admin.todos.at(\n    connection,\n    {\n      todoId: createdTodo.id,\n    },\n  );\n  typia.assert(retrievedTodo);\n\n  // 4. Assert essential fields\n  TestValidator.equals(\n    \"retrieved id matches created\",\n    retrievedTodo.id,\n    createdTodo.id,\n  );\n  TestValidator.equals(\n    \"retrieved title matches\",\n    retrievedTodo.title,\n    createdTodo.title,\n  );\n  TestValidator.equals(\n    \"retrieved user id matches admin id\",\n    retrievedTodo.todo_list_user_id,\n    admin.id,\n  );\n  TestValidator.equals(\n    \"is_completed is false on creation\",\n    retrievedTodo.is_completed,\n    false,\n  );\n  // Assert created_at/updated_at equality via string comparison\n  TestValidator.equals(\n    \"created_at matches\",\n    retrievedTodo.created_at,\n    createdTodo.created_at,\n  );\n  TestValidator.equals(\n    \"updated_at matches\",\n    retrievedTodo.updated_at,\n    createdTodo.updated_at,\n  );\n  // Optionally, confirm completed_at and deleted_at are missing or null\n  TestValidator.equals(\n    \"completed_at is null on creation\",\n    retrievedTodo.completed_at,\n    null,\n  );\n  TestValidator.equals(\n    \"deleted_at is null on creation\",\n    retrievedTodo.deleted_at,\n    null,\n  );\n}\n"}],"compiled":{"type":"success"},"created_at":"2025-09-30T16:07:40.622Z","completed_at":"2025-09-30T16:16:02.845Z","step":0},{"id":"0199a386-28bb-7759-b69b-63c93ac33792","type":"userMessage","contents":[{"type":"text","text":"Implement API functions."}],"created_at":"2025-10-02T06:05:02.523Z"},{"type":"realize","id":"0199a38d-a24b-77f8-a953-b93b5d6b3f5a","instruction":"Implement the actual business logic for each minimal Todo list API endpoint. Ensure that each function (create, list, update, delete Todo) follows the simplest and most direct logic possible, focusing on correctness and reliability. Do not add extra features or logic beyond what is necessary for a basic Todo app.","authorizations":[{"error_analysis":"MyGlobal.ts fails due to missing './MyConfiguration'; unrelated to provider/decorator. userAuthorize and UserAuth code is structurally sound and import paths are correct. No TypeScript errors found with decorator/provider code according to provided snippets.","solution_guidance":"MyGlobal.ts requires './MyConfiguration' to exist, which is unrelated to the provider/decorator. No changes required for userAuthorize or UserAuth. Ensure that './MyConfiguration' is present or stub its export. Provider and Decorator adhere to conventions and Prisma model mapping.","provider":{"name":"userAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { UserPayload } from \"../../decorators/payload/UserPayload\";\n\n/**\n * Authenticate and authorize a regular user account via JWT.\n *\n * @param request - Incoming HTTP request object\n * @returns The decoded UserPayload if JWT and database checks pass\n * @throws ForbiddenException if role/type mismatch or user does not exist\n */\nexport async function userAuthorize(request: {\n  headers: {\n    authorization?: string;\n  };\n}): Promise<UserPayload> {\n  const payload: UserPayload = jwtAuthorize({ request }) as UserPayload;\n\n  if (payload.type !== \"user\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // Check if the user exists in the database\n  const user = await MyGlobal.prisma.todo_list_users.findFirst({\n    where: {\n      id: payload.id,\n    },\n  });\n\n  if (user === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/userAuthorize.ts"},"decorator":{"name":"UserAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { userAuthorize } from \"../providers/authorize/userAuthorize\";\n\n/**\n * Decorator to automatically inject authenticated UserPayload into controller methods.\n * Attaches Bearer token security schema in Swagger documentation.\n */\nexport const UserAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return userAuthorize(request);\n  })(),\n);\n","location":"src/decorators/UserAuth.ts"},"payload":{"name":"UserPayload","location":"src/decorators/payload/UserPayload.ts","content":"import { tags } from \"typia\";\n\n/**\n * Authenticated payload for a regular user.\n *\n * - Id: Top-level user ID (todo_list_users.id)\n * - Type: Always 'user'\n */\nexport interface UserPayload {\n  /** Unique identifier for the user account (todo_list_users.id) */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the user role */\n  type: \"user\";\n}\n"},"role":{"name":"user","description":"A registered user who can log in, log out, and manage their own personal todo list, but cannot access or modify other users’ data. Can create, update, mark as complete/incomplete, and delete their own tasks.","kind":"member"}},{"error_analysis":"Provider and decorator compile, but Prisma admin table is 'todo_list_admins' (not 'admins'). Also, ensure import paths align with project file structure; review adminAuthorize database field usage. No issues in payload. Minor doc and naming must match schema.","solution_guidance":"Update provider: change DB table from 'admins' to 'todo_list_admins' in prisma query, keep where: { id: payload.id }. Review import paths to confirm './jwtAuthorize' and other imports are correct relative paths. Decorator: verify import for provider matches directory and naming. No payload changes. No unnecessary property inventions.","provider":{"name":"adminAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { AdminPayload } from \"../../decorators/payload/AdminPayload\";\n\n/**\n * Authenticate and authorize an administrator based on JWT and DB presence.\n *\n * @param request - Express HTTP request containing headers\n * @returns AdminPayload if authentication and authorization are valid\n * @throws ForbiddenException if not an admin or not enrolled\n */\nexport async function adminAuthorize(request: {\n  headers: {\n    authorization?: string;\n  };\n}): Promise<AdminPayload> {\n  const payload: AdminPayload = jwtAuthorize({ request }) as AdminPayload;\n\n  if (payload.type !== \"admin\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // Validate admin existence - admin is standalone (id = payload.id)\n  const admin = await MyGlobal.prisma.todo_list_admins.findFirst({\n    where: {\n      id: payload.id,\n    },\n  });\n  if (admin === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/adminAuthorize.ts"},"decorator":{"name":"AdminAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { adminAuthorize } from \"../providers/authorize/adminAuthorize\";\n\n/**\n * Parameter decorator for administrator JWT authentication.\n *\n * Usage: `@AdminAuth() admin: AdminPayload`\n */\nexport const AdminAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_0: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return adminAuthorize(request);\n  })(),\n);","location":"src/decorators/AdminAuth.ts"},"payload":{"name":"AdminPayload","location":"src/decorators/payload/AdminPayload.ts","content":"import { tags } from \"typia\";\n\n/**\n * JWT payload for administrator authentication.\n *\n * - Id: administrator's table id (UUID, standalone admin, not user id)\n * - Type: always \"admin\" for discriminator\n */\nexport interface AdminPayload {\n  /** Top-level admin table ID (the fundamental admin identifier in the system). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the discriminated union type. */\n  type: \"admin\";\n}\n"},"role":{"name":"admin","description":"An administrator who can view and manage all users and todos in the system, has permission to perform maintenance and emergency recovery tasks.","kind":"admin"}}],"functions":[{"location":"src/providers/postTodoListUserTodos.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function postTodoListUserTodos(props: {\n  user: UserPayload;\n  body: ITodoListTodo.ICreate;\n}): Promise<ITodoListTodo> {\n  const now = toISOStringSafe(new Date());\n  const trimmedTitle = props.body.title.trim();\n\n  // Business rule enforcement: title must be trimmed, non-empty, <=100 chars, no line breaks\n  if (trimmedTitle.length === 0) {\n    throw new HttpException(\"Title must not be empty or whitespace only.\", 400);\n  }\n  if (trimmedTitle.length > 100) {\n    throw new HttpException(\"Title must not exceed 100 characters.\", 400);\n  }\n  if (\n    trimmedTitle.includes(\n      \"\\\n\",\n    ) ||\n    trimmedTitle.includes(\n      \"\\\n\",\n    )\n  ) {\n    throw new HttpException(\"Title must not contain line breaks.\", 400);\n  }\n\n  const created = await MyGlobal.prisma.todo_list_todos.create({\n    data: {\n      id: v4(),\n      todo_list_user_id: props.user.id,\n      title: trimmedTitle,\n      is_completed: false,\n      created_at: now,\n      updated_at: now,\n      completed_at: null,\n      deleted_at: null,\n    },\n  });\n\n  return {\n    id: created.id,\n    todo_list_user_id: created.todo_list_user_id,\n    title: created.title,\n    is_completed: created.is_completed,\n    created_at: toISOStringSafe(created.created_at),\n    updated_at: toISOStringSafe(created.updated_at),\n    completed_at:\n      created.completed_at === null\n        ? null\n        : toISOStringSafe(created.completed_at),\n    deleted_at:\n      created.deleted_at === null ? null : toISOStringSafe(created.deleted_at),\n  };\n}\n","endpoint":{"method":"post","path":"/todoList/user/todos"},"name":"postTodoListUserTodos"},{"location":"src/providers/postAuthUserJoin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserJoin(props: {\n  body: ITodoListUser.IJoin;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { email, password } = props.body;\n  // Step 1: Check for duplicate email\n  const existing = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { email },\n  });\n  if (existing !== null) {\n    throw new HttpException(\"Email already registered.\", 409);\n  }\n\n  // Step 2: Hash password securely\n  const password_hash = await PasswordUtil.hash(password);\n\n  // Step 3: Generate user id and timestamps\n  const id = v4();\n  const now = toISOStringSafe(new Date());\n\n  // Step 4: Insert user\n  const user = await MyGlobal.prisma.todo_list_users.create({\n    data: {\n      id,\n      email,\n      password_hash,\n      created_at: now,\n      updated_at: now,\n    },\n  });\n\n  // Step 5: Compute token expiry\n  const access_expiry = new Date(Date.now() + 60 * 60 * 1000);\n  const refresh_expiry = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n\n  const access_token = jwt.sign(\n    { id: user.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"1h\", issuer: \"autobe\" },\n  );\n  const refresh_token = jwt.sign(\n    { id: user.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"7d\", issuer: \"autobe\" },\n  );\n\n  // Step 6: Return authorized user DTO with token group\n  return {\n    id: user.id,\n    email: user.email,\n    created_at: toISOStringSafe(user.created_at),\n    updated_at: toISOStringSafe(user.updated_at),\n    token: {\n      access: access_token,\n      refresh: refresh_token,\n      expired_at: toISOStringSafe(access_expiry),\n      refreshable_until: toISOStringSafe(refresh_expiry),\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/join"},"name":"postAuthUserJoin"},{"location":"src/providers/postAuthUserLogin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserLogin(props: {\n  body: ITodoListUser.ILogin;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { email, password } = props.body;\n  // 1. Find user by unique email\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { email },\n  });\n  if (!user) throw new HttpException(\"Invalid credentials\", 403);\n\n  // 2. Password check using PasswordUtil\n  const valid = await PasswordUtil.verify(password, user.password_hash);\n  if (!valid) throw new HttpException(\"Invalid credentials\", 403);\n\n  // 3. Update 'updated_at' field with current timestamp (toISOStringSafe)\n  const now = toISOStringSafe(new Date());\n  await MyGlobal.prisma.todo_list_users.update({\n    where: { id: user.id },\n    data: { updated_at: now },\n  });\n\n  // 4. Generate JWT tokens with proper payload/issuer/expiration\n  const jwtPayload = { id: user.id, type: \"user\" };\n  const access = jwt.sign(jwtPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"1h\",\n    issuer: \"autobe\",\n  });\n  const refresh = jwt.sign(jwtPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"7d\",\n    issuer: \"autobe\",\n  });\n\n  // 5. Compute exact token expiry times (ISO format)\n  const accessExpired = toISOStringSafe(new Date(Date.now() + 60 * 60 * 1000));\n  const refreshExpired = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n  );\n\n  return {\n    id: user.id,\n    email: user.email,\n    created_at: toISOStringSafe(user.created_at),\n    updated_at: now,\n    token: {\n      access: access,\n      refresh: refresh,\n      expired_at: accessExpired,\n      refreshable_until: refreshExpired,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/login"},"name":"postAuthUserLogin"},{"location":"src/providers/postAuthUserRefresh.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserRefresh(props: {\n  body: ITodoListUser.IRefresh;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { refresh_token } = props.body;\n  let decoded: any;\n  try {\n    decoded = jwt.verify(refresh_token, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    });\n  } catch (err) {\n    throw new HttpException(\"Invalid or expired refresh token\", 401);\n  }\n\n  if (\n    !decoded ||\n    typeof decoded !== \"object\" ||\n    decoded.type !== \"user\" ||\n    !decoded.id\n  ) {\n    throw new HttpException(\"Invalid refresh token\", 401);\n  }\n\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { id: decoded.id },\n  });\n  if (!user) {\n    throw new HttpException(\"User not found for refresh token\", 401);\n  }\n\n  // Now, rotate tokens\n  const now = new Date();\n  const accessExpires = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour\n  const refreshExpires = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // 7 days\n\n  const access = jwt.sign(\n    { id: user.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"1h\", issuer: \"autobe\" },\n  );\n  const refresh = jwt.sign(\n    { id: user.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"7d\", issuer: \"autobe\" },\n  );\n\n  // Update user's updated_at\n  await MyGlobal.prisma.todo_list_users.update({\n    where: { id: user.id },\n    data: { updated_at: toISOStringSafe(now) },\n  });\n\n  return {\n    id: user.id,\n    email: user.email,\n    created_at: toISOStringSafe(user.created_at),\n    updated_at: toISOStringSafe(now),\n    token: {\n      access,\n      refresh,\n      expired_at: toISOStringSafe(accessExpires),\n      refreshable_until: toISOStringSafe(refreshExpires),\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/refresh"},"name":"postAuthUserRefresh"},{"location":"src/providers/postAuthAdminJoin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthAdminJoin(props: {\n  body: ITodoListAdmin.ICreate;\n}): Promise<ITodoListAdmin.IAuthorized> {\n  const { email, password } = props.body;\n\n  // Check for duplicate email\n  const exists = await MyGlobal.prisma.todo_list_admins.findUnique({\n    where: { email },\n    select: { id: true },\n  });\n  if (exists) {\n    throw new HttpException(\"Duplicate email: already registered\", 409);\n  }\n\n  // Hash password\n  const password_hash = await PasswordUtil.hash(password);\n\n  // Generate IDs, timestamps\n  const id = v4();\n  const now = toISOStringSafe(new Date());\n\n  // Create admin\n  const admin = await MyGlobal.prisma.todo_list_admins.create({\n    data: {\n      id,\n      email,\n      password_hash,\n      created_at: now,\n      updated_at: now,\n    },\n    select: {\n      id: true,\n      email: true,\n      created_at: true,\n      updated_at: true,\n    },\n  });\n\n  // Token expiry computation\n  const accessTokenExpiresInSeconds = 3600;\n  const refreshTokenExpiresInSeconds = 604800;\n  const accessExpiredAt = toISOStringSafe(\n    new Date(Date.now() + accessTokenExpiresInSeconds * 1000),\n  );\n  const refreshableUntil = toISOStringSafe(\n    new Date(Date.now() + refreshTokenExpiresInSeconds * 1000),\n  );\n\n  // Issue JWT tokens\n  const access = jwt.sign(\n    { id: admin.id, type: \"admin\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: accessTokenExpiresInSeconds, issuer: \"autobe\" },\n  );\n  const refresh = jwt.sign(\n    { id: admin.id, type: \"admin\", tokenType: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: refreshTokenExpiresInSeconds, issuer: \"autobe\" },\n  );\n\n  return {\n    id: admin.id,\n    email: admin.email,\n    created_at: toISOStringSafe(admin.created_at),\n    updated_at: toISOStringSafe(admin.updated_at),\n    token: {\n      access,\n      refresh,\n      expired_at: accessExpiredAt,\n      refreshable_until: refreshableUntil,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/admin/join"},"name":"postAuthAdminJoin"},{"location":"src/providers/postAuthAdminLogin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthAdminLogin(props: {\n  body: ITodoListAdmin.ILogin;\n}): Promise<ITodoListAdmin.IAuthorized> {\n  const { email, password } = props.body;\n\n  // 1. Find admin by email\n  const admin = await MyGlobal.prisma.todo_list_admins.findUnique({\n    where: { email },\n  });\n  if (!admin) {\n    throw new HttpException(\"Invalid credentials\", 401);\n  }\n\n  // 2. Check password\n  const passwordValid = await PasswordUtil.verify(\n    password,\n    admin.password_hash,\n  );\n  if (!passwordValid) {\n    throw new HttpException(\"Invalid credentials\", 401);\n  }\n\n  // 3. Prepare expiration times\n  const nowMs = Date.now();\n  const accessExpiresAt = new Date(nowMs + 60 * 60 * 1000); // 1 hour\n  const refreshExpiresAt = new Date(nowMs + 7 * 24 * 60 * 60 * 1000); // 7 days\n\n  // 4. JWT claims\n  const accessPayload = { id: admin.id, type: \"admin\" };\n  const refreshPayload = { id: admin.id, type: \"admin\", tokenType: \"refresh\" };\n\n  // 5. Generate tokens\n  const access = jwt.sign(accessPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"1h\",\n    issuer: \"autobe\",\n  });\n  const refresh = jwt.sign(refreshPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"7d\",\n    issuer: \"autobe\",\n  });\n\n  // 6. Assemble token info\n  const token = {\n    access,\n    refresh,\n    expired_at: toISOStringSafe(accessExpiresAt),\n    refreshable_until: toISOStringSafe(refreshExpiresAt),\n  };\n\n  // 7. Return authorized admin info\n  return {\n    id: admin.id,\n    email: admin.email,\n    created_at: toISOStringSafe(admin.created_at),\n    updated_at: toISOStringSafe(admin.updated_at),\n    token,\n  };\n}\n","endpoint":{"method":"post","path":"/auth/admin/login"},"name":"postAuthAdminLogin"},{"location":"src/providers/postAuthAdminRefresh.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthAdminRefresh(props: {\n  body: ITodoListAdmin.IRefresh;\n}): Promise<ITodoListAdmin.IAuthorized> {\n  const { body } = props;\n\n  let decoded: { id: string; type: string };\n  try {\n    decoded = jwt.verify(body.refresh_token, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    }) as { id: string; type: string };\n  } catch {\n    throw new HttpException(\"Invalid or expired refresh token\", 401);\n  }\n  if (!decoded || decoded.type !== \"admin\" || !decoded.id) {\n    throw new HttpException(\"Invalid admin refresh token\", 401);\n  }\n\n  const admin = await MyGlobal.prisma.todo_list_admins.findUnique({\n    where: { id: decoded.id },\n  });\n  if (!admin) {\n    throw new HttpException(\"Admin not found\", 401);\n  }\n\n  // Compute expiration date-time fields as ISO 8601 strings\n  const nowEpoch = Date.now();\n  const accessLifespanMs = 60 * 60 * 1000; // 1 hour\n  const refreshLifespanMs = 7 * 24 * 60 * 60 * 1000; // 7 days\n\n  const expired_at = toISOStringSafe(new Date(nowEpoch + accessLifespanMs));\n  const refreshable_until = toISOStringSafe(\n    new Date(nowEpoch + refreshLifespanMs),\n  );\n\n  const access = jwt.sign(\n    { id: admin.id, type: \"admin\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"1h\",\n      issuer: \"autobe\",\n    },\n  );\n  const refresh = jwt.sign(\n    { id: admin.id, type: \"admin\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n\n  return {\n    id: admin.id,\n    email: admin.email,\n    created_at: toISOStringSafe(admin.created_at),\n    updated_at: toISOStringSafe(admin.updated_at),\n    token: {\n      access,\n      refresh,\n      expired_at,\n      refreshable_until,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/admin/refresh"},"name":"postAuthAdminRefresh"},{"location":"src/providers/patchTodoListAdminUsers.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { IPageITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListUser\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function patchTodoListAdminUsers(props: {\n  admin: AdminPayload;\n  body: ITodoListUser.IRequest;\n}): Promise<IPageITodoListUser.ISummary> {\n  const { body } = props;\n  const page = typeof body.page === \"number\" && body.page > 0 ? body.page : 1;\n  const limit =\n    typeof body.limit === \"number\" && body.limit > 0 ? body.limit : 100;\n\n  const email =\n    typeof body.email === \"string\" && body.email.length > 0\n      ? body.email\n      : undefined;\n  let sortField: \"created_at\" | \"email\" = \"created_at\";\n  if (body.sort === \"created_at\" || body.sort === \"email\")\n    sortField = body.sort;\n  let order: \"asc\" | \"desc\" = \"desc\";\n  if (body.order === \"asc\" || body.order === \"desc\") order = body.order;\n\n  const where = email !== undefined ? { email: { contains: email } } : {};\n\n  // Inline orderBy - only supported fields\n  const orderBy =\n    sortField === \"email\" ? { email: order } : { created_at: order };\n\n  const total = await MyGlobal.prisma.todo_list_users.count({ where });\n  const users = await MyGlobal.prisma.todo_list_users.findMany({\n    where,\n    orderBy,\n    skip: (page - 1) * limit,\n    take: limit,\n    select: {\n      id: true,\n      email: true,\n      created_at: true,\n    },\n  });\n\n  const data = users.map((user) => ({\n    id: user.id,\n    email: user.email,\n    created_at: toISOStringSafe(user.created_at),\n  }));\n\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: total,\n      pages: Math.ceil(total / Number(limit)),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/admin/users"},"name":"patchTodoListAdminUsers"},{"location":"src/providers/getTodoListAdminUsersUserId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function getTodoListAdminUsersUserId(props: {\n  admin: AdminPayload;\n  userId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListUser> {\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { id: props.userId },\n    select: {\n      id: true,\n      email: true,\n      created_at: true,\n      updated_at: true,\n    },\n  });\n  if (!user) throw new HttpException(\"User not found\", 404);\n  return {\n    id: user.id,\n    email: user.email,\n    created_at: toISOStringSafe(user.created_at),\n    updated_at: toISOStringSafe(user.updated_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/admin/users/{userId}"},"name":"getTodoListAdminUsersUserId"},{"location":"src/providers/putTodoListAdminUsersUserId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function putTodoListAdminUsersUserId(props: {\n  admin: AdminPayload;\n  userId: string & tags.Format<\"uuid\">;\n  body: ITodoListUser.IUpdate;\n}): Promise<ITodoListUser> {\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { id: props.userId },\n  });\n  if (!user) {\n    throw new HttpException(\"User not found\", 404);\n  }\n\n  // Prepare updated fields. Only include provided fields (email, password_hash).\n  const now = toISOStringSafe(new Date());\n  const updateFields: {\n    email?: string;\n    password_hash?: string;\n    updated_at: string & tags.Format<\"date-time\">;\n  } = {\n    ...(props.body.email !== undefined ? { email: props.body.email } : {}),\n    ...(props.body.password_hash !== undefined\n      ? { password_hash: props.body.password_hash }\n      : {}),\n    updated_at: now,\n  };\n\n  try {\n    const updated = await MyGlobal.prisma.todo_list_users.update({\n      where: { id: props.userId },\n      data: updateFields,\n    });\n    return {\n      id: updated.id,\n      email: updated.email,\n      created_at: toISOStringSafe(updated.created_at),\n      updated_at: toISOStringSafe(updated.updated_at),\n    };\n  } catch (error) {\n    // Check unique constraint violation (duplicate email)\n    if (\n      typeof error === \"object\" &&\n      error !== null &&\n      \"code\" in error &&\n      (error as { code?: string }).code === \"P2002\"\n    ) {\n      throw new HttpException(\"Email must be unique\", 409);\n    }\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"put","path":"/todoList/admin/users/{userId}"},"name":"putTodoListAdminUsersUserId"},{"location":"src/providers/deleteTodoListAdminUsersUserId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function deleteTodoListAdminUsersUserId(props: {\n  admin: AdminPayload;\n  userId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  try {\n    await MyGlobal.prisma.todo_list_users.delete({\n      where: { id: props.userId },\n    });\n  } catch (error) {\n    if (\n      error instanceof Prisma.PrismaClientKnownRequestError &&\n      error.code === \"P2025\"\n    ) {\n      throw new HttpException(\n        `User with id ${props.userId} does not exist`,\n        404,\n      );\n    }\n    throw new HttpException(\"Internal server error\", 500);\n  }\n}\n","endpoint":{"method":"delete","path":"/todoList/admin/users/{userId}"},"name":"deleteTodoListAdminUsersUserId"},{"location":"src/providers/patchTodoListAdminAdmins.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { IPageITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAdmin\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function patchTodoListAdminAdmins(props: {\n  admin: AdminPayload;\n  body: ITodoListAdmin.IRequest;\n}): Promise<IPageITodoListAdmin.ISummary> {\n  const { body } = props;\n  const page = body.page ?? 1;\n  const limit = body.limit ?? 100;\n  const skip = (page - 1) * limit;\n\n  // Parse and constrain sort/order\n  const allowedSort: (\"created_at\" | \"email\")[] = [\"created_at\", \"email\"];\n  const allowedOrder: (\"asc\" | \"desc\")[] = [\"asc\", \"desc\"];\n  const sortField = allowedSort.includes(body.sort ?? \"created_at\")\n    ? (body.sort ?? \"created_at\")\n    : \"created_at\";\n  const sortOrder = allowedOrder.includes(body.order ?? \"desc\")\n    ? (body.order ?? \"desc\")\n    : \"desc\";\n\n  // Build Prisma where condition for partial email match\n  const prismaWhere = {\n    ...(body.email !== undefined &&\n      body.email !== null &&\n      body.email.length > 0 && {\n        email: { contains: body.email },\n      }),\n  };\n\n  // Query\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_admins.findMany({\n      where: prismaWhere,\n      orderBy: { [sortField]: sortOrder },\n      skip,\n      take: limit,\n      select: {\n        id: true,\n        email: true,\n        created_at: true,\n      },\n    }),\n    MyGlobal.prisma.todo_list_admins.count({ where: prismaWhere }),\n  ]);\n\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: Number(total),\n      pages: Math.ceil(Number(total) / Number(limit)),\n    },\n    data: rows.map((admin) => ({\n      id: admin.id,\n      email: admin.email,\n      created_at: toISOStringSafe(admin.created_at),\n    })),\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/admin/admins"},"name":"patchTodoListAdminAdmins"},{"location":"src/providers/getTodoListAdminAdminsAdminId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function getTodoListAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListAdmin> {\n  const row = await MyGlobal.prisma.todo_list_admins.findFirst({\n    where: { id: props.adminId },\n    select: {\n      id: true,\n      email: true,\n      created_at: true,\n      updated_at: true,\n    },\n  });\n  if (!row) {\n    throw new HttpException(\"Not Found\", 404);\n  }\n  return {\n    id: row.id,\n    email: row.email,\n    created_at: toISOStringSafe(row.created_at),\n    updated_at: toISOStringSafe(row.updated_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/admin/admins/{adminId}"},"name":"getTodoListAdminAdminsAdminId"},{"location":"src/providers/putTodoListAdminAdminsAdminId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAdmin\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function putTodoListAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n  body: ITodoListAdmin.IUpdate;\n}): Promise<ITodoListAdmin> {\n  // Auth is ensured by decorator.\n  // 1. Check existence of target adminId\n  const original = await MyGlobal.prisma.todo_list_admins.findUnique({\n    where: { id: props.adminId },\n  });\n  if (!original) {\n    throw new HttpException(\"Admin not found\", 404);\n  }\n  // 2. Check: do not allow updating id\n  // (id is not present in body by DTO/type design)\n  // 3. Prepare updated_at\n  const updated_at = toISOStringSafe(new Date());\n  // 4. Update\n  const updated = await MyGlobal.prisma.todo_list_admins.update({\n    where: { id: props.adminId },\n    data: {\n      email: props.body.email ?? undefined,\n      password_hash: props.body.password_hash ?? undefined,\n      updated_at: updated_at,\n    },\n  });\n  // 5. Return as ITodoListAdmin - convert date fields\n  return {\n    id: updated.id,\n    email: updated.email,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: updated_at,\n  };\n}\n","endpoint":{"method":"put","path":"/todoList/admin/admins/{adminId}"},"name":"putTodoListAdminAdminsAdminId"},{"location":"src/providers/deleteTodoListAdminAdminsAdminId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function deleteTodoListAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  // Step 1: Confirm admin exists\n  const admin = await MyGlobal.prisma.todo_list_admins.findUnique({\n    where: { id: props.adminId },\n    select: { id: true },\n  });\n  if (!admin) {\n    throw new HttpException(\"Admin not found\", 404);\n  }\n  // Step 2: Count admins (to prevent deleting last admin)\n  const adminCount = await MyGlobal.prisma.todo_list_admins.count();\n  if (adminCount <= 1) {\n    throw new HttpException(\n      \"At least one admin account must remain. Deletion was cancelled.\",\n      409,\n    );\n  }\n  // Step 3: Hard delete\n  await MyGlobal.prisma.todo_list_admins.delete({\n    where: { id: props.adminId },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoList/admin/admins/{adminId}"},"name":"deleteTodoListAdminAdminsAdminId"},{"location":"src/providers/patchTodoListUserTodos.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function patchTodoListUserTodos(props: {\n  user: UserPayload;\n  body: ITodoListTodo.IRequest;\n}): Promise<IPageITodoListTodo.ISummary> {\n  const { user, body } = props;\n  const page = body.page !== undefined ? body.page : 1;\n  const limit = body.limit !== undefined ? body.limit : 20;\n  const skip = (Number(page) - 1) * Number(limit);\n\n  const where = {\n    todo_list_user_id: user.id,\n    deleted_at: null,\n    ...(body.is_completed !== undefined && { is_completed: body.is_completed }),\n    ...(body.search !== undefined &&\n      body.search.length > 0 && {\n        title: { contains: body.search },\n      }),\n  };\n\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_todos.findMany({\n      where,\n      orderBy: { created_at: \"desc\" },\n      skip: Number(skip),\n      take: Number(limit),\n      select: {\n        id: true,\n        title: true,\n        is_completed: true,\n        created_at: true,\n        updated_at: true,\n      },\n    }),\n    MyGlobal.prisma.todo_list_todos.count({ where }),\n  ]);\n\n  const data = rows.map((row) => ({\n    id: row.id,\n    title: row.title,\n    is_completed: row.is_completed,\n    created_at: toISOStringSafe(row.created_at),\n    updated_at: toISOStringSafe(row.updated_at),\n  }));\n\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: total,\n      pages: Math.ceil(total / Number(limit)),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/user/todos"},"name":"patchTodoListUserTodos"},{"location":"src/providers/patchTodoListAdminTodos.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function patchTodoListAdminTodos(props: {\n  admin: AdminPayload;\n  body: ITodoListTodo.IRequest;\n}): Promise<IPageITodoListTodo.ISummary> {\n  const { body } = props;\n  const page = body.page !== undefined ? body.page : 1;\n  const limit = body.limit !== undefined ? body.limit : 20;\n  const skip = (page - 1) * limit;\n\n  const where = {\n    deleted_at: null,\n    ...(body.is_completed !== undefined && { is_completed: body.is_completed }),\n    ...(body.search !== undefined &&\n      body.search !== \"\" && { title: { contains: body.search } }),\n  };\n\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_todos.findMany({\n      where,\n      orderBy: { created_at: \"desc\" },\n      skip,\n      take: limit,\n    }),\n    MyGlobal.prisma.todo_list_todos.count({ where }),\n  ]);\n\n  const data = rows.map((todo) => ({\n    id: todo.id,\n    title: todo.title,\n    is_completed: todo.is_completed,\n    created_at: toISOStringSafe(todo.created_at),\n    updated_at: toISOStringSafe(todo.updated_at),\n  }));\n\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: total,\n      pages: Math.ceil(total / limit),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/admin/todos"},"name":"patchTodoListAdminTodos"},{"location":"src/providers/getTodoListUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function getTodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListTodo> {\n  const { user, todoId } = props;\n\n  // Find the Todo item by PK, throw 404 if not found\n  const todo = await MyGlobal.prisma.todo_list_todos.findUniqueOrThrow({\n    where: { id: todoId },\n  });\n\n  // Only allow if user owns the Todo\n  if (user.id !== todo.todo_list_user_id) {\n    throw new HttpException(\n      \"Forbidden: You do not have access to this Todo\",\n      403,\n    );\n  }\n\n  // Build output per ITodoListTodo. Omit optionals if null.\n  return {\n    id: todo.id,\n    todo_list_user_id: todo.todo_list_user_id,\n    title: todo.title,\n    is_completed: todo.is_completed,\n    created_at: toISOStringSafe(todo.created_at),\n    updated_at: toISOStringSafe(todo.updated_at),\n    ...(todo.completed_at !== null && {\n      completed_at: toISOStringSafe(todo.completed_at),\n    }),\n    ...(todo.deleted_at !== null && {\n      deleted_at: toISOStringSafe(todo.deleted_at),\n    }),\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/user/todos/{todoId}"},"name":"getTodoListUserTodosTodoId"},{"location":"src/providers/getTodoListAdminTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function getTodoListAdminTodosTodoId(props: {\n  admin: AdminPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListTodo> {\n  // Admin is authorized to access any todo-list-todos record\n  const todo = await MyGlobal.prisma.todo_list_todos.findUniqueOrThrow({\n    where: { id: props.todoId },\n    select: {\n      id: true,\n      todo_list_user_id: true,\n      title: true,\n      is_completed: true,\n      created_at: true,\n      updated_at: true,\n      completed_at: true,\n      deleted_at: true,\n    },\n  });\n  return {\n    id: todo.id,\n    todo_list_user_id: todo.todo_list_user_id,\n    title: todo.title,\n    is_completed: todo.is_completed,\n    created_at: toISOStringSafe(todo.created_at),\n    updated_at: toISOStringSafe(todo.updated_at),\n    completed_at: todo.completed_at ? toISOStringSafe(todo.completed_at) : null,\n    deleted_at: todo.deleted_at ? toISOStringSafe(todo.deleted_at) : null,\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/admin/todos/{todoId}"},"name":"getTodoListAdminTodosTodoId"},{"location":"src/providers/postTodoListAdminTodos.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function postTodoListAdminTodos(props: {\n  admin: AdminPayload;\n  body: ITodoListTodo.ICreate;\n}): Promise<ITodoListTodo> {\n  const now = toISOStringSafe(new Date());\n  const created = await MyGlobal.prisma.todo_list_todos.create({\n    data: {\n      id: v4(),\n      todo_list_user_id: props.admin.id,\n      title: props.body.title,\n      is_completed: false,\n      created_at: now,\n      updated_at: now,\n      completed_at: null,\n      deleted_at: null,\n    },\n  });\n  return {\n    id: created.id,\n    todo_list_user_id: created.todo_list_user_id,\n    title: created.title,\n    is_completed: created.is_completed,\n    created_at: toISOStringSafe(created.created_at),\n    updated_at: toISOStringSafe(created.updated_at),\n    completed_at:\n      created.completed_at === null\n        ? null\n        : toISOStringSafe(created.completed_at),\n    deleted_at:\n      created.deleted_at === null ? null : toISOStringSafe(created.deleted_at),\n  };\n}\n","endpoint":{"method":"post","path":"/todoList/admin/todos"},"name":"postTodoListAdminTodos"},{"location":"src/providers/putTodoListUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function putTodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  body: ITodoListTodo.IUpdate;\n}): Promise<ITodoListTodo> {\n  const { user, todoId, body } = props;\n\n  // Fetch todo by ID\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: todoId },\n  });\n  if (!todo) {\n    throw new HttpException(\"Todo not found\", 404);\n  }\n\n  // Ownership check (UserPayload is always type 'user')\n  if (todo.todo_list_user_id !== user.id) {\n    throw new HttpException(\"Forbidden\", 403);\n  }\n\n  // Determine update fields\n  const now = toISOStringSafe(new Date());\n\n  // Only update fields provided in body\n  const data: {\n    title?: string;\n    is_completed?: boolean;\n    completed_at?: (string & tags.Format<\"date-time\">) | null;\n    updated_at: string & tags.Format<\"date-time\">;\n  } = {\n    updated_at: now,\n  };\n\n  if (body.title !== undefined) {\n    data.title = body.title;\n  }\n  if (body.is_completed !== undefined) {\n    data.is_completed = body.is_completed;\n    data.completed_at = body.is_completed ? now : null;\n  }\n\n  const updated = await MyGlobal.prisma.todo_list_todos.update({\n    where: { id: todoId },\n    data,\n  });\n\n  return {\n    id: updated.id,\n    todo_list_user_id: updated.todo_list_user_id,\n    title: updated.title,\n    is_completed: updated.is_completed,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n    completed_at:\n      updated.completed_at !== null && updated.completed_at !== undefined\n        ? toISOStringSafe(updated.completed_at)\n        : null,\n    deleted_at:\n      updated.deleted_at !== null && updated.deleted_at !== undefined\n        ? toISOStringSafe(updated.deleted_at)\n        : undefined,\n  };\n}\n","endpoint":{"method":"put","path":"/todoList/user/todos/{todoId}"},"name":"putTodoListUserTodosTodoId"},{"location":"src/providers/putTodoListAdminTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function putTodoListAdminTodosTodoId(props: {\n  admin: AdminPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  body: ITodoListTodo.IUpdate;\n}): Promise<ITodoListTodo> {\n  // Find the existing todo\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: props.todoId },\n  });\n  if (!todo) {\n    throw new HttpException(\"Todo not found\", 404);\n  }\n\n  const now: string & tags.Format<\"date-time\"> = toISOStringSafe(new Date());\n\n  // Decide completed_at: update if is_completed is present, else keep as is\n  let completed_at: (string & tags.Format<\"date-time\">) | null =\n    todo.completed_at ? toISOStringSafe(todo.completed_at) : null;\n  if (typeof props.body.is_completed === \"boolean\") {\n    if (props.body.is_completed) {\n      completed_at = now;\n    } else {\n      completed_at = null;\n    }\n  }\n\n  // Prepare fields to update\n  const updated = await MyGlobal.prisma.todo_list_todos.update({\n    where: { id: props.todoId },\n    data: {\n      ...(props.body.title !== undefined ? { title: props.body.title } : {}),\n      ...(props.body.is_completed !== undefined\n        ? { is_completed: props.body.is_completed }\n        : {}),\n      completed_at:\n        props.body.is_completed !== undefined ? completed_at : undefined,\n      updated_at: now,\n    },\n  });\n\n  return {\n    id: updated.id,\n    todo_list_user_id: updated.todo_list_user_id,\n    title: updated.title,\n    is_completed: updated.is_completed,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n    completed_at: updated.completed_at\n      ? toISOStringSafe(updated.completed_at)\n      : null,\n    deleted_at: updated.deleted_at ? toISOStringSafe(updated.deleted_at) : null,\n  };\n}\n","endpoint":{"method":"put","path":"/todoList/admin/todos/{todoId}"},"name":"putTodoListAdminTodosTodoId"},{"location":"src/providers/deleteTodoListUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function deleteTodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const { user, todoId } = props;\n\n  // Fetch the todo by ID (must exist)\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: todoId },\n    select: {\n      id: true,\n      todo_list_user_id: true,\n    },\n  });\n  if (!todo) {\n    throw new HttpException(\"Todo not found\", 404);\n  }\n  // Only owner can delete (user.id must match todo_list_user_id)\n  if (todo.todo_list_user_id !== user.id) {\n    throw new HttpException(\n      \"Unauthorized: You can only delete your own todos\",\n      403,\n    );\n  }\n  // Hard delete\n  await MyGlobal.prisma.todo_list_todos.delete({ where: { id: todoId } });\n}\n","endpoint":{"method":"delete","path":"/todoList/user/todos/{todoId}"},"name":"deleteTodoListUserTodosTodoId"},{"location":"src/providers/deleteTodoListAdminTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function deleteTodoListAdminTodosTodoId(props: {\n  admin: AdminPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  // Ensure the todo exists before deleting\n  await MyGlobal.prisma.todo_list_todos.findUniqueOrThrow({\n    where: { id: props.todoId },\n  });\n  await MyGlobal.prisma.todo_list_todos.delete({\n    where: { id: props.todoId },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoList/admin/todos/{todoId}"},"name":"deleteTodoListAdminTodosTodoId"}],"controllers":{"src/controllers/auth/user/AuthUserController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { postAuthUserJoin } from \"../../../providers/postAuthUserJoin\";\nimport { postAuthUserLogin } from \"../../../providers/postAuthUserLogin\";\nimport { postAuthUserRefresh } from \"../../../providers/postAuthUserRefresh\";\n\nimport { ITodoListUser } from \"../../../api/structures/ITodoListUser\";\n\n@Controller(\"/auth/user\")\nexport class AuthUserController {\n  /**\n   * Register a new user in the 'todo_list_users' table and receive JWT tokens\n   * for session start.\n   *\n   * This operation enables public registration of a new user for the minimal\n   * Todo application. It creates a record in the 'todo_list_users' table with\n   * the provided email and hashed password. Both 'created_at' and 'updated_at'\n   * are set with the account creation timestamp (UTC ISO 8601).\n   *\n   * All fields referenced (email, password_hash, created_at, updated_at) must\n   * be present and valid as per schema. The operation verifies email uniqueness\n   * and generates tokens upon successful join. The password is securely hashed\n   * as defined in the 'password_hash' column (never in plain text).\n   *\n   * No privilege is granted beyond ordinary user (cannot access any other\n   * data). Account registration issues a user JWT token pair without any admin\n   * capability, precisely in line with minimalism principles for account\n   * management.\n   *\n   * Security practices require email uniqueness, password strength validation,\n   * secure token generation, and all onboarded fields are directly mapped to\n   * schema fields with no extension. This operation must be called only by\n   * unauthenticated/public clients.\n   *\n   * This operation is always the first in the authentication flow, followed by\n   * login for future accesses or refresh for renewing tokens. It is related to\n   * the 'login' and 'refresh' operations for a complete authentication\n   * lifecycle.\n   *\n   * @param connection\n   * @param body User registration information for 'todo_list_users' (email,\n   *   password)\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @TypedBody()\n    body: ITodoListUser.IJoin,\n  ): Promise<ITodoListUser.IAuthorized> {\n    try {\n      return await postAuthUserJoin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate a user in 'todo_list_users' with email/password and issue new\n   * JWT tokens.\n   *\n   * This operation authenticates users of the minimal Todo app by validating\n   * their provided email and password. It queries only 'todo_list_users', using\n   * fields 'email' and 'password_hash', and—upon successful credential\n   * match—issues new JWT tokens for access and refresh, following the strict\n   * security requirements.\n   *\n   * Login updates the 'updated_at' field to log last login activity. No extra\n   * account or role information is returned; the authentication response\n   * includes only required fields.\n   *\n   * Security is ensured by: never revealing actual password or failure\n   * specifics, hashing all credentials, and rejecting all logins lacking valid\n   * schema-matching records. Each login attempt is isolated to the user account\n   * referenced by email.\n   *\n   * The login process is the second step in end-user authentication workflows,\n   * after registration. Token refresh and logout are handled by additional\n   * endpoints. This operation is not accessible for admin or guest roles—it is\n   * only for member users as defined by the schema.\n   *\n   * @param connection\n   * @param body Login information (email and password) per 'todo_list_users'\n   *   schema.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(\n    @TypedBody()\n    body: ITodoListUser.ILogin,\n  ): Promise<ITodoListUser.IAuthorized> {\n    try {\n      return await postAuthUserLogin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh JWT tokens for a user in 'todo_list_users', updating the session\n   * securely.\n   *\n   * This endpoint allows authenticated users to renew their session by\n   * submitting a valid JWT refresh token. It references the 'todo_list_users'\n   * table for token validation and—if valid—generates new access and refresh\n   * tokens. The 'updated_at' field is updated to reflect token renewal.\n   *\n   * No additional details are altered in the user record. Security is managed\n   * by fully verifying the refresh token, rejecting invalid or expired tokens,\n   * and exposing no extra account data.\n   *\n   * All token operations are strictly mapped to real schema fields, and the\n   * response returns the minimal necessary authorized DTO with no extra\n   * information. This operation is essential for maintaining user login\n   * persistence under JWT strategies. Only available to users with valid\n   * refresh tokens issued by the system.\n   *\n   * The refresh endpoint completes the authentication cycle in coordination\n   * with registration and login. Failure to provide a valid refresh token\n   * results in an authentication error with no account data disclosed.\n   *\n   * @param connection\n   * @param body Refresh token for renewing authentication in 'todo_list_users'.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @TypedBody()\n    body: ITodoListUser.IRefresh,\n  ): Promise<ITodoListUser.IAuthorized> {\n    try {\n      return await postAuthUserRefresh({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/auth/admin/AuthAdminController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { postAuthAdminJoin } from \"../../../providers/postAuthAdminJoin\";\nimport { postAuthAdminLogin } from \"../../../providers/postAuthAdminLogin\";\nimport { postAuthAdminRefresh } from \"../../../providers/postAuthAdminRefresh\";\n\nimport { ITodoListAdmin } from \"../../../api/structures/ITodoListAdmin\";\n\n@Controller(\"/auth/admin\")\nexport class AuthAdminController {\n  /**\n   * Register a new admin account in todo_list_admins and issue initial admin\n   * tokens.\n   *\n   * This API registers a new admin account using the essential fields specified\n   * in the todo_list_admins schema: unique email and password_hash, issued at\n   * registration time. Each admin account is uniquely identified by the email\n   * and has its password securely stored as a hash. Upon successful\n   * registration, the endpoint issues a new access token and refresh token,\n   * embodying the authentication standard required for future privileged access\n   * by admins.\n   *\n   * The implementation validates the email for uniqueness at the database level\n   * (@@unique on email field) and ensures the password is securely hashed\n   * before being persisted. The timestamps for creation and update (created_at,\n   * updated_at) are automatically managed for audit purposes and are not\n   * user-supplied.\n   *\n   * Admin registration is functionally distinct from standard user\n   * registration: only entries in the todo_list_admins table can obtain\n   * admin-level access. There is no role overlap; admin accounts do not provide\n   * standard user functionality and have no reference to the todos or user\n   * tables. This precise separation is both a security and audit measure.\n   *\n   * For security, registration input is validated for email uniqueness and\n   * password completeness. Passwords should be strong, and only hashes ever\n   * stored. Token issuance adheres to business rules for admin session\n   * management and access control.\n   *\n   * This operation is necessary for all admin workflow authentication and is\n   * the exclusive way to add new admins. All subsequent admin login and session\n   * refresh flows rely on successful join.\n   *\n   * @param connection\n   * @param body Admin registration payload: email and hashed password\n   *   (password_hash).\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @TypedBody()\n    body: ITodoListAdmin.ICreate,\n  ): Promise<ITodoListAdmin.IAuthorized> {\n    try {\n      return await postAuthAdminJoin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate an admin account from todo_list_admins and issue JWT access\n   * and refresh tokens.\n   *\n   * This API provides administrator login via email and password as defined in\n   * todo_list_admins. Email must be unique and previously registered. Password\n   * authentication is implemented by comparing the received password, securely\n   * hashed, to the stored password_hash field. Admin status is strictly\n   * enforced via membership in the todo_list_admins table; regular users are\n   * not permitted to authenticate as admins.\n   *\n   * Upon successful authentication, the endpoint generates and returns new\n   * access and refresh tokens, encapsulated as required for privileged\n   * sessions. JWT tokens contain admin role and identity claims to distinguish\n   * access scope.\n   *\n   * No further user attributes are referenced, and only fields email and\n   * password_hash from the schema are required to validate credentials. The\n   * schema requires all admin emails to be unique, reducing impersonation\n   * risk.\n   *\n   * For security, ensure passwords are always transmitted securely and never\n   * logged or exposed. Login attempts are limited to prevent brute-force\n   * attacks as dictated in higher-level security policy and business rules\n   * documents.\n   *\n   * This endpoint is essential to admin authentication and is required before\n   * any privileged or system-wide access is granted. The tokens returned are\n   * used for all subsequent admin-level operations until expiration or\n   * revocation.\n   *\n   * @param connection\n   * @param body Authentication payload: admin email and password (plain).\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(\n    @TypedBody()\n    body: ITodoListAdmin.ILogin,\n  ): Promise<ITodoListAdmin.IAuthorized> {\n    try {\n      return await postAuthAdminLogin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh an admin JWT access and refresh token set for ongoing sessions.\n   *\n   * This API endpoint enables administrators to renew their session by\n   * presenting a valid refresh token, as per JWT session lifecycle for admin\n   * accounts managed in todo_list_admins. It uses the refresh token to validate\n   * the admin's identity and re-issues a new pair of access and refresh tokens\n   * on success. Only tokens mapped to an existing admin's identity in\n   * todo_list_admins are valid for refresh.\n   *\n   * No extra data fields are referenced from the admin schema beyond identity\n   * linkage required by the token. This operation is essential for maintaining\n   * secure and continuous admin sessions without repeated credentials entry.\n   *\n   * Security best practices mandate that expired, revoked, or invalid refresh\n   * tokens must be rejected. Tokens are tied directly to admin accounts and\n   * cannot be shared or used cross-role or cross-user. The JWT contents encode\n   * admin role information and enforce privilege separation from regular users\n   * in the system.\n   *\n   * No password or email is required for this operation—only the refresh token\n   * supplied by the client. This endpoint is a foundational part of admin\n   * authentication flows and supports stateless, scalable session management\n   * for admins.\n   *\n   * This operation is necessary to maintain admin authentication state and\n   * avoid repeated logins. All advanced admin functions require a non-expired\n   * valid access token issued through the login or refresh endpoints.\n   *\n   * @param connection\n   * @param body Refresh token request, typically providing the current refresh\n   *   token.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @TypedBody()\n    body: ITodoListAdmin.IRefresh,\n  ): Promise<ITodoListAdmin.IAuthorized> {\n    try {\n      return await postAuthAdminRefresh({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoList/admin/users/TodolistAdminUsersController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchTodoListAdminUsers } from \"../../../../providers/patchTodoListAdminUsers\";\nimport { AdminAuth } from \"../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../decorators/payload/AdminPayload\";\nimport { getTodoListAdminUsersUserId } from \"../../../../providers/getTodoListAdminUsersUserId\";\nimport { putTodoListAdminUsersUserId } from \"../../../../providers/putTodoListAdminUsersUserId\";\nimport { deleteTodoListAdminUsersUserId } from \"../../../../providers/deleteTodoListAdminUsersUserId\";\n\nimport { IPageITodoListUser } from \"../../../../api/structures/IPageITodoListUser\";\nimport { ITodoListUser } from \"../../../../api/structures/ITodoListUser\";\n\n@Controller(\"/todoList/admin/users\")\nexport class TodolistAdminUsersController {\n  /**\n   * List all registered users with paging and search (admin only).\n   *\n   * Retrieve a paginated and optionally filtered list of all registered user\n   * accounts in the minimal Todo List application. This endpoint allows\n   * administrators to search by email and supports pagination for large numbers\n   * of users, leveraging the todo_list_users table as defined in the schema.\n   *\n   * The endpoint enforces access restrictions: only authenticated\n   * administrators can use this operation. Regular users are forbidden from\n   * accessing this API. Results include all standard fields (user id, email,\n   * timestamps) but do not contain password hashes or other sensitive\n   * information.\n   *\n   * Common use cases include system administration, maintenance, and audit\n   * reviews by privileged staff. Related endpoints manage creation, update, or\n   * deletion of users and their associated data.\n   *\n   * @param connection\n   * @param body Request parameters for user search, including email filter and\n   *   pagination controls\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoListUser.IRequest,\n  ): Promise<IPageITodoListUser.ISummary> {\n    try {\n      return await patchTodoListAdminUsers({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get details for a specific user account (admin only).\n   *\n   * Retrieve full information about a single user registered in the minimal\n   * Todo List application, using the provided userId as a lookup. This endpoint\n   * accesses the todo_list_users table and is intended strictly for\n   * administrative use, enforcing security via authentication and role checks.\n   *\n   * Returned data includes the user's id, email, account creation and update\n   * timestamps, and does not include password hashes. Only administrators can\n   * access this endpoint for any userId; regular users may not use this\n   * endpoint.\n   *\n   * This API complements other endpoints for user creation, update, and\n   * deletion, allowing administrators to inspect account-specific data as\n   * needed for auditing or maintenance.\n   *\n   * @param connection\n   * @param userId Unique identifier for the user to be retrieved\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":userId\")\n  public async at(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListUser> {\n    try {\n      return await getTodoListAdminUsersUserId({\n        admin,\n        userId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update a specific user's information by ID (admin only).\n   *\n   * Update the properties (e.g., email, password hash) of a registered user in\n   * the minimal Todo List app, targeting the user account identified by userId.\n   * This operation modifies the todo_list_users table, enforcing all business\n   * rules for uniqueness, permissions, and field validation.\n   *\n   * Only administrators may perform this operation, and all field updates must\n   * comply with data constraints: unique, properly formatted email; hashed\n   * password; and required timestamps. Upon successful update, updated_at is\n   * set to the current timestamp. Sensitive operations are logged for audit\n   * purposes.\n   *\n   * This API is designed for rare administrative corrections, security\n   * responses, or manual account management; regular users cannot update other\n   * user records via this endpoint.\n   *\n   * @param connection\n   * @param userId Unique identifier of the user to be updated\n   * @param body Object containing updatable user fields (such as email or\n   *   password hash)\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":userId\")\n  public async update(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListUser.IUpdate,\n  ): Promise<ITodoListUser> {\n    try {\n      return await putTodoListAdminUsersUserId({\n        admin,\n        userId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a user and cascade-remove all their todos (admin only).\n   *\n   * Permanently remove a user account, including all owned todo tasks, from the\n   * system. This operation acts on the todo_list_users table, using the\n   * provided userId as the target. It enforces security, allowing only\n   * authenticated administrators to invoke it. The delete is physically\n   * executed (hard delete), severing all related data rather than simply\n   * flagging records as deleted.\n   *\n   * Upon successful completion, the user account and all todos connected\n   * through the foreign key to todo_list_todos are erased. This supports\n   * privacy mandates and prevents orphaned or leaked records. No response body\n   * is returned if successful; errors are signaled with appropriate codes and\n   * messages in case of permission, referential, or internal failures.\n   *\n   * This endpoint is to be used by administrators in the rare case of account\n   * removal due to user request, policy violation, or data privacy obligations.\n   * Irrecoverable data loss is a consequence, so extra audit logging or\n   * confirmation mechanisms should be employed by clients.\n   *\n   * @param connection\n   * @param userId Unique identifier of the user to be deleted\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":userId\")\n  public async erase(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoListAdminUsersUserId({\n        admin,\n        userId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoList/admin/admins/TodolistAdminAdminsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchTodoListAdminAdmins } from \"../../../../providers/patchTodoListAdminAdmins\";\nimport { AdminAuth } from \"../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../decorators/payload/AdminPayload\";\nimport { getTodoListAdminAdminsAdminId } from \"../../../../providers/getTodoListAdminAdminsAdminId\";\nimport { putTodoListAdminAdminsAdminId } from \"../../../../providers/putTodoListAdminAdminsAdminId\";\nimport { deleteTodoListAdminAdminsAdminId } from \"../../../../providers/deleteTodoListAdminAdminsAdminId\";\n\nimport { IPageITodoListAdmin } from \"../../../../api/structures/IPageITodoListAdmin\";\nimport { ITodoListAdmin } from \"../../../../api/structures/ITodoListAdmin\";\n\n@Controller(\"/todoList/admin/admins\")\nexport class TodolistAdminAdminsController {\n  /**\n   * Search and retrieve a paginated list of administrator accounts from\n   * todo_list_admins.\n   *\n   * This API operation returns a filtered and paginated list of administrator\n   * accounts registered in the system. It operates over the todo_list_admins\n   * table, providing system-wide visibility for superusers and allowing easy\n   * search, filtering, and sorting based on email or the account creation\n   * date.\n   *\n   * Authorization is strictly required: only users with the admin role may\n   * access this endpoint, as regular users are never permitted to view or\n   * manage administrator information. The returned data excludes sensitive\n   * fields such as password hashes, focusing only on operational metadata.\n   *\n   * The operation is essential for maintenance, emergency support, and security\n   * audits. It is typically paired with endpoints for viewing the details of a\n   * specific administrator or for performing create, update, or delete actions.\n   * Error scenarios include forbidden access for non-admins, validation\n   * failures on filter parameters, and unexpected server errors.\n   *\n   * @param connection\n   * @param body Filtering and pagination criteria for listing administrators.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoListAdmin.IRequest,\n  ): Promise<IPageITodoListAdmin.ISummary> {\n    try {\n      return await patchTodoListAdminAdmins({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get detailed information for a specific administrator by adminId from\n   * todo_list_admins.\n   *\n   * This API operation provides authorized admin users with the full metadata\n   * profile of a particular administrator account, uniquely identified by\n   * adminId in the todo_list_admins table. It is used for viewing core\n   * attributes such as email, timestamps, and other audit-relevant fields,\n   * while ensuring that password hashes and other sensitive data remain\n   * undisclosed.\n   *\n   * Access to this endpoint is restricted strictly to users with admin\n   * privileges. Security and privacy are enforced at the endpoint and service\n   * layer. The information supplied helps with system maintenance, user audits,\n   * or when troubleshooting admin privileges and actions.\n   *\n   * Related operations include listing all admins and enabling update or delete\n   * actions by adminId. Error responses include forbidden access for\n   * non-admins, not found for missing adminId, and resource access violations\n   * for unauthorized requests.\n   *\n   * @param connection\n   * @param adminId The unique identifier (UUID) of the administrator to\n   *   retrieve.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":adminId\")\n  public async at(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListAdmin> {\n    try {\n      return await getTodoListAdminAdminsAdminId({\n        admin,\n        adminId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update administrator profile details for a target admin, identified by\n   * adminId.\n   *\n   * This API endpoint allows authorized admin users to update an administrator\n   * record in the todo_list_admins table, selected by the adminId parameter.\n   * Supported fields for update typically include the admin's email address and\n   * a new password hash, as well as tracking changes in the updated_at\n   * timestamp for audit.\n   *\n   * Strict access controls are in effect: only users with admin privileges may\n   * invoke this operation. Changing adminId is not permitted; all updates are\n   * constrained to permitted fields. The response supplies the new metadata\n   * profile after updating.\n   *\n   * Related endpoints include detail retrieval, list, and delete actions.\n   * Errors include forbidden for non-admins, not found for invalid adminId, and\n   * validation errors on input data.\n   *\n   * @param connection\n   * @param adminId The unique identifier (UUID) of the administrator to update.\n   * @param body New metadata for the administrator, such as email or password\n   *   hash, to apply to the target adminId.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":adminId\")\n  public async update(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListAdmin.IUpdate,\n  ): Promise<ITodoListAdmin> {\n    try {\n      return await putTodoListAdminAdminsAdminId({\n        admin,\n        adminId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a specific administrator account, identified by adminId (hard\n   * delete) from todo_list_admins.\n   *\n   * This API operation allows an authorized admin to permanently remove an\n   * administrator account from the todo_list_admins table, selecting the record\n   * by adminId. The deletion is irreversible: the record is physically removed,\n   * along with the associated email and password data. As there is no\n   * deleted_at or similar soft delete flag in the schema, this is a hard delete\n   * operation.\n   *\n   * Access is strictly limited to admin users, and this action should only be\n   * performed with care, typically when an admin is leaving the organization or\n   * privileges must be revoked. The operation will log the deletion for audit\n   * purposes and enforce all necessary security checks.\n   *\n   * Potential errors include forbidden access for non-admins, not found for\n   * invalid adminId, and resource conflicts (e.g., if last remaining admin;\n   * business logic must ensure at least one admin remains).\n   *\n   * @param connection\n   * @param adminId The unique identifier (UUID) of the administrator to delete.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":adminId\")\n  public async erase(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoListAdminAdminsAdminId({\n        admin,\n        adminId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoList/user/todos/TodolistUserTodosController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { postTodoListUserTodos } from \"../../../../providers/postTodoListUserTodos\";\nimport { UserAuth } from \"../../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../../decorators/payload/UserPayload\";\nimport { patchTodoListUserTodos } from \"../../../../providers/patchTodoListUserTodos\";\nimport { getTodoListUserTodosTodoId } from \"../../../../providers/getTodoListUserTodosTodoId\";\nimport { putTodoListUserTodosTodoId } from \"../../../../providers/putTodoListUserTodosTodoId\";\nimport { deleteTodoListUserTodosTodoId } from \"../../../../providers/deleteTodoListUserTodosTodoId\";\n\nimport { ITodoListTodo } from \"../../../../api/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"../../../../api/structures/IPageITodoListTodo\";\n\n@Controller(\"/todoList/user/todos\")\nexport class TodolistUserTodosController {\n  /**\n   * Create a new Todo item for the current authenticated user.\n   *\n   * Create a new Todo item for the authenticated user. The title field is\n   * mandatory, must be trimmed, non-empty, and no longer than 100 characters.\n   * On creation, the item is marked incomplete, and all timestamps (creation,\n   * update) are set to the current time. Ownership association is automatic,\n   * ensuring users cannot create Todos for others; admin users can also create\n   * Todos for their own admin account.\n   *\n   * Any business-rule or validation violations, such as duplicate titles (if\n   * such logic is enforced in application), title length issues, or\n   * whitespace-only titles, are reported with clear error messages. Only fields\n   * defined in the minimal schema (id, title, is_completed, timestamps, user\n   * ownership) are processed. The operation does not support setting completed\n   * or deleted fields upon creation; these fields are managed by update\n   * endpoints or internal logic.\n   *\n   * @param connection\n   * @param body Data required for creating a new Todo item: minimal, only title\n   *   required.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post()\n  public async create(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoListTodo.ICreate,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await postTodoListUserTodos({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search and retrieve a filtered, paginated list of Todo items.\n   *\n   * Retrieve a filtered, paginated list of Todo items using advanced search\n   * capabilities. This operation is available to authenticated users wishing to\n   * view their own todos, or to administrators wishing to view all users'\n   * todos. The returned data is sorted in reverse-chronological order by\n   * creation date, as described in the requirements.\n   *\n   * Authorization and role validation are enforced so that standard users can\n   * access only their own todos, while admins can access the entire dataset.\n   * Text search for task titles and filtering by completion status are included\n   * based on application-level logic. Validation ensures users may not access\n   * data outside their permission scope.\n   *\n   * Results are paginated for efficiency and may be further sorted or filtered\n   * as required by client use cases. The type definitions for both the request\n   * and response DTOs are based directly on the minimal todo_list_todos schema\n   * structure, including PK, title, completion status, timestamps, and\n   * ownership references (for admin views).\n   *\n   * @param connection\n   * @param body Filter, search, and pagination options for retrieving Todo\n   *   items.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoListTodo.IRequest,\n  ): Promise<IPageITodoListTodo.ISummary> {\n    try {\n      return await patchTodoListUserTodos({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve the details of a specific Todo item by ID.\n   *\n   * Retrieve the details of a specific Todo item given its unique identifier.\n   * This operation enforces security by confirming that the requester is either\n   * the owner of the Todo (standard user) or has administrative privileges. The\n   * detailed response includes all relevant schema fields: id, belonged user\n   * id, title, completion status, creation timestamp, last updated timestamp,\n   * completion timestamp, and deleted timestamp (for soft-deleted items).\n   *\n   * If the Todo is not found or the requesting user lacks permission, the\n   * system returns an appropriate error. This function is essential to enable\n   * clients to display or further manipulate a single Todo item in detail. Any\n   * fields not present in the minimal schema are excluded from the response.\n   *\n   * @param connection\n   * @param todoId Unique identifier for the target Todo item.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":todoId\")\n  public async at(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await getTodoListUserTodosTodoId({\n        user,\n        todoId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update a specific Todo item’s title or completion status.\n   *\n   * Update the details of an existing Todo item, as specified by its UUID. The\n   * operation enforces strict validation for title updates: the title must be\n   * non-empty, without leading or trailing whitespace, and within the\n   * 100-character schema constraint. The operation supports updating the\n   * is_completed flag, managing the completed_at timestamp accordingly: if a\n   * Todo is marked complete, completed_at is set; if marked as incomplete,\n   * completed_at is cleared.\n   *\n   * Only users who own the Todo can update it, except for admin users who may\n   * update any item. All changes are subject to full field validation as\n   * specified in the business rules. The updated Todo is returned in the\n   * response. If permission is denied, or if the item does not exist, the\n   * operation returns a clear error.\n   *\n   * @param connection\n   * @param todoId Unique identifier for the Todo item to update.\n   * @param body New values for the Todo's fields: title and/or completion\n   *   status.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":todoId\")\n  public async update(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListTodo.IUpdate,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await putTodoListUserTodosTodoId({\n        user,\n        todoId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Permanently delete a Todo task from the todo_list_todos table by its ID.\n   *\n   * This API operation deletes a specific Todo task from the todo_list_todos\n   * table. Only authenticated users can invoke this endpoint, and business\n   * logic must ensure either that the requester is the owner of the todo or has\n   * admin privileges. If the user is not the owner and is not an administrator,\n   * the operation is denied.\n   *\n   * The operation takes the todoId as a path parameter. The todoId must be a\n   * valid UUID corresponding to an existing Todo task. If no such Todo exists,\n   * the service should return an error or not-found status. Upon successful\n   * deletion, the Todo task is permanently removed from the database and cannot\n   * be recovered via standard means. The operation does not return a response\n   * body; a successful status code confirms deletion.\n   *\n   * The todo_list_todos table defines the association between Todo tasks and\n   * users. Owning users are identified by the todo_list_user_id foreign key.\n   * The deleted_at column exists for potential future extensibility regarding\n   * soft deletes, but this operation performs a true hard delete, erasing both\n   * data and all related links. Admin users may invoke this operation on any\n   * todo, and all permission management should be implemented in\n   * business/service logic.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the Todo task to be deleted (UUID\n   *   format).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":todoId\")\n  public async erase(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoListUserTodosTodoId({\n        user,\n        todoId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoList/admin/todos/TodolistAdminTodosController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { postTodoListAdminTodos } from \"../../../../providers/postTodoListAdminTodos\";\nimport { AdminAuth } from \"../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../decorators/payload/AdminPayload\";\nimport { patchTodoListAdminTodos } from \"../../../../providers/patchTodoListAdminTodos\";\nimport { getTodoListAdminTodosTodoId } from \"../../../../providers/getTodoListAdminTodosTodoId\";\nimport { putTodoListAdminTodosTodoId } from \"../../../../providers/putTodoListAdminTodosTodoId\";\nimport { deleteTodoListAdminTodosTodoId } from \"../../../../providers/deleteTodoListAdminTodosTodoId\";\n\nimport { ITodoListTodo } from \"../../../../api/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"../../../../api/structures/IPageITodoListTodo\";\n\n@Controller(\"/todoList/admin/todos\")\nexport class TodolistAdminTodosController {\n  /**\n   * Create a new Todo item for the current authenticated user.\n   *\n   * Create a new Todo item for the authenticated user. The title field is\n   * mandatory, must be trimmed, non-empty, and no longer than 100 characters.\n   * On creation, the item is marked incomplete, and all timestamps (creation,\n   * update) are set to the current time. Ownership association is automatic,\n   * ensuring users cannot create Todos for others; admin users can also create\n   * Todos for their own admin account.\n   *\n   * Any business-rule or validation violations, such as duplicate titles (if\n   * such logic is enforced in application), title length issues, or\n   * whitespace-only titles, are reported with clear error messages. Only fields\n   * defined in the minimal schema (id, title, is_completed, timestamps, user\n   * ownership) are processed. The operation does not support setting completed\n   * or deleted fields upon creation; these fields are managed by update\n   * endpoints or internal logic.\n   *\n   * @param connection\n   * @param body Data required for creating a new Todo item: minimal, only title\n   *   required.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post()\n  public async create(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoListTodo.ICreate,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await postTodoListAdminTodos({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search and retrieve a filtered, paginated list of Todo items.\n   *\n   * Retrieve a filtered, paginated list of Todo items using advanced search\n   * capabilities. This operation is available to authenticated users wishing to\n   * view their own todos, or to administrators wishing to view all users'\n   * todos. The returned data is sorted in reverse-chronological order by\n   * creation date, as described in the requirements.\n   *\n   * Authorization and role validation are enforced so that standard users can\n   * access only their own todos, while admins can access the entire dataset.\n   * Text search for task titles and filtering by completion status are included\n   * based on application-level logic. Validation ensures users may not access\n   * data outside their permission scope.\n   *\n   * Results are paginated for efficiency and may be further sorted or filtered\n   * as required by client use cases. The type definitions for both the request\n   * and response DTOs are based directly on the minimal todo_list_todos schema\n   * structure, including PK, title, completion status, timestamps, and\n   * ownership references (for admin views).\n   *\n   * @param connection\n   * @param body Filter, search, and pagination options for retrieving Todo\n   *   items.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoListTodo.IRequest,\n  ): Promise<IPageITodoListTodo.ISummary> {\n    try {\n      return await patchTodoListAdminTodos({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve the details of a specific Todo item by ID.\n   *\n   * Retrieve the details of a specific Todo item given its unique identifier.\n   * This operation enforces security by confirming that the requester is either\n   * the owner of the Todo (standard user) or has administrative privileges. The\n   * detailed response includes all relevant schema fields: id, belonged user\n   * id, title, completion status, creation timestamp, last updated timestamp,\n   * completion timestamp, and deleted timestamp (for soft-deleted items).\n   *\n   * If the Todo is not found or the requesting user lacks permission, the\n   * system returns an appropriate error. This function is essential to enable\n   * clients to display or further manipulate a single Todo item in detail. Any\n   * fields not present in the minimal schema are excluded from the response.\n   *\n   * @param connection\n   * @param todoId Unique identifier for the target Todo item.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":todoId\")\n  public async at(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await getTodoListAdminTodosTodoId({\n        admin,\n        todoId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update a specific Todo item’s title or completion status.\n   *\n   * Update the details of an existing Todo item, as specified by its UUID. The\n   * operation enforces strict validation for title updates: the title must be\n   * non-empty, without leading or trailing whitespace, and within the\n   * 100-character schema constraint. The operation supports updating the\n   * is_completed flag, managing the completed_at timestamp accordingly: if a\n   * Todo is marked complete, completed_at is set; if marked as incomplete,\n   * completed_at is cleared.\n   *\n   * Only users who own the Todo can update it, except for admin users who may\n   * update any item. All changes are subject to full field validation as\n   * specified in the business rules. The updated Todo is returned in the\n   * response. If permission is denied, or if the item does not exist, the\n   * operation returns a clear error.\n   *\n   * @param connection\n   * @param todoId Unique identifier for the Todo item to update.\n   * @param body New values for the Todo's fields: title and/or completion\n   *   status.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":todoId\")\n  public async update(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListTodo.IUpdate,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await putTodoListAdminTodosTodoId({\n        admin,\n        todoId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Permanently delete a Todo task from the todo_list_todos table by its ID.\n   *\n   * This API operation deletes a specific Todo task from the todo_list_todos\n   * table. Only authenticated users can invoke this endpoint, and business\n   * logic must ensure either that the requester is the owner of the todo or has\n   * admin privileges. If the user is not the owner and is not an administrator,\n   * the operation is denied.\n   *\n   * The operation takes the todoId as a path parameter. The todoId must be a\n   * valid UUID corresponding to an existing Todo task. If no such Todo exists,\n   * the service should return an error or not-found status. Upon successful\n   * deletion, the Todo task is permanently removed from the database and cannot\n   * be recovered via standard means. The operation does not return a response\n   * body; a successful status code confirms deletion.\n   *\n   * The todo_list_todos table defines the association between Todo tasks and\n   * users. Owning users are identified by the todo_list_user_id foreign key.\n   * The deleted_at column exists for potential future extensibility regarding\n   * soft deletes, but this operation performs a true hard delete, erasing both\n   * data and all related links. Admin users may invoke this operation on any\n   * todo, and all permission management should be implemented in\n   * business/service logic.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the Todo task to be deleted (UUID\n   *   format).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":todoId\")\n  public async erase(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoListAdminTodosTodoId({\n        admin,\n        todoId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n"},"compiled":{"type":"success"},"created_at":"2025-10-02T06:05:05.764Z","completed_at":"2025-10-02T06:13:12.395Z","step":0}]