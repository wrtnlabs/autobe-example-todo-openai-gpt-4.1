import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { post__auth_user_verify_email } from "../../../../providers/post__auth_user_verify_email";

import { ITodoListUser } from "../../../../api/structures/ITodoListUser";

@Controller("/auth/user/verify-email")
export class AuthUserVerify_emailController {
  /**
   * Verify new user email post-registration in todo_list_users (sets
   * is_email_verified to true for authentication enablement).
   *
   * This endpoint verifies ownership of a user's email address
   * post-registration, operating on the todo_list_users table. Upon successful
   * submission of a valid token and user identification (id), the field
   * 'is_email_verified' is set to true, unlocking authentication and full
   * service access for the user. This operation rejects attempts for
   * already-verified accounts, deleted users ('deleted_at' not null), or
   * invalid/expired verification tokens, returning error details as per
   * business policy.
   *
   * The email verification process is required by business authentication rules
   * and supports compliance with common account lifecycle management practices.
   * Timestamps are updated accordingly in 'updated_at' for the user record. The
   * endpoint produces change audit logs for traceability but does not issue
   * tokens; users must subsequently login/refresh using other endpoints. This
   * operation is critical for onboarding/anti-abuse and may be required after
   * email changes or account migration scenarios.
   *
   * @param connection
   * @param body User email verification request, typically includes user ID and
   *   a verification token.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async verifyEmail(
    @TypedBody()
    body: ITodoListUser.IVerifyEmail,
  ): Promise<ITodoListUser.IVerifyEmailResult> {
    try {
      return await post__auth_user_verify_email({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
