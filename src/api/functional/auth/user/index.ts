import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListUser } from "../../../structures/ITodoListUser";

/**
 * Register a new user account in todo_list_users and provision JWT tokens
 * (role: user).
 *
 * This API operation allows creation of a new user account for the regular user
 * role, referencing the todo_list_users table in the Prisma schema. The join
 * operation enables end users to register with their email and password,
 * provided fields are unique and conform to database constraints.
 *
 * The handler validates the email is not already present in
 * todo_list_users.email, checks that the password_hash meets required security
 * standards, and initializes the status field (for instance 'active') according
 * to business logic. Upon registration, only defined table fields such as
 * email, password_hash, name (optional), and status are stored—no extraneous
 * data is accepted. Errors arising from unique constraint violations or
 * required field omissions are surfaced with business-appropriate messages.
 *
 * The operation is only accessible to users not currently authenticated.
 * Registration success results in issuing a JWT access token plus a refresh
 * token, encoding user id from todo_list_users.id and assigning the "user"
 * role. The response conforms to the ITodoListUser.IAuthorized DTO format. Any
 * edge cases, such as attempting to register with a deactivated, suspended, or
 * previously soft-deleted email, are handled in accordance with the current
 * value of the deleted_at and status columns in todo_list_users.
 *
 * This endpoint is foundational for onboarding, integrating directly with the
 * login, refresh, and password management endpoints within the user
 * authentication flow. If registration is unsuccessful, the operation does not
 * leak details about which field(s) caused failure beyond standard error
 * handling. It is closely related to the todo_list_users Prisma DB model and
 * must align with all its business documentation.
 *
 * @param props.connection
 * @param props.body Information required to create a new user account (email,
 *   password_hash, optional name/avatar for profile, initial status as per
 *   business logic).
 * @setHeader token.access Authorization
 *
 * @path /auth/user/join
 * @accessor api.functional.auth.user.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Information required to create a new user account (email,
     * password_hash, optional name/avatar for profile, initial status as
     * per business logic).
     */
    body: ITodoListUser.IJoin;
  };
  export type Body = ITodoListUser.IJoin;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/join";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a user from todo_list_users, issue new JWT session tokens (role:
 * user).
 *
 * This operation enables existing registered users to authenticate to the todo
 * list application via email and password, as stored in the todo_list_users
 * table. The system hashes the supplied password and matches it against
 * todo_list_users.password_hash for the email record. Logins are allowed only
 * for users with status indicating active account and a null value for
 * deleted_at. On a successful login, new JWT access and refresh tokens are
 * generated as specified by business rules, with the user id and "user" role
 * included in tokens. The last_login_at field is updated to the present time
 * for audit and security tracking.
 *
 * If authentication fails, the system returns a standard login error message,
 * never exposing which field—email or password—caused failure. Error reporting
 * follows business guidelines and must not enable user enumeration attacks. The
 * system checks only real schema fields (email, password_hash, status,
 * deleted_at).
 *
 * Successful logins enable access to all authorized API endpoints for the user
 * role. This operation seamlessly connects to related endpoints such as
 * refresh, password-reset (if implemented), and general user session
 * management. It is always consistent with the todo_list_users schema and omits
 * extraneous logic or fields.
 *
 * @param props.connection
 * @param props.body User login credentials: email address and raw password (to
 *   be hashed before comparison).
 * @setHeader token.access Authorization
 *
 * @path /auth/user/login
 * @accessor api.functional.auth.user.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * User login credentials: email address and raw password (to be hashed
     * before comparison).
     */
    body: ITodoListUser.ILogin;
  };
  export type Body = ITodoListUser.ILogin;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/login";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Renew JWT session tokens for a user by validating a refresh token against
 * todo_list_users.
 *
 * This API operation allows registered user accounts to renew their JWT session
 * using a valid refresh token referencing an active record in todo_list_users.
 * The handler extracts and verifies the token, checks the status and ensures
 * deleted_at is null for the related user, then issues a fresh JWT
 * access/refresh token pair. If the token is expired, revoked, or references an
 * ineligible account (wrong status or soft-deleted), errors are reported per
 * business rules.
 *
 * Only fields actually defined in the schema (status, deleted_at, etc.) are
 * used for account checks. Upon a successful refresh, the service updates the
 * last_login_at if specified in application logic. No credentials are required
 * in the request; all context comes from the presented refresh token.
 *
 * This operation is related to login, join, and any password/session management
 * flows, forming the core of the user's ongoing authentication lifecycle. Only
 * operations present in todo_list_users, including necessary validation fields,
 * are referenced.
 *
 * @param props.connection
 * @param props.body Valid JWT refresh token referencing a todo_list_users
 *   account for session renewal.
 * @setHeader token.access Authorization
 *
 * @path /auth/user/refresh
 * @accessor api.functional.auth.user.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Valid JWT refresh token referencing a todo_list_users account for
     * session renewal.
     */
    body: ITodoListUser.IRefresh;
  };
  export type Body = ITodoListUser.IRefresh;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/refresh";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
