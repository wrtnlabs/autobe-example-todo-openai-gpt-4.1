import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListUser } from "../../../structures/ITodoListUser";

/**
 * Register a new todo_list_user account and issue authentication tokens.
 *
 * This registration endpoint allows users to sign up for the Todo List
 * application by providing a unique email address and password. The process
 * creates a record in the todo_list_user table, which is the main actor entity
 * representing all regular users and owners of todo items.
 *
 * Registration utilizes the 'email' as the core identifier, enforcing
 * uniqueness as per schema constraints. Passwords submitted are hashed and
 * stored in the 'password_hash' column, ensuring no plain text passwords are
 * ever persisted or exposed in responses, aligning with security requirements.
 *
 * Role-based business logic restricts this operation to unauthenticated clients
 * only. Permissions enforce that already-registered (authenticated) users are
 * blocked from accessing this operation for themselves, promoting
 * single-account policy by design.
 *
 * Upon successful registration, initial JWT access/refresh tokens are provided,
 * granting full authenticated session rights matching the 'user' role, as
 * allowed in the permissions matrix.
 *
 * This endpoint is tightly coupled with the login and token refresh operations,
 * forming the core user account lifecycle. All error handling around
 * uniqueness, validation, and secure storage is derived directly from the
 * todo_list_user schema fields.
 *
 * @param props.connection
 * @param props.body Registration information for a new user (email, password).
 * @setHeader token.access Authorization
 *
 * @path /auth/user/join
 * @accessor api.functional.auth.user.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration information for a new user (email, password). */
    body: ITodoListUser.IJoin;
  };
  export type Body = ITodoListUser.IJoin;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/join";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a todo_list_user and issue new tokens.
 *
 * Authenticates a registered Todo List user by verifying submitted email and
 * password credentials against the todo_list_user table. Matches the supplied
 * email, then compares the provided password (after hashing) with the stored
 * password_hash. Authentication success results in the issuance of JWT access
 * and refresh tokens compliant with session policies for the 'user' role.
 *
 * All fields handled map directly to the todo_list_user tableâ€”primarily 'email'
 * and 'password_hash' (used internally). Authentication tokens returned are
 * constructed without exposing any sensitive fields or database identifiers.
 *
 * Role-based business logic ensures this operation is available only to
 * unauthenticated users. Existing sessions must be invalidated or expired
 * before invoking login again.
 *
 * Security is paramount: rate limiting may be applied to repeated failed
 * attempts per system policy (not encoded in this schema). All error returns
 * are generic, never indicating which field was incorrect, to minimize
 * information leakage.
 *
 * This login operation is the required companion to join (registration) and
 * refresh (token renewal) for complete account/session lifecycle management.
 *
 * @param props.connection
 * @param props.body Login credentials for existing user (email, password).
 * @setHeader token.access Authorization
 *
 * @path /auth/user/login
 * @accessor api.functional.auth.user.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login credentials for existing user (email, password). */
    body: ITodoListUser.ILogin;
  };
  export type Body = ITodoListUser.ILogin;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/login";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT tokens for a todo_list_user session.
 *
 * This token refresh endpoint provides authenticated Todo List users a means to
 * renew their session by presenting a valid refresh token issued during
 * previous login or registration. It validates the refresh token, confirms its
 * association with an existing todo_list_user, and, if valid and unexpired,
 * issues a new set of access and refresh tokens for seamless session
 * continuation.
 *
 * Token logic is implemented per security and session policy: access tokens are
 * short-lived (30 minutes), while refresh tokens may be valid up to 30 days,
 * conforming to the requirements in the business documentation and permission
 * matrix.
 *
 * The token refresh process is stateless regarding the underlying
 * todo_list_user schema; it does not alter, create, or remove table records. It
 * simply reads and verifies minimal identifying fields linked to the user's
 * identity. No sensitive info is returned.
 *
 * Security and session enforcement is maintained: expired, invalid, or tampered
 * tokens result in error responses and session invalidation, supporting robust
 * access control.
 *
 * This operation is required to maintain authenticated user workflows,
 * supporting login and join (registration) as the main entry points for session
 * initialization.
 *
 * @param props.connection
 * @param props.body Refresh token for session renewal process.
 * @setHeader token.access Authorization
 *
 * @path /auth/user/refresh
 * @accessor api.functional.auth.user.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token for session renewal process. */
    body: ITodoListUser.IRefresh;
  };
  export type Body = ITodoListUser.IRefresh;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/refresh";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
