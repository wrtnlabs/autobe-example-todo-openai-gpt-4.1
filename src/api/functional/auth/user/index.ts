import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListUser } from "../../../structures/ITodoListUser";
export * as verify_email from "./verify_email";
export * as request_password_reset from "./request_password_reset";
export * as reset_password from "./reset_password";

/**
 * Register a new user account in the todo_list_users table (authentication join
 * operation) for registration and onboarding.
 *
 * This endpoint registers a new user in the 'todo_list_users' table, storing
 * email and a securely hashed password. The 'email' field is required, must be
 * unique, and is used for authentication and communication. The 'password_hash'
 * field stores a salted hash of the user's password, never the plain password;
 * validation and hashing are performed prior to persistence, protecting against
 * common security attacks. The 'is_email_verified' flag is initialized to
 * false, requiring users to complete an email verification flow before full
 * access is granted, as referenced by the schema description. Timestamps for
 * account creation and updates ('created_at', 'updated_at') are managed
 * automatically to enable auditing and compliance.
 *
 * This operation requires strict validation to enforce unique emails
 * (case-insensitive) and strong password rules as dictated by business policy.
 * Attempts to register using an existing email return a specific error. Upon
 * successful registration, email verification is initiated, and access tokens
 * are only issued after successful confirmation. Sensitive information, such as
 * 'password_hash' and internal audit fields, are excluded from API responses.
 *
 * Security is paramount; all fields are verified for proper format, uniqueness,
 * and strength prior to account creation. No authentication is required to
 * access this operation, but access is rate-limited to prevent abuse. Directly
 * integrates with login and password reset flows to enable secure credential
 * management for the user role.
 *
 * Deletion of the created account or updates to email/password are handled by
 * separate endpoints. This operation's activity is logged for audit and privacy
 * compliance. All authentication workflows for 'user' originate here, and all
 * user-owned resources in related tables cascade upon full account deletion.
 *
 * @param props.connection
 * @param props.body Registration information for creating a new user account
 *   (email, password).
 * @setHeader token.access Authorization
 *
 * @path /auth/user/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration information for creating a new user account (email,
     * password).
     */
    body: ITodoListUser.IJoin;
  };
  export type Body = ITodoListUser.IJoin;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/join";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * User login/authentication for the todo_list_users table (login to receive JWT
 * access and refresh tokens).
 *
 * This endpoint authenticates a user via credentials (email and password) using
 * 'todo_list_users'. It enforces case-insensitive email lookup, explicit
 * null-check of 'deleted_at' (account must not be soft-deleted), and confirms
 * 'is_email_verified' is true before issuing authentication tokens. Passwords
 * are validated against the 'password_hash' field using a secure, salted
 * comparison that prevents timing attacks or credential leaks. On success,
 * issues JWT tokens and records a session in the 'todo_list_auth_sessions'
 * table for session auditing and active login management.
 *
 * Unsuccessful attempts are handled by business rules: generic error messages
 * are returned (never revealing if email or password was incorrect) and
 * repeated failed attempts are rate-limited to mitigate brute-force attacks. If
 * 'is_email_verified' is false, no login is permitted and a verification-needed
 * message is issued. If 'deleted_at' is not null, login is also prohibited,
 * indicating the account is disabled or deleted.
 *
 * No password hash or credential details are ever exposed to clients, and
 * successful authentications update last-used session information for security
 * monitoring. Password changes and global logout by session are handled via
 * other endpoints using the session and password reset tables described in the
 * schema. Logs authentication attempts for audit purposes and integrates
 * closely with join/registration and password reset operations.
 *
 * Operation requires no authentication to call, but all tokens and credentials
 * returned are subject to strict validation and business session expiration
 * policies. Only intended for the 'user' role as defined by the database
 * schema.
 *
 * @param props.connection
 * @param props.body Credentials for user authentication: email and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/user/login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Credentials for user authentication: email and password. */
    body: ITodoListUser.ILogin;
  };
  export type Body = ITodoListUser.ILogin;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/login";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT authentication tokens for 'user' role using
 * todo_list_auth_sessions (refresh token operation).
 *
 * This endpoint refreshes JWT authentication tokens for an authenticated
 * 'user'. It uses the 'todo_list_auth_sessions' table to validate the provided
 * session_token (refresh token) by checking for matching, active, unexpired,
 * and non-revoked session. It also confirms the linked user exists and is not
 * soft-deleted ('deleted_at' is null). Session expiration ('expires_at') and
 * revocation logic are strictly enforced per schema and business rules,
 * ensuring users can only refresh tokens when all security conditions are
 * satisfied.
 *
 * If the submitted refresh token is expired, revoked, or does not correspond to
 * a valid, active session, the operation fails with a specific error requiring
 * re-authentication via the login endpoint. Successful refreshes update
 * relevant session metadata (updated_at, user_agent, ip_address) and return new
 * JWT access/refresh tokens per the established session policy. All activity is
 * logged for compliance and security review, referencing the corresponding user
 * account.
 *
 * Operation is only available to authenticated users presenting a valid refresh
 * token (session_token); it does not require explicit authentication on call
 * but uses token validation per security best practices. Tightly integrated
 * with the login and join/register operations to provide seamless
 * authentication for the 'user' role defined in the schema.
 *
 * @param props.connection
 * @param props.body Refresh token request with session_token for the 'user'.
 * @setHeader token.access Authorization
 *
 * @path /auth/user/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token request with session_token for the 'user'. */
    body: ITodoListUser.IRefresh;
  };
  export type Body = ITodoListUser.IRefresh;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/refresh";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
