import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListAdmin } from "../../../structures/ITodoListAdmin";

/**
 * Register a new admin account (todo_list_admin table).
 *
 * This API operation allows for the creation of a new admin account in the Todo
 * List application, using the 'todo_list_admin' table as its persistent store.
 * The endpoint is intended as the main entry point for onboarding
 * administrators who will oversee user management, todo moderation, and enforce
 * business compliance.
 *
 * Account creation requires input fields for a unique 'email' and a securely
 * hashed 'password_hash', both enforced at the database and application layers
 * for unique constraint and non-reversible security, respectively. The admin
 * registration flow is independent from ordinary user account management,
 * providing role isolation for privileged operations.
 *
 * Timestamps for 'created_at' and 'updated_at' are set automatically on the
 * backend for audit logs and compliance traceability, as indicated by the
 * schema.
 *
 * Security considerations include strict uniqueness checks on 'email', the
 * requirement that passwords are never stored or returned in plain text, and
 * awareness that admin accounts created require further protection (e.g.,
 * protected enrollment, invitation, or separate admin channel) in production
 * deployments.
 *
 * This operation is related to admin authentication and the admin login
 * endpoint and is required as a precursor for 'admin login' and token refresh
 * workflows.
 *
 * @param props.connection
 * @param props.body Admin registration information (unique email, password
 *   hash).
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Admin registration information (unique email, password hash). */
    body: ITodoListAdmin.ICreate;
  };
  export type Body = ITodoListAdmin.ICreate;
  export type Response = ITodoListAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): ITodoListAdmin.IAuthorized =>
    typia.random<ITodoListAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate admin with email and password (todo_list_admin table).
 *
 * This API enables system administrators to authenticate and obtain access
 * tokens in the Todo List application, interacting directly with the
 * persistence layer defined by the 'todo_list_admin' schema. Admins must
 * provide their registered email and correct password, which is hashed and
 * checked against the 'password_hash' field. Successful login provides JWT
 * access and refresh tokens with the admin's identity, role, and permitted
 * session claims.
 *
 * Security practices enforced here include never returning raw password data
 * (all password handling is via hashes) and always auditing authentication
 * attempts using the schema-defined timestamps and audit infrastructure. Login
 * errors cover invalid credentials or non-existent admin accounts.
 *
 * Role-specific session controls are implemented, granting access only to admin
 * endpoints after successful authentication. This process is distinct from user
 * login, targeting only records in 'todo_list_admin'.
 *
 * Session token payloads include admin ID, issued-at and expiry timestamps, and
 * the 'admin' role claim as per business policy.
 *
 * Used in tandem with admin registration ('join') and session refresh endpoints
 * for a complete authentication lifecycle.
 *
 * @param props.connection
 * @param props.body Admin login credentials (email, password).
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Admin login credentials (email, password). */
    body: ITodoListAdmin.ILogin;
  };
  export type Body = ITodoListAdmin.ILogin;
  export type Response = ITodoListAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): ITodoListAdmin.IAuthorized =>
    typia.random<ITodoListAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh admin JWT session tokens using valid refresh token (todo_list_admin).
 *
 * This API operation allows authenticated admins to refresh their access and
 * refresh JWT tokens using a valid, non-expired refresh token, as prescribed by
 * the 'todo_list_admin' Prisma schema. Token rotation is critical to maintain
 * secure privileged access while enforcing session limitations, as required by
 * business compliance policies.
 *
 * The refresh logic uses the admin's identity from the refresh token, validates
 * session eligibility, and issues a new token pair, with no password or
 * credential resubmission needed. Token refresh can only be performed for
 * existing, authenticated admin accounts; no schema fields beyond 'id' and
 * uniqueness constraints are directly referenced in the operation.
 *
 * Expired, revoked, or tampered refresh tokens result in failed authentication
 * and informative business error reporting. New tokens' payload includes admin
 * ID, session timestamps, and 'admin' role as determined from the
 * 'todo_list_admin' table.
 *
 * Token management is integral to the admin authentication workflow, providing
 * session continuity following initial registration ('join') and authentication
 * ('login'). Security includes rate limits, logging, and session integrity
 * checks, with no sensitive credential leakage at any step.
 *
 * This operation complements the admin login flow and is required for secure
 * session renewal and sustained system access.
 *
 * @param props.connection
 * @param props.body Admin refresh token request payload.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Admin refresh token request payload. */
    body: ITodoListAdmin.IRefresh;
  };
  export type Body = ITodoListAdmin.IRefresh;
  export type Response = ITodoListAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): ITodoListAdmin.IAuthorized =>
    typia.random<ITodoListAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
