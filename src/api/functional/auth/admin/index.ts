import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListAdmin } from "../../../structures/ITodoListAdmin";

/**
 * Register a new admin account in todo_list_admins and issue initial admin
 * tokens.
 *
 * This API registers a new admin account using the essential fields specified
 * in the todo_list_admins schema: unique email and password_hash, issued at
 * registration time. Each admin account is uniquely identified by the email and
 * has its password securely stored as a hash. Upon successful registration, the
 * endpoint issues a new access token and refresh token, embodying the
 * authentication standard required for future privileged access by admins.
 *
 * The implementation validates the email for uniqueness at the database level
 * (@@unique on email field) and ensures the password is securely hashed before
 * being persisted. The timestamps for creation and update (created_at,
 * updated_at) are automatically managed for audit purposes and are not
 * user-supplied.
 *
 * Admin registration is functionally distinct from standard user registration:
 * only entries in the todo_list_admins table can obtain admin-level access.
 * There is no role overlap; admin accounts do not provide standard user
 * functionality and have no reference to the todos or user tables. This precise
 * separation is both a security and audit measure.
 *
 * For security, registration input is validated for email uniqueness and
 * password completeness. Passwords should be strong, and only hashes ever
 * stored. Token issuance adheres to business rules for admin session management
 * and access control.
 *
 * This operation is necessary for all admin workflow authentication and is the
 * exclusive way to add new admins. All subsequent admin login and session
 * refresh flows rely on successful join.
 *
 * @param props.connection
 * @param props.body Admin registration payload: email and hashed password
 *   (password_hash).
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Admin registration payload: email and hashed password
     * (password_hash).
     */
    body: ITodoListAdmin.ICreate;
  };
  export type Body = ITodoListAdmin.ICreate;
  export type Response = ITodoListAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): ITodoListAdmin.IAuthorized =>
    typia.random<ITodoListAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an admin account from todo_list_admins and issue JWT access and
 * refresh tokens.
 *
 * This API provides administrator login via email and password as defined in
 * todo_list_admins. Email must be unique and previously registered. Password
 * authentication is implemented by comparing the received password, securely
 * hashed, to the stored password_hash field. Admin status is strictly enforced
 * via membership in the todo_list_admins table; regular users are not permitted
 * to authenticate as admins.
 *
 * Upon successful authentication, the endpoint generates and returns new access
 * and refresh tokens, encapsulated as required for privileged sessions. JWT
 * tokens contain admin role and identity claims to distinguish access scope.
 *
 * No further user attributes are referenced, and only fields email and
 * password_hash from the schema are required to validate credentials. The
 * schema requires all admin emails to be unique, reducing impersonation risk.
 *
 * For security, ensure passwords are always transmitted securely and never
 * logged or exposed. Login attempts are limited to prevent brute-force attacks
 * as dictated in higher-level security policy and business rules documents.
 *
 * This endpoint is essential to admin authentication and is required before any
 * privileged or system-wide access is granted. The tokens returned are used for
 * all subsequent admin-level operations until expiration or revocation.
 *
 * @param props.connection
 * @param props.body Authentication payload: admin email and password (plain).
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Authentication payload: admin email and password (plain). */
    body: ITodoListAdmin.ILogin;
  };
  export type Body = ITodoListAdmin.ILogin;
  export type Response = ITodoListAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): ITodoListAdmin.IAuthorized =>
    typia.random<ITodoListAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh an admin JWT access and refresh token set for ongoing sessions.
 *
 * This API endpoint enables administrators to renew their session by presenting
 * a valid refresh token, as per JWT session lifecycle for admin accounts
 * managed in todo_list_admins. It uses the refresh token to validate the
 * admin's identity and re-issues a new pair of access and refresh tokens on
 * success. Only tokens mapped to an existing admin's identity in
 * todo_list_admins are valid for refresh.
 *
 * No extra data fields are referenced from the admin schema beyond identity
 * linkage required by the token. This operation is essential for maintaining
 * secure and continuous admin sessions without repeated credentials entry.
 *
 * Security best practices mandate that expired, revoked, or invalid refresh
 * tokens must be rejected. Tokens are tied directly to admin accounts and
 * cannot be shared or used cross-role or cross-user. The JWT contents encode
 * admin role information and enforce privilege separation from regular users in
 * the system.
 *
 * No password or email is required for this operationâ€”only the refresh token
 * supplied by the client. This endpoint is a foundational part of admin
 * authentication flows and supports stateless, scalable session management for
 * admins.
 *
 * This operation is necessary to maintain admin authentication state and avoid
 * repeated logins. All advanced admin functions require a non-expired valid
 * access token issued through the login or refresh endpoints.
 *
 * @param props.connection
 * @param props.body Refresh token request, typically providing the current
 *   refresh token.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token request, typically providing the current refresh token. */
    body: ITodoListAdmin.IRefresh;
  };
  export type Body = ITodoListAdmin.IRefresh;
  export type Response = ITodoListAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): ITodoListAdmin.IAuthorized =>
    typia.random<ITodoListAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
