import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListUser } from "../../../../structures/ITodoListUser";
import { IPageITodoListUser } from "../../../../structures/IPageITodoListUser";

/**
 * Advanced search and pagination of all user accounts (todo_list_users table)
 * for administrators.
 *
 * This PATCH /users operation lets admin users search, filter, and page through
 * the entire set of registered user accounts. Common use cases include support
 * intervention, compliance review, and operational monitoring. It incorporates
 * fields such as user ID, email, display name, account status, last login time,
 * and creation date. No password or sensitive token information is ever
 * included in responses.
 *
 * Security is a priority: only authenticated users with the 'admin' role can
 * invoke this endpoint. All search and pagination inputs are validated against
 * business rules to prevent unauthorized enumeration or injection. The
 * underlying implementation conforms to the unique and indexed constraints
 * defined in the schema. System administrators should log access to this
 * endpoint for audit purposes.
 *
 * Relevant Prisma schema: todo_list_users. This operation supports business
 * reporting, account management, and acts as an entry point to further
 * user-specific admin actions.
 *
 * @param props.connection
 * @param props.body Filter conditions, search queries, and pagination/sorting
 *   parameters for admin user search.
 * @path /todoList/admin/users
 * @accessor api.functional.todoList.admin.users.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter conditions, search queries, and pagination/sorting parameters
     * for admin user search.
     */
    body: ITodoListUser.IRequest;
  };
  export type Body = ITodoListUser.IRequest;
  export type Response = IPageITodoListUser.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoList/admin/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/admin/users";
  export const random = (): IPageITodoListUser.ISummary =>
    typia.random<IPageITodoListUser.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific user's detailed profile (todo_list_users table) using
 * their unique userId.
 *
 * This GET /users/{userId} operation allows an admin user to access full
 * details of any user account for business or support needs. The returned data
 * includes all core fields: id, email, name, avatar_uri, status, last_login_at,
 * created_at, updated_at, and soft-deletion state (deleted_at), excluding any
 * sensitive password_hash. This operation is essential for compliance reviews,
 * user support, and operational monitoring.
 *
 * Authorization is strictly enforced: only 'admin' role users are permitted.
 * Each access is logged as per compliance and audit policy. If the userId
 * parameter does not correspond to an existing user, the operation returns a
 * 'not found' error. Input validation ensures the userId is a proper UUID
 * before proceeding. This operation supports the overall goal of accountable
 * and transparent user management.
 *
 * @param props.connection
 * @param props.userId Unique identifier (UUID) of the user account to retrieve.
 * @path /todoList/admin/users/:userId
 * @accessor api.functional.todoList.admin.users.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the user account to retrieve. */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListUser;

  export const METADATA = {
    method: "GET",
    path: "/todoList/admin/users/:userId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/admin/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): ITodoListUser => typia.random<ITodoListUser>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update fields of a specific user account (todo_list_users) by admin,
 * including profile and status changes.
 *
 * This PUT /users/{userId} endpoint lets admin users update details in any user
 * account. Allowed fields include display name, status, avatar_uri, and
 * optionally email or password_hash for support scenarios (e.g., account
 * recovery). Updates to the email must maintain unique index constraints and
 * comply with validation established by the business. Any password_hash
 * provided must be securely pre-hashed on the client side.
 *
 * Only administrators are authorized to use this; audit logs record every
 * modification for compliance. On success, the updated user record (excluding
 * credential hash) is returned, reflecting all applied changes. If the provided
 * userId is invalid or does not exist, a clear error is returned. Business
 * rules ensure that soft-deleted users are not updated unless explicitly
 * restored. This operation supports robust account lifecycle management in
 * accordance with privacy and compliance objectives.
 *
 * @param props.connection
 * @param props.userId Unique identifier (UUID) of the user account to update.
 * @param props.body Fields and their new values for the user account update.
 *   Must follow all business validation rules.
 * @path /todoList/admin/users/:userId
 * @accessor api.functional.todoList.admin.users.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the user account to update. */
    userId: string & tags.Format<"uuid">;

    /**
     * Fields and their new values for the user account update. Must follow
     * all business validation rules.
     */
    body: ITodoListUser.IUpdate;
  };
  export type Body = ITodoListUser.IUpdate;
  export type Response = ITodoListUser;

  export const METADATA = {
    method: "PUT",
    path: "/todoList/admin/users/:userId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoList/admin/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): ITodoListUser => typia.random<ITodoListUser>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a user account (todo_list_users) by setting deleted_at; admin
 * only.
 *
 * This DELETE /users/{userId} endpoint lets administrators mark a user account
 * as deleted by populating the deleted_at field (soft delete), following the
 * schema's soft deletion pattern. Such accounts are removed from active
 * listings but remain in the database for retention and compliance. This
 * operation is strictly permitted only for admin users, triggering an audit log
 * entry for every deletion.
 *
 * Input validation guarantees the userId is a valid UUID and that the account
 * exists. Attempts to delete non-existent or already-deleted users return a
 * clear error. Related todos become orphaned or are handled based on cascading
 * rules. The operation is irreversible—no recovery possible unless a dedicated
 * restore function is created. This endpoint supports business needs for
 * privacy, compliance, right-to-be-forgotten scenarios, and account lifecycle
 * control.
 *
 * @param props.connection
 * @param props.userId Unique identifier (UUID) of the user account to
 *   soft-delete.
 * @path /todoList/admin/users/:userId
 * @accessor api.functional.todoList.admin.users.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the user account to soft-delete. */
    userId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/admin/users/:userId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/admin/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
