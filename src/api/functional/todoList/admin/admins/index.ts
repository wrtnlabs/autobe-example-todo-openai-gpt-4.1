import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListAdmin } from "../../../../structures/ITodoListAdmin";
import { IPageITodoListAdmin } from "../../../../structures/IPageITodoListAdmin";

/**
 * List/search all Todo List administrator accounts with filtering and
 * pagination (table: todo_list_admins).
 *
 * This API operation enables the searching and listing of administrator
 * accounts registered in the Todo List system. It provides a secure method to
 * retrieve admin details, supporting filters such as partial email or name
 * matches, privilege level, and account status (e.g., active, suspended).
 * Returned results include all fields from the todo_list_admins Prisma table
 * except sensitive password hashes and soft-deleted accounts (deleted_at is
 * null).
 *
 * The operation is only accessible to authenticated admins with adequate roles,
 * ensuring that sensitive admin data is not exposed to regular users. Results
 * are sorted in descending order of creation time by default, but sorting or
 * pagination options can be specified in the request. This is typically used in
 * system admin dashboards for oversight, onboarding, or compliance checks.
 *
 * Appropriate business validation is applied to prevent excessive query size or
 * abuse. Audit logs may be generated for listing large admin datasets. The
 * response does not include authentication secrets or operational logs
 * unrelated to account registry.
 *
 * @param props.connection
 * @param props.body Search and pagination parameters for admin account
 *   filtering
 * @path /todoList/admin/admins
 * @accessor api.functional.todoList.admin.admins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search and pagination parameters for admin account filtering */
    body: ITodoListAdmin.IRequest;
  };
  export type Body = ITodoListAdmin.IRequest;
  export type Response = IPageITodoListAdmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoList/admin/admins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/admin/admins";
  export const random = (): IPageITodoListAdmin.ISummary =>
    typia.random<IPageITodoListAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific Todo List administrator (table:
 * todo_list_admins).
 *
 * This API endpoint returns the full detail of an administrator account
 * specified by the adminId path parameter. It pulls all non-sensitive fields
 * from the referenced todo_list_admins schema table, supporting administrative
 * review or management.
 *
 * The endpoint requires the caller to be authenticated as an admin. Sensitive
 * authentication data such as password_hash are excluded from the returned
 * object. Returned fields include name, email, status, privilege_level,
 * avatar_uri, timestamp data (created_at, updated_at, last_login_at,
 * last_admin_action_at), and account state.
 *
 * Security enforcement is strict to ensure only admins can access other admin
 * data. Audit logging of access can be implemented in actual business logic to
 * comply with operational policy.
 *
 * @param props.connection
 * @param props.adminId The unique identifier (UUID) of the target administrator
 *   account.
 * @path /todoList/admin/admins/:adminId
 * @accessor api.functional.todoList.admin.admins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The unique identifier (UUID) of the target administrator account. */
    adminId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListAdmin;

  export const METADATA = {
    method: "GET",
    path: "/todoList/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): ITodoListAdmin => typia.random<ITodoListAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the profile or status of a specific administrator account (table:
 * todo_list_admins).
 *
 * This endpoint enables an authenticated admin to update the details of another
 * admin account, referenced by the adminId path parameter. Fields eligible for
 * update include name, avatar_uri, status, privilege_level, and account state
 * (active/suspended/locked), but not authentication secrets or audit history.
 * The operation validates all inputs according to business rules, with
 * server-side enforcement of email uniqueness and privilege change
 * constraints.
 *
 * Password resets or credential changes must be performed via separate
 * dedicated API endpoints for security. The operation is logged as an
 * administrative action, and only fields defined in ITodoListAdmin.IUpdate may
 * be altered by this endpoint. On success, the updated admin account object is
 * returned.
 *
 * @param props.connection
 * @param props.adminId The unique identifier (UUID) of the target administrator
 *   account to update.
 * @param props.body Updated administrator account profile/status information
 *   (excluding password hash)
 * @path /todoList/admin/admins/:adminId
 * @accessor api.functional.todoList.admin.admins.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * The unique identifier (UUID) of the target administrator account to
     * update.
     */
    adminId: string & tags.Format<"uuid">;

    /**
     * Updated administrator account profile/status information (excluding
     * password hash)
     */
    body: ITodoListAdmin.IUpdate;
  };
  export type Body = ITodoListAdmin.IUpdate;
  export type Response = ITodoListAdmin;

  export const METADATA = {
    method: "PUT",
    path: "/todoList/admin/admins/:adminId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoList/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): ITodoListAdmin => typia.random<ITodoListAdmin>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete an administrator account (table: todo_list_admins, hard
 * delete).
 *
 * Invoking this endpoint causes the permanent deletion (hard delete) of the
 * administrator account identified by the adminId path parameter. The deletion
 * action removes the todo_list_admins row and all associated relationships,
 * except where foreign key constraints enforce cascading or retention rules
 * defined by business logic.
 *
 * Access to this operation is strictly limited to admin users, reflecting the
 * seriousness of deleting privileged accounts. Deletion triggers audit logging
 * for compliance, and the operation is irreversible—deleted admin records
 * cannot be restored by normal means. Errors are returned if the target admin
 * does not exist or has already been deleted via soft delete (deleted_at is
 * non-null).
 *
 * Business logic may require additional administrative approval or confirmation
 * for high-privilege removals. The endpoint does not return a response body but
 * will signal completion or failure via standard HTTP status codes.
 *
 * @param props.connection
 * @param props.adminId The unique identifier (UUID) of the administrator
 *   account to delete.
 * @path /todoList/admin/admins/:adminId
 * @accessor api.functional.todoList.admin.admins.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier (UUID) of the administrator account to delete. */
    adminId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
