import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListTodo } from "../../../../structures/ITodoListTodo";
import { IPageITodoListTodo } from "../../../../structures/IPageITodoListTodo";

/**
 * Create a new todo item for the current user (todo_list_todos table).
 *
 * Create a new todo for the authenticated user. The input must contain valid,
 * non-empty content (1–255 trimmed non-control characters) and may contain an
 * optional due date (ISO 8601, not in the past). The system assigns ownership,
 * sets completed=false, and validates that a similar todo has not been
 * submitted within the deduplication window for this user.
 *
 * Upon success, returns the full todo object with assigned identifiers and all
 * relevant business fields. Attempts to create todos for other users, bypassing
 * business validation, or duplicating tasks within the deduplication window are
 * denied with appropriate error messages. This operation allows only the "user"
 * role to create new todos for themselves.
 *
 * Edge cases covered include: whitespace-only content, excessive length,
 * invalid or past due dates, deduplication, and unauthorized submissions.
 * Ownership and per-field validation are enforced strictly at the business
 * logic and API entry level.
 *
 * @param props.connection
 * @param props.body Content for the new todo (1–255 chars, no control
 *   characters, not blank), and optional due date (future or today).
 * @path /todoList/user/todos
 * @accessor api.functional.todoList.user.todos.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Content for the new todo (1–255 chars, no control characters, not
     * blank), and optional due date (future or today).
     */
    body: ITodoListTodo.ICreate;
  };
  export type Body = ITodoListTodo.ICreate;
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "POST",
    path: "/todoList/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/todos";
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of todos for a user
 * (todo_list_todos table).
 *
 * Retrieve the list of todos for the currently authenticated user, supporting
 * advanced search and filtering. Users can retrieve only their own todos, while
 * admins may access todos across users for audit or troubleshooting purposes.
 * The results are ordered with the most recently created tasks first by
 * default. The business rule enforces that only the owner (role: user) or an
 * admin (role: admin) can access a user's todos; unauthorized attempts are
 * denied and logged.
 *
 * This operation applies field-level filters (content, completion status, due
 * date window) and supports pagination parameters like page size and offset.
 * Results exclude todos from soft-deleted users or invalid states. Input
 * validation prevents negative page sizes or offsets, and content queries are
 * trimmed & sanitized. This operation is critical for productivity workflows in
 * the Todo list app, enforcing data privacy and strict row-level access
 * control.
 *
 * Edge cases—such as empty results or invalid filters—are handled gracefully
 * with clear business error messages and do not leak internal state or
 * information.
 *
 * This endpoint is paired with single-todo retrieval, creation, updating, and
 * deletion APIs for full user task management.
 *
 * @param props.connection
 * @param props.body Search criteria (content, completed, due_date), sort and
 *   pagination parameters (offset, page size) for todo list retrieval.
 * @path /todoList/user/todos
 * @accessor api.functional.todoList.user.todos.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria (content, completed, due_date), sort and pagination
     * parameters (offset, page size) for todo list retrieval.
     */
    body: ITodoListTodo.IRequest;
  };
  export type Body = ITodoListTodo.IRequest;
  export type Response = IPageITodoListTodo.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoList/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/todos";
  export const random = (): IPageITodoListTodo.ISummary =>
    typia.random<IPageITodoListTodo.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a single todo by its unique identifier (todo_list_todos
 * table).
 *
 * Retrieve a single todo item's complete details by its ID. The system verifies
 * that the requesting user owns the todo identified by todoId, or that the
 * requester is an admin. Unauthorized access results in a forbidden action
 * error, and a non-existent todoId generates a not-found error with a
 * business-appropriate message.
 *
 * Returned fields include: unique identifier, owner user ID, content (up to 255
 * characters), completion status, due date (if set), timestamps for creation,
 * last update, and (if completed) completion, as well as relational references
 * for audit purposes. The data model prohibits exposure of deleted or
 * inaccessible todos.
 *
 * This operation can be used together with update, mark complete/incomplete,
 * and delete endpoints. The schema enforces ownership and data access at the
 * business logic level for full regulatory compliance and privacy control.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the target todo to retrieve.
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target todo to retrieve. */
    todoId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoList/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a todo item by its unique identifier (todo_list_todos table).
 *
 * Update (edit) an existing todo item by its unique ID. The input may include a
 * new content value (subject to strict validation), an updated due date (if
 * allowed), or a request to change completion status. Ownership is checked:
 * regular users may only edit their own todos, while admins may update any
 * user's todo according to business and compliance policy, with all such
 * actions logged for audit.
 *
 * All string and field edits are validated against business logic: content
 * length/character rules, due date not in the past or before creation,
 * completion status consistency. The operation returns the full, updated todo
 * on success, with proper error responses if not found, unauthorized, or
 * validation fails. Audit logs are generated for admin-driven updates when
 * required by business policy.
 *
 * This endpoint completes the CRUD lifecycle together with create, deletion,
 * and retrieval endpoints.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the target todo to update.
 * @param props.body Update input for the target todo: content (1–255 chars),
 *   completed status, optional due date.
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target todo to update. */
    todoId: string & tags.Format<"uuid">;

    /**
     * Update input for the target todo: content (1–255 chars), completed
     * status, optional due date.
     */
    body: ITodoListTodo.IUpdate;
  };
  export type Body = ITodoListTodo.IUpdate;
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "PUT",
    path: "/todoList/user/todos/:todoId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a specific todo item from the user's todo list
 * (todo_list_todos table).
 *
 * This endpoint allows a user (or admin) to permanently remove a single todo
 * item, identified by its UUID, from the todo_list_todos table. The deleted
 * todo is irreversibly purged; it will not appear in listings, cannot be
 * restored, and all links to this task are erased from the database.
 *
 * To fulfill business logic, the endpoint verifies that the requesting user is
 * either the owner of the todo or holds an admin role. If a user attempts to
 * delete a todo they do not own, or that does not exist, the system denies the
 * operation and returns a business-level error message.
 *
 * When an admin performs a delete, the system must create an associated audit
 * log entry, as described in the audit_logs table specification, to ensure
 * traceability.
 *
 * There is no soft-deletion: records are removed entirely from persistent
 * storage. This behavior is critical for both user privacy and compliance with
 * user-level data removal (right to erasure). Error handling includes returning
 * 'not found' if the todo was already deleted or an invalid UUID is provided.
 *
 * @param props.connection
 * @param props.todoId The unique identifier (UUID) of the todo item to be
 *   deleted.
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier (UUID) of the todo item to be deleted. */
    todoId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
