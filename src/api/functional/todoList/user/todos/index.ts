import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListTodo } from "../../../../structures/ITodoListTodo";
import { IPageITodoListTodo } from "../../../../structures/IPageITodoListTodo";
export * as deleted from "./deleted";

/**
 * Create a new todo for the user in todo_list_todos.
 *
 * Create a new todo item for the authenticated user. Requires a title
 * (business-constrained: 1–255 characters, unique per user among incomplete
 * todos), with optional description (up to 1000 characters) and optional due
 * date (future only, strict format).
 *
 * The operation ensures the owning user is always the caller, ignoring or
 * rejecting foreign or forged ownership claims. All necessary business
 * validations (field lengths, unique constraint, per-user active todo limit if
 * enforced by implementation) are performed. Upon success, the newly created
 * todo item is returned in detail, with all persistence-generated fields
 * populated.
 *
 * @param props.connection
 * @param props.body Todo creation data: title (required), description, due
 *   date, and optional completion status at creation.
 * @path /todoList/user/todos
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Todo creation data: title (required), description, due date, and
     * optional completion status at creation.
     */
    body: ITodoListTodo.ICreate;
  };
  export type Body = ITodoListTodo.ICreate;
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "POST",
    path: "/todoList/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/todos";
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated, searchable list of the authenticated user's todos from
 * todo_list_todos.
 *
 * Retrieve a paginated and filtered list of todo items for the authenticated
 * user. This operation queries the todo_list_todos table, strictly limiting
 * results to the caller's own records in compliance with the application's
 * ownership enforcement policies. Multiple search capabilities are
 * available—sort by due date or creation time, filter by completion status
 * (complete, incomplete, all), and search titles via case-insensitive substring
 * matching.
 *
 * Pagination parameters control page size and number, with defaults and limits
 * aligning with business rules (e.g., 20 items per page, up to 100 per page,
 * reasonable maximums applied). If the authenticated user requests a page
 * beyond available results, an empty result set with bounds information is
 * returned. No data from any other user is ever included.
 *
 * Security is paramount: authorization checks ensure only logged-in users can
 * access this endpoint, and all queries are scope-restricted to the user's own
 * todos by user ID. The response contains todo item summaries suitable for list
 * display, with sufficient detail for client navigation and further item
 * interaction.
 *
 * @param props.connection
 * @param props.body Filter, pagination, status, search, and sorting parameters
 *   for todo list retrieval.
 * @path /todoList/user/todos
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter, pagination, status, search, and sorting parameters for todo
     * list retrieval.
     */
    body: ITodoListTodo.IRequest;
  };
  export type Body = ITodoListTodo.IRequest;
  export type Response = IPageITodoListTodo.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoList/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/todos";
  export const random = (): IPageITodoListTodo.ISummary =>
    typia.random<IPageITodoListTodo.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details for a single todo owned by the user from todo_list_todos.
 *
 * Retrieve a single todo's full detail for the authenticated user. This
 * operation fetches a todo item by its unique identifier (todoId), ensuring it
 * belongs to the caller according to privacy compliance and ownership
 * enforcement. All detail fields are included in the response (title, optional
 * description, due date, completion status and timestamp, creation and update
 * times).
 *
 * Strict authorization and permission checks mean that only the owner can view
 * this resource; queries for nonexistent or non-owned todoId result in a
 * not-found or permission-denied error. Implementation must not expose whether
 * a missing todoId ever existed if not owned by the current user.
 *
 * Response data is suitable for detailed todo views, edit forms, or item
 * inspection in client UIs.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the todo item to retrieve. Must be a
 *   valid UUID string.
 * @path /todoList/user/todos/:todoId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the todo item to retrieve. Must be a valid UUID
     * string.
     */
    todoId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoList/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a user-owned todo by todoId in todo_list_todos.
 *
 * Update an existing todo item, modifying fields such as title (with per-user
 * incomplete uniqueness enforced, 1–255 chars), description (max 1000), due
 * date (must be valid/future), is_completed status, and completed_at where
 * appropriate. All ownership and existence rules apply: only allows
 * modification if the todo exists and belongs to the caller.
 *
 * Timestamps for last update are strictly set by the service. Any attempted
 * modification of created_at/user_id is ignored and treated as invalid.
 * Violations of validation rules or business invariants (such as duplicate
 * incomplete-title) result in error responses.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the todo to update. Must be a valid
 *   UUID string.
 * @param props.body Fields to update on the todo (title, description, status,
 *   due date).
 * @path /todoList/user/todos/:todoId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the todo to update. Must be a valid UUID string. */
    todoId: string & tags.Format<"uuid">;

    /** Fields to update on the todo (title, description, status, due date). */
    body: ITodoListTodo.IUpdate;
  };
  export type Body = ITodoListTodo.IUpdate;
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "PUT",
    path: "/todoList/user/todos/:todoId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a todo item by todoId from todo_list_todos (hard delete).
 *
 * Permanently delete a todo the user owns. This is a destructive,
 * non-reversible removal from todo_list_todos. Before performing the delete,
 * ensures that the specified todoId exists and belongs to the calling user—no
 * cross-user or foreign deletes allowed. No 'soft delete' or logical deletion
 * marker is set: once removed, the todo disappears from active lists. However,
 * a separate append-only deletion audit log (todo_list_deleted_todo_logs)
 * records the event for business compliance and transient self-service
 * history.
 *
 * Attempts to delete a non-existent or non-owned todo return a generic
 * not-found error (do not reveal details about resources not owned by the
 * caller). No response body is required on success.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the todo to be deleted. Must be a
 *   valid UUID string.
 * @path /todoList/user/todos/:todoId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the todo to be deleted. Must be a valid UUID
     * string.
     */
    todoId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
